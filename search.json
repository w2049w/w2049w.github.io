[{"title":"mysql/procedure","url":"/2020/05/23/mysql/procedure/","content":"# 存储过程\n\n**什么是存储过程：**\n\n> 事先经过编译并存储在数据库中的一段sql语句的集合。\n>\n> 类似于java中的方法\n\n\n\n**使用好处**\n\n1. 简化应用开发人员的很多工作\n2. 减少数据在数据库和应用服务器之间的传输\n3. 提高了数据处理的效率\n4. \n\n一组预先编译好的SQL语句的集合，理解成批处理语句\n\n## 创建语法\n\n```\nCREATE PROCEDURE 存储过程名(参数列表)\nBEGIN\n\n\t存储过程体（一组合法的SQL语句）\nEND\n```\n\n\n\n**参数列表包含三部分**\n\n- 参数模式\n- 参数名\n- 参数类型\n\n> 例：in stuname varchar(20)\n\n\n\n**参数模式：**\n\n`in`：该参数可以作为输入，也就是该参数需要调用方传入值\n\n`out`：该参数可以作为输出，也就是该参数可以作为返回值\n\n`inout`：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值\n\n\n\n- 如果存储过程体仅仅只有一句话，begin end可以省略\n\n- 存储过程体中的每条sql语句的结尾要求必须加分号。\n\n- 存储过程的结尾可以使用 delimiter 重新设置（避免与存储过程体的分号混淆）\n\n  ```\n  delimiter 结束标记\n  # 例\n  delimiter $\n  ```\n\n**例：**\n\n插入到admin表中五条记录\n\n``` mysql\nUSE girls;\n\nDELIMITER $\nCREATE PROCEDURE myp1()\nBEGIN\n\tINSERT INTO admin(username,`password`) \n\tVALUES\n\t('john1','0000'),('lily','0000'),('rose','0000'),('jack','0000'),('tom','0000');\nEND $\n```\n\n## 调用语法\n\n``` \nCALL 存储过程名(实参列表);\n```\n\n``` mysql\nCALL myp1();\n```\n\n\n\n## 创建带in模式参数的存储过程\n\n创建存储过程实现 根据女神名，查询对应的男神信息\n\n``` mysql\nDELIMITER $\nCREATE PROCEDURE myp2(IN beautyName VARCHAR(20))\nBEGIN\n\tSELECT bo.*\n\tFROM boys bo\n\tRIGHT JOIN beauty b ON bo.id = b.boyfriend_id\n\tWHERE b.name=beautyName;\nEND $\n```\n\n``` mysql\nCALL myp2('赵敏');\n```\n\n创建存储过程实现，判断用户是否登录成功\n\n``` mysql\nDELIMITER $\nCREATE PROCEDURE myp3(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))\nBEGIN\n\tDECLARE result INT DEFAULT 0;\t#声明并初始化\n\t\n\tSELECT COUNT(*) INTO result\t#赋值\n\tFROM admin\n\tWHERE admin.username = username\n\tAND admin.password = PASSWORD;\n\t\n\tSELECT IF(result>0,'成功','失败');\t#使用\nEND $\n```\n\n\n\n``` mysql\nCALL myp3('john','8888');\nCALL myp3('john','1234');\n```\n\n\n\n## 创建out模式参数的存储过程\n\n根据输入的女神名，返回对应的男神名\n\n``` mysql\nDELIMITER $\nCREATE PROCEDURE myp4(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))\nBEGIN\n\tSELECT bo.boyname INTO boyname\n\tFROM boys bo\n\tRIGHT JOIN\n\tbeauty b ON b.boyfriend_id = bo.id\n\tWHERE b.name=beautyName ;\nEND $\n```\n\n``` mysql\n# 调用 使用自定义变量接收\nCALL myp4('赵敏',@name);\nSELECT @name;\n```\n\n根据输入的女神名，返回对应的男神名和魅力值\n\n``` mysql\nDELIMITER $\nCREATE PROCEDURE myp5(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT) \nBEGIN\n\tSELECT boys.boyname ,boys.usercp INTO boyname,usercp\n\tFROM boys \n\tRIGHT JOIN\n\tbeauty b ON b.boyfriend_id = boys.id\n\tWHERE b.name=beautyName ;\n\t\nEND $\n```\n\n``` mysql\nCALL myp5('小昭',@name,@cp);\nSELECT @name,@cp;\n```\n\n\n\n## 创建带inout模式参数的存储过程\n\n传入a和b两个值，最终a和b都翻倍并返回\n\n``` mysql\nDROP PROCEDURE IF EXISTS myp5;\n\nDELIMITER $\nCREATE PROCEDURE myp5(INOUT a INT,INOUT b INT)\nBEGIN\n\n\tSET a:=a*2;\n\tSET b:=b*2;\n\nEND $\n```\n\n``` mysql\nSET @m=10;\nSET @n=20;\nCALL myp5(@m,@n);\nSELECT @m,@n;\n```\n\n\n\n## 查看存储过程的信息\n\n``` mysql\nSHOW CREATE PROCEDURE myp5;\n```\n\n"},{"title":"Docker基本使用","url":"/2020/05/23/docker/docker/","content":"\n# Docker基本使用\n\n**Docker**是一个开源的应用容器引擎；是一个轻量级容器技术；\n\nDocker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；\n\n运行中的这个镜像称为容器，容器启动是非常快速的。\n\n\n\n![](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/20180303145450.png)\n\n\n\n![](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/20180303145531.png)\n\n## 核心概念\n\n`docker主机(Host)`：安装了Docker程序的机器（Docker直接安装在操作系统之上）；\n\n`docker客户端(Client)`：连接docker主机进行操作；\n\n`docker仓库(Registry)`：用来保存各种打包好的软件镜像；\n\n`docker镜像(Images)`：软件打包好的镜像；放在docker仓库中；\n\n`docker容器(Container)`：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用\n\n![](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/20180303165113.png)\n\n使用Docker的步骤：\n\n1. 确认要安装docker的系统的linux内核高于`3.10`，低于3.10使用`yum update`更新\n\n   ```shell\n   uname -r\n   ```\n\n2. 安装docker\n\n   ```shell\n   yum install docker\n   ```\n\n3. 查看docker版本\n\n   ```shell\n   docker -v\n   ```\n\n4. 查看docker状态\n\n   ```shell\n   service docker status\n   ```\n\n5. 启动docker\n\n   ```shell\n   service docker start\n   ```\n\n6. 停止docker\n\n   ```shell\n   service docker stop\n   ```\n\n7. 设置docker开机自启\n\n   ```shell\n   systemctl enable docker\n   ```\n\n   \n\n\n\n## docker常用命令\n\n### 镜像操作\n\n| 操作 | 命令                                            | 说明                                                     |\n| ---- | ----------------------------------------------- | -------------------------------------------------------- |\n| 检索 | docker  search 关键字  eg：docker  search redis | 我们经常去docker  hub上检索镜像的详细信息，如镜像的TAG。 |\n| 拉取 | docker pull 镜像名:tag                          | :tag是可选的，tag表示标签，多为软件的版本，默认是latest  |\n| 列表 | docker images                                   | 查看所有本地镜像                                         |\n| 删除 | docker rmi image-id                             | 删除指定的本地镜像                                       |\n\n### 修改镜像源\n\n修改 /etc/docker/daemon.json ，写入如下内容（如果文件不存在请新建该文件）\n\n```\nvim /etc/docker/daemon.json\n\n#　内容：\n\n{\n\"registry-mirrors\":[\"http://hub-mirror.c.163.com\"]\n}\n```\n\n| 国内镜像源        | 地址                                 |\n| ----------------- | ------------------------------------ |\n| Docker 官方中国区 | https://registry.docker-cn.com       |\n| 网易              | http://hub-mirror.c.163.com          |\n| 中国科技大学      | https://docker.mirrors.ustc.edu.cn   |\n| 阿里云            | https://pee6w651.mirror.aliyuncs.com |\n\n\n\n## 容器操作\n\n**以tomcat为例：**\n\n1. 下载tomcat镜像\n\n   ```shell\n   docker pull tomcat\n   ```\n\n   如需选择具体版本，可以在<https://hub.docker.com/>搜索tomcat\n\n   ```shell\n   docker pull tomcat:7.0.96-jdk8-adoptopenjdk-hotspot\n   ```\n\n2. 根据镜像启动容器，不加TAG默认latest，如果没有下载latest会先去下载再启动\n\n   ```shell\n   docker run --name mytomcat -d tomcat:latest\n   ```\n\n   `--name`：给容器起个名字\n\n   `-d`：后台启动，不加就是前端启动，然后你就只能开一个新的窗口连接，不然就望着黑乎乎的窗口，啥也干不了，`Ctrl+C`即可退出，当然，容器也会关闭\n\n3. 查看运行中的容器\n\n   ```shell\n   docker ps\n   ```\n\n4. 停止运行中的容器\n\n   ```shell\n   docker stop  容器的id\n   \n   # 或者\n   \n   docker stop  容器的名称，就是--name给起的哪个名字\n   ```\n\n5. 查看所有的容器\n\n   ```shell\n   docker ps -a\n   ```\n\n6. 启动容器\n\n   ```shell\n   docker start 容器id/名字\n   ```\n\n7. 删除一个容器\n\n   ```shell\n   docker rm 容器id/名字\n   ```\n\n8. 启动一个做了端口映射的tomcat\n\n   ```shell\n    docker run -d -p 8888:8080 tomcat\n   ```\n\n   `-d`：后台运行\n   `-p`: 将主机的端口映射到容器的一个端口    `主机端口(8888)`:`容器内部的端口(8080)`\n\n   外界通过主机的8888端口就可以访问到tomcat，前提是8888端口开放\n\n9. 关闭防火墙\n\n   ```shell\n   # 查看防火墙状态\n   service firewalld status\n   \n   # 关闭防火墙\n   service firewalld stop\n   ```\n\n10. 查看容器的日志\n\n    ```shell\n    docker logs 容器id/名字\n    ```\n\n    \n\n**以mysql为例：**\n\n``` shell\n# 拉取镜像\ndocker pull mysql:5.7.28\n\n# 运行mysql容器\n docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7.28\n```\n\n`--name mysql`：容器的名字是mysql；\n\n`MYSQL_ROOT_PASSWORD=root`：root用户的密码是root (必须指定)\n\n连接容器内mysql\n\n在使用 **-d** 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：\n\n- **docker attach**\n- **docker exec**：推荐使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。\n\n```shell\ndocker exec -it mysql bash\n```\n\n`-i`: 交互式操作。\n\n`-t`: 终端。\n\n`mysql`: 名为mysql的 镜像。\n\n`bash`：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash，也可以用`/bin/bash`。\n\n连接上以后就可以正常使用mysql命令操作了\n\n```shell\nmysql -uroot -proot\n```\n\n\n\n直接使用端口映射更加方便\n\n```shell\ndocker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7.28\n```\n\n","tags":["docker"],"categories":["docker"]},{"title":"hibernate加载策略","url":"/2020/05/23/hibernate/loadmethod/","content":"\n# 加载策略\n\n## 类级别的加载策略\n\n`get`：**立即检索**。get方法一执行，立即查询所有字段的数据。\n\n`load`：**延迟检索**。默认情况，load方法执行后，如果只使用OID的值不进行查询，如果要使用其他属性值才查询\n\n需要断点调试查看\n\n```java\npackage club.zzrfdsnsyl.demo.a_OID;\n\nimport org.hibernate.Session;\nimport org.hibernate.Transaction;\nimport org.junit.Test;\n\nimport club.zzrfdsnsyl.Utils.HbUtil;\nimport club.zzrfdsnsyl.domain.Customer;\n\n/**\n * 就是 sessino.get()和.load()\n * @author SYL\n *\n */\npublic class OID {\n\t\n\t@Test\n\tpublic void t1() {\n\t\tSession session = HbUtil.getCurrentSession();\n\t\tTransaction transaction = session.beginTransaction();\n\t\tCustomer customer = session.get(Customer.class, 1L);\n\t\tSystem.out.println(customer);\n\t\ttransaction.commit();\n\t\tsession.close();\n\t}\n\t@Test\n\tpublic void t2() {\n\t\tSession session = HbUtil.getCurrentSession();\n\t\tTransaction transaction = session.beginTransaction();\n\t\tCustomer customer = session.load(Customer.class, 2L);\n\t\tSystem.out.println(customer);\n\t\ttransaction.commit();\n\t\tsession.close();\n\t}\n}\n\n```\n\n\n\n## 关联级别的加载策略\n\n","tags":["hibernate"],"categories":["hibernate"]},{"title":"hibernate多表关联查询","url":"/2020/05/23/hibernate/manytable/","content":"\n# Hibernate的多表关联关系映射\n\n一对多：主表的主键 与 从表外键 形成 **主外键关系**\n\n多对多：提供**中间表**（从表），提供2个字段（外键）分别对应两个主表。\n\n一对一: **主外键关系**\n\n\n\n## 一对多，多对一\n\n例：客户(`Customer`)和联系人(`LinkMan`)\n\n一个客户对应多个联系人\n\n`Customer`实体类添加`LinkMan`的集合\n\n```java\n\t//表达一对多关系\n\tprivate Set<LinkMan> linkMans=new HashSet<LinkMan>();\n```\n\n\n\n`Customer`映射文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE hibernate-mapping PUBLIC \n    \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n    \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n    <hibernate-mapping package=\"club.zzrfdsnsyl.domain\">\n    \t<class name=\"Customer\">\n    \t\t<id name=\"cust_id\">\n    \t\t\t<generator class=\"native\"></generator>\n    \t\t</id>\n    \t\t<property name=\"cust_name\"></property>\n    \t\t<property name=\"cust_source\"></property>\n    \t\t<property name=\"cust_industry\"></property>\n    \t\t<property name=\"cust_level\"></property>\n    \t\t<property name=\"cust_linkman\"></property>\n    \t\t<property name=\"cust_phone\"></property>\n    \t\t<property name=\"cust_mobile\"></property>\n    \t\t<!-- \n    \t\t\t配置关联\n    \t\t\tset：集合类型\n    \t\t\tname：属性名称\n    \t\t\tinverse属性: 配置关系是否维护. \n\t\t  \t\ttrue: customer不维护关系\n\t\t  \t\tfalse(默认值): customer维护关系\n    \t\t\tinverse属性: 性能优化.提高关系维护的性能.\n\t\t  \t\t原则: 无论怎么放弃,总有一方必须要维护关系.\n\t\t  \t\t一对多关系中: 一的一方放弃.也只能一的一方放弃.多的一方不能放弃.\n    \t\t -->\n    \t\t<!-- \n    \t\t\tcolumn:多的一方的外键名(也就是本表的主键)\n    \t\t\t\n    \t\t-->\n    \t\t <!--\n   \t\t\t\t一对多\n   \t\t\t\tclass:多的一方的类名\n    \t\t-->\n    \t\t<set name=\"linkMans\">\n    \t\t\t<key column=\"lkm_cust_id\"></key>\n    \t\t\t<one-to-many class=\"LinkMan\"/>\n    \t\t</set>\n    \t</class>\n    </hibernate-mapping>\n```\n\n\n\n`LinkMan`实体类添加`Customer`类型的属性\n\n```java\n\t//表达多对一关系\n\tprivate Customer customer ;\n```\n\n\n\nLinkMan实体映射文件\n\n``` xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE hibernate-mapping PUBLIC \n    \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n    \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n    <hibernate-mapping package=\"club.zzrfdsnsyl.domain\">\n    \t<class name=\"LinkMan\" table=\"linkman\">\n    \t\t<id name=\"lkm_id\">\n    \t\t\t<generator class=\"native\"></generator>\n    \t\t</id>\n    \t\t<property name=\"lkm_gender\"></property>\n    \t\t<property name=\"lkm_name\"></property>\n    \t\t<property name=\"lkm_phone\"></property>\n    \t\t<property name=\"lkm_email\"></property>\n    \t\t<property name=\"lkm_qq\"></property>\n    \t\t<property name=\"lkm_mobile\"></property>\n    \t\t<property name=\"lkm_memo\"></property>\n    \t\t<property name=\"lkm_position\"></property>\n    \t\t<!--\n    \t\t\t配置关联 \n    \t\t\tname:一的一方的属性名\n    \t\t\tclass:一的一方的类路径\n    \t\t\tcolumn：外键名\n    \t\t -->\n   \t\t   <!-- \n\t\t \t\t级联操作:\tcascade\n\t\t \t\tsave-update: 级联保存更新\n\t\t \t\tdelete:级联删除\n\t\t \t\tall:save-update+delete\n\t\t \t\t级联操作: 简化操作.目的就是为了少些两行代码.\n\t\t  \t-->\n    \t\t<many-to-one cascade=\"save-update\" name=\"customer\" class=\"Customer\" column=\"lkm_cust_id\">\n    \t\t</many-to-one>\n    \t</class>\n    </hibernate-mapping>\n```\n\n\n\n```java\n\t@Test\n\t/**\n\t * \t添加客户与联系人\n\t */\n\tpublic void t1() {\n\t\tTransaction transaction = session.beginTransaction();\n\t\tCustomer customer=new Customer();\n\t\tcustomer.setCust_name(\"阿里巴巴\");\n\t\t\n\t\tLinkMan linkMan01=new LinkMan();\n\t\tlinkMan01.setLkm_name(\"利达\");\n\t\tlinkMan01.setCustomer(customer);\n\t\t\n\t\tLinkMan linkMan02=new LinkMan();\n\t\tlinkMan02.setLkm_name(\"大卫王\");\n\t\tlinkMan02.setCustomer(customer);\n\t\t\n\t\tcustomer.getLinkMans().add(linkMan01);\n\t\tcustomer.getLinkMans().add(linkMan02);\n\t\t\n\t\tsession.save(customer);\n\t\tsession.save(linkMan01);\n\t\tsession.save(linkMan02);\n\t\t\n\t\ttransaction.commit();\n\t}\n\t\n```\n\n\n\n## 设置外键维护的方式\n\n修改Customer的配置文件，**添加一个inverse选项**\n\ninverse是hibernate双向关系中的基本概念。\n\ninverse的真正作用就是指定由哪一方来维护之间的关联关系。当一方中指定了“inverse=false”（默认），那么那一方就有责任负责之间的关联关系。\n\n\n\n## cascade级联\n\n级联保存,级联修改. 保存`Customer`(客户)时,同时保存`LinkMan`(联系人)\n\n或者保存`LinkMan`(联系人)时,同时保存`Customer`(客户)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE hibernate-mapping PUBLIC \n    \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n    \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n    <hibernate-mapping package=\"club.zzrfdsnsyl.domain\">\n    \t<class name=\"LinkMan\" table=\"linkman\">\n            \n           ......\n            \n   \t\t   <!-- \n\t\t \t\t级联操作:\tcascade\n\t\t \t\tsave-update: 级联保存更新\n\t\t \t\tdelete:级联删除\n\t\t \t\tall:save-update+delete\n\t\t\t\tdelete-orphan:删除所有和当前对象解除关联关系的对象\n\t\t\t\tall-delete-orphan: \n\t\t\t\t\t在解除父子关系时,自动删除不属于父对象的子对象, 也支持级联删除和级联保存更新.\n\n\t\t \t\t级联操作: 简化操作.目的就是为了少些两行代码.\n\t\t  \t-->\n    \t\t<many-to-one cascade=\"save-update\" name=\"customer\" class=\"Customer\" column=\"lkm_cust_id\">\n    \t\t</many-to-one>\n    \t</class>\n    </hibernate-mapping>\n```\n\n\n\n```java\n\tpublic void t2() {\n\t\tTransaction transaction = session.beginTransaction();\n\t\tCustomer customer=new Customer();\n\t\tcustomer.setCust_name(\"海尔\");\n\t\t\n\t\tLinkMan linkMan01=new LinkMan();\n\t\tlinkMan01.setLkm_name(\"的撒达\");\n\t\tlinkMan01.setCustomer(customer);\n\t\t\n\t\tLinkMan linkMan02=new LinkMan();\n\t\tlinkMan02.setLkm_name(\"大蒜\");\n\t\tlinkMan02.setCustomer(customer);\n\t\t\n\t\tcustomer.getLinkMans().add(linkMan01);\n\t\tcustomer.getLinkMans().add(linkMan02);\n\t\t\n//\t\tsession.save(customer); 设置了级联会自动保存\n\t\tsession.save(linkMan01);\n\t\tsession.save(linkMan02);\n\t\t\n\t\ttransaction.commit();\n\t}\n\t\n```\n\n\n\n## 多对多\n\nUser(用户)和`Role`(角色)，中间表`sys_user_role`\n\nUser实体类\n\n``` java\n\t//表达多对多\n\tprivate Set<Role> roles = new HashSet<Role>();\n```\n\nUser实体类映射文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE hibernate-mapping PUBLIC \n    \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n    \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n    <hibernate-mapping package=\"club.zzrfdsnsyl.domain\">\n    \n    \t<class name=\"User\" table=\"sys_user\">\n    \t\t<id name=\"user_id\">\n    \t\t\t<generator class=\"native\"></generator>\n    \t\t</id>\n    \t\t<property name=\"user_code\"></property>\n    \t\t<property name=\"user_name\"></property>\n    \t\t<property name=\"user_password\"></property>\n    \t\t<property name=\"user_state\"></property>\n    \t\t<set name=\"roles\" table=\"sys_user_role\" cascade=\"save-update\">\n    \t\t\t<key column=\"user_id\"></key>\n    \t\t\t<many-to-many class=\"Role\" column=\"role_id\"></many-to-many>\n    \t\t</set>\n    \t</class>\n    </hibernate-mapping>\n```\n\nRole实体类\n\n``` java\n\t//表达多对多\n\tprivate Set<User> users = new HashSet<User>();\n```\n\nRole实体类映射文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE hibernate-mapping PUBLIC \n    \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n    \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n    <hibernate-mapping package=\"club.zzrfdsnsyl.domain\">\n    \t<class name=\"Role\" table=\"sys_role\">\n    \t\t<id name=\"role_id\">\n    \t\t\t<generator class=\"native\"></generator>\n    \t\t</id>\n    \t\t<property name=\"role_name\"></property>\n    \t\t<property name=\"role_memo\"></property>\n    \t\t<!-- \n    \t\t\t关联映射\n    \t\t\tname:关联的集合属性名\n    \t\t\ttable:中间表的名称\n    \t\t\tkey column:当前表在中间表的外键名名称\n    \t\t\tmany-to-many class:关联表的类实体路径\n    \t\t\tmany-to-many column:关联表在中间表中的列名（外键名）\n   \t\t\t -->\n    \t\t<set name=\"users\" table=\"sys_user_role\" inverse=\"true\">\n    \t\t\t<key column=\"role_id\"></key>\n    \t\t\t<many-to-many class=\"User\" column=\"user_id\"></many-to-many>\n    \t\t</set>\n    \t</class>\n    </hibernate-mapping>\n    \n```\n\n\n\n\n\n```java\npackage club.zzrfdsnsyl.demo;\n\nimport org.hibernate.Session;\nimport org.hibernate.Transaction;\nimport org.junit.Test;\n\nimport club.zzrfdsnsyl.Utils.HbUtil;\nimport club.zzrfdsnsyl.domain.Role;\nimport club.zzrfdsnsyl.domain.User;\n\n/**\n * 多对多\n * @author SYL\n *\n */\npublic class ManyToMany {\n\tprivate Session session=HbUtil.getCurrentSession();\n\t\n\t@Test\n\tpublic void t1() {\n\t\tTransaction transatction = session.beginTransaction();\n\t\t//创建user\n\t\tUser user1=new User();\n\t\tuser1.setUser_name(\"赵XX\");\n\t\tUser user2=new User();\n\t\tuser2.setUser_name(\"杨XX\");\n\t\tUser user3=new User();\n\t\tuser3.setUser_name(\"孙XX\");\n\t\t\n\t\t//创建角色\n\t\tRole role1=new Role();\n\t\trole1.setRole_name(\"CEO\");\n\t\tRole role2=new Role();\n\t\trole2.setRole_name(\"男公关\");\n\t\tRole role3=new Role();\n\t\trole3.setRole_name(\"则所清洁员\");\n\t\t\n\t\t//对应关系\n\t\tuser1.getRoles().add(role2);\n\t\tuser1.getRoles().add(role3);\n\t\t\n\t\tuser2.getRoles().add(role3);\n\t\t\n\t\tuser3.getRoles().add(role1);\n\t\t\n\t\t//持久化\n\t\tsession.save(user1);\n\t\tsession.save(user2);\n\t\tsession.save(user3);\n\t\tsession.save(role1);\n\t\tsession.save(role2);\n\t\tsession.save(role3);\n\t\t\n\t\ttransatction.commit();\n\t}\n\t\n\t/**\n\t * \t多表的级联 给user添加级联\n\t */\n\t@Test\n\tpublic void t2() {\n\t\tTransaction transatction = session.beginTransaction();\n\t\t//创建角色\n\t\tRole r1=new Role();\n\t\tr1.setRole_name(\"行政管理\");\n\t\tRole r2=new Role();\n\t\tr2.setRole_name(\"人事管理\");\n\t\tRole r3=new Role();\n\t\tr3.setRole_name(\"财政管理\");\n\t\t\n\t\tUser user = session.get(User.class, 3L);\n\t\tuser.getRoles().add(r1);\n\t\tuser.getRoles().add(r2);\n\t\tuser.getRoles().add(r3);\n\t\ttransatction.commit();\n\t}\n}\n\n```\n\n","tags":["hibernate"],"categories":["hibernate"]},{"title":"hibernate实体的状态","url":"/2020/05/23/hibernate/status/","content":"\n\n# Hibernate 实体的状态\n\n实体Entity有三种状态，`瞬时状态`、`持久状态`、`脱管状态`\n\n瞬时状态：transient,  session没有缓存，数据库也没有记录，oid没有值\n\n持久状态：persistent,  session有缓存，数据库也有记录,oid有值\n\n脱管状态/游离状态：detached，session没有缓存，数据库有记录,oid有值\n\n\n\n## 瞬时转持久\n\n新创建的一个对象，经过save,或者savaOrUpdate调用后，会变成持久状态\n\n\n\n## 持久转脱管\n\n`load`，`get`返回的对象是持久状态的，当session关闭或者清除后，对象变成脱管状态\n\n\n\n```java\npackage club.zzrfdsnsyl.demo.a_threeState;\n\nimport java.io.Serializable;\n\nimport org.hibernate.Session;\nimport org.hibernate.Transaction;\nimport org.junit.Test;\n\nimport club.zzrfdsnsyl.Utils.HbUtil;\nimport club.zzrfdsnsyl.domain.Customer;\n\n/**\n * 持久化对象的三种状态\n * @author SYL\n *\t瞬时\t\t持久\t\t游离\n *\t瞬时\tsave()/get()-->持久\n *\t游离 update()-->持久\n *\t持久 delete()-->瞬时\n *\t瞬时/游离 saveOrUpdate()-->持久\n */\npublic class State {\n\t/**\n\t * 瞬时状态 无OID 没有与session关联\n\t */\n\t@Test\n\tpublic void transientState() {\n\t\tCustomer customer=new Customer();\n\t\tcustomer.setCust_name(\"郑州财经学院\");\n\t}\n    \n\t/**\n\t * 持久化状态 有OID 与session关联\n\t */\n\t@Test\n\tpublic void persistent() {\n\t\tCustomer customer=new Customer();\n\t\tcustomer.setCust_name(\"郑州财经学院\");\n\t\tSession session = HbUtil.openSession();\n\t\tSerializable save = session.save(customer); \n\t\tSystem.out.println(save);\n\t}\n\t/**\n\t * 游离状态 \n\t */\n\t@Test\n\tpublic void detached() {\n\t\tCustomer customer=new Customer();\n\t\tcustomer.setCust_name(\"郑州财经学院\");\n\t\tSession session = HbUtil.openSession();\n\t\tTransaction transaction = session.beginTransaction();\n\t\tSerializable save = session.save(customer);\n\t\tSystem.out.println(save);\n\t\ttransaction.commit();\n\t\tsession.close(); //session关闭 与session没联系了\n\t}\n\t\n\t\n\t/**\n\t * 持久化状态 有OID 与session关联\n\t */\n\t@Test\n\tpublic void persistent02() {\n\t\tSession session = HbUtil.openSession();\n\t\tTransaction transaction = session.beginTransaction();\n\t\tCustomer customer = session.get(Customer.class, 1L); \n\t\tcustomer.setCust_name(\"小米科技\");\n\t\t//无需.update(...);\n\t\ttransaction.commit();\n\t\tsession.close();\n\t\t\n\t}\n}\n\n```\n\n\n\n## 总结\n\n`get`、`load`、`createQuery`、`createCriteria` 等从数据库获得的都是持久态\n\n瞬时状态执行`save`、`update`、`saveOrUpdate`之后变成持久状态\n\n\n\n持久态转换脱管态\n\n1. session.close () 关闭\n2. session.clear() 清除所有\n3. session.evict(obj) 清除指定的PO对象\n\n","tags":["hibernate"],"categories":["hibernate"]},{"title":"hibernate缓存","url":"/2020/05/23/hibernate/cache/","content":"\n# Hibernate缓存\n\n## 一级缓存\n\n一级缓存：又称为session级别的缓存。\n\n当获得一次会话（session），hibernate在session中创建多个集合（map），用于存放操作数据（PO对象），**为程序优化服务**，如果之后需要相应的数据，hibernate优先从session缓存中获取，如果有就使用；如果没有再查询数据库。\n\n**当session关闭时，一级缓存销毁。**\n\n\n\n```java\npackage club.zzrfdsnsyl.demo.b_cache;\n\nimport org.hibernate.Session;\nimport org.hibernate.Transaction;\nimport org.junit.Test;\n\nimport club.zzrfdsnsyl.Utils.HbUtil;\nimport club.zzrfdsnsyl.domain.Customer;\n\n/**\n * 一级缓存\n * @author SYL\n *\n */\npublic class First_cache {\n\t\n\t@Test\n\tpublic void test_first_cache() {\n\t\tSession session = HbUtil.openSession();\n\t\tCustomer customer = session.get(Customer.class, 1L);\n\t\tCustomer customer2 = session.get(Customer.class, 1L);\n\t\tSystem.out.println(customer==customer2);\n\t\tSystem.out.println(customer.equals(customer2));\n\t\tsession.close();\n\t}\n\t\n\t\n\t/**\n\t * 持久化就是把对象放到session缓存\n\t */\n\t@Test\n\tpublic void test() {\n\t\tSession session = HbUtil.openSession();\n\t\tCustomer customer=new Customer();\n\t\tcustomer.setCust_id(1L);\t//游离状态 有OID没有与session绑定 \n\t\tcustomer.setCust_name(\"百度公司\");;\n\t\tsession.update(customer);\t//持久化状态\n\t\tCustomer customer2 = session.get(Customer.class,1L);\n\t\tSystem.out.println(customer2.getCust_name()); //从缓存中找 有则不会去数据库\n\t\tsession.close();\n\t}\n}\n\n```\n\n## 清除一级缓存\n\n1. `session.clear()` 清除所有缓存\n2. `session.evict(obj)` 清除指定的对象缓存\n\n\n\n## 一级缓存快照\n\n快照：与一级缓存存放位置是一样，对一级缓存数据备份。\n\n保证数据库的数据与 一级缓存的数据必须一致。\n\n如果一级缓存**修改了**，在执行commit提交时，将自动刷新一级缓存。执行update语句，将一级缓存的数据更新到数据库。\n\n\n\n!> HQL的结果会进行一级缓存，SQL的结果不会添加到一级缓存\n\n","tags":["hibernate"],"categories":["hibernate"]},{"title":"jsp","url":"/2020/05/23/javaweb/jsp/","content":"\n# Jsp(JavaServer Pages)\n\n## jsp脚本\n\n`<%!java代码%>`：会被翻译成servlet的成员的内容\n\n```jsp\n//下面的代码在一个标签中声明了一个变量和一个方法：\n<%!\n    String color[] = {\"red\", \"green\", \"blue\"};\n    String getColor(int i){\n        return color[i];\n    }\n%>\n```\n\n`<%java代码%>`：内部的java代码翻译到service方法的内部\n\n```jsp\n<%! int count = 0; %>\n<% count++; %>\n```\n\n`<%=java变量或表达式>`：会被翻译成service方法内部out.print()\n\n```jsp\n<%= count%>\n```\n\n\n\n## jsp注释\n\n1. html注释：`<!--注释内容-->` ---可见范围 jsp源码、翻译后的servlet、页面\t\t\t\t\t\t\t\t\t\t\t\t显示html源码\n2. java注释：`//单行注释  /*多行注释*/` ---可见范围 jsp源码 翻译后的servlet\n3. jsp注释：`<%--注释内容--%>` --- 可见范围 jsp源码可见\n\n\n\n## jsp运行原理\n\njsp本质就是一个servlet\n\n当第一次访问jsp页面时，会向一个servlet容器（tomcat等）发出请求，servlet容器先要把 jsp页面转化为servlet代码（.java），再编译成.class 文件 再进行调用。当再次访问jsp页面时 跳过翻译和编译的过程 直接调用 流程：\n\n第一次访问流程：\n\n1. 客户端发出请求hello.jsp\n2. web容器将jsp转化为servlet代码（hello_jsp.java）\n\n          3、web容器将转化为servlet代码编译（hello_jsp.class）\n\n          4、web容器加载编译后的代码并执行\n\n          5、将执行结果响应给客户端\n\n\n\n## jsp指令\n\n### page指令\n\n```\n<%@ page 属性名1= \"属性值1\" 属性名2= \"属性值2\" ...%>\n```\n\n| **属性**           | **描述**                                            |\n| ------------------ | --------------------------------------------------- |\n| buffer             | 指定out对象使用缓冲区的大小                         |\n| autoFlush          | 控制out对象的 缓存区                                |\n| contentType        | 指定当前JSP页面的MIME类型和字符编码                 |\n| errorPage          | 指定当JSP页面发生异常时需要转向的错误处理页面       |\n| isErrorPage        | 指定当前页面是否可以作为另一个JSP页面的错误处理页面 |\n| extends            | 指定servlet从哪一个类继承                           |\n| import             | 导入要使用的Java类                                  |\n| info               | 定义JSP页面的描述信息                               |\n| isThreadSafe       | 指定对JSP页面的访问是否为线程安全                   |\n| language           | 定义JSP页面所用的脚本语言，默认是Java               |\n| session            | 指定JSP页面是否使用session                          |\n| isELIgnored        | 指定是否执行EL表达式                                |\n| isScriptingEnabled | 确定脚本元素能否被使用                              |\n\n### include指令\n\n页面包含（静态包含）指令，可以将一个jsp页面包含到另一个jsp页面中\n\n```\n<%@ include file=\"被包含文件的 相对 url 地址\"%>\n```\n\n\n\n### taglib指令\n\n在jsp页面中引入标签库（jstl标签库、struts2标签库）\n\n```\n<%@ taglib uri=\"标签库地址\" prefix=\"前缀\"%>\n```\n\n\n\n## JSP 动作元素（标签）\n\n\n\n### jsp:include\n\n页面包含（动态包含）\n\n```\n<jsp:include page=\"被包含的页面\"/>\n```\n\n&lt;jsp:useBean&gt;\n\n```\n<jsp:forward page=\"要转发的资源\" />\n```\n\n### jsp:forward\n\n把请求转到另外的页面\n\n```\n<jsp:forward page=\"相对 URL 地址\" />\n```\n\n### jsp:useBean\n\n加载一个将在JSP页面中使用的JavaBean。\n\n```\n<jsp:useBean id=\"name\" class=\"package.class\" />\n```\n\n### jsp:setProperty\n\n用来设置已经实例化的Bean对象的属性，有两种用法。\n\n1. 你可以在jsp:useBean元素的外面（后面）使用\n2. 把jsp:setProperty放入jsp:useBean元素的内部\n\n```\n<jsp:useBean id=\"myName\" [type=\"指定将引用该对象变量的类型\"] />\n...\n<jsp:setProperty name=\"myName\" property=\"属性名\" [value=\"指定值\" param=\"请求参数作为Bean属性的值\"] />\n\n//或者\n\n<jsp:useBean id=\"myName\" ... >\n...\n   <jsp:setProperty name=\"myName\" property=\"属性名\" [value=\"指定值\" param=\"请求参数作为Bean属性的值\"] />\n</jsp:useBean>\n```\n\n### jsp:getProperty\n\n获取指定Bean属性的值，转换成字符串，然后输出。\n\n```\n<jsp:useBean id=\"myName\" ... />\n...\n<jsp:getProperty name=\"myName\" property=\"属性名\" />\n```\n\n\n\n## jsp内置/隐式对象（9个）\n\n| **名称**    | **类型**                               | **描述**                                    |\n| ----------- | -------------------------------------- | ------------------------------------------- |\n| out         | javax.servlet.jsp.JspWriter            | 用于页面输出                                |\n| request     | javax.servlet.http.HttpServletRequest  | 得到用户请求信息，                          |\n| response    | javax.servlet.http.HttpServletResponse | 服务器向客户端的回应信息                    |\n| config      | javax.servlet.ServletConfig            | 服务器配置，可以取得初始化参数              |\n| session     | javax.servlet.http.HttpSession         | 用来保存用户的信息                          |\n| application | javax.servlet.ServletContext           | 所有用户的共享信息                          |\n| page        | java.lang.Object                       | 指当前页面转换后的Servlet类的实例           |\n| pageContext | javax.servlet.jsp.PageContext          | JSP的页面容器                               |\n| exception   | java.lang.Throwable                    | 表示JSP页面所发生的异常，在错误页中才起作用 |\n\n","tags":["java"],"categories":["java"]},{"title":"hibernate配置文件","url":"/2020/05/23/hibernate/properties/","content":"\n# Hibernate配置文件\n\n## 主配置文件\n\n`hibernate.cfg.xml`\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE hibernate-configuration PUBLIC\n\t\"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n\t\"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\">\n\n<hibernate-configuration>\n\t<session-factory>\n\t\t<!-- \n\t\t\thibernate下载文件\\project\\etc可查看\n\t\t\t\n\t\t\t#hibernate.dialect org.hibernate.dialect.MySQLDialect\n\t\t\t#hibernate.dialect org.hibernate.dialect.MySQLInnoDBDialect\n\t\t\t#hibernate.dialect org.hibernate.dialect.MySQLMyISAMDialect\n\t\t\t#hibernate.connection.driver_class com.mysql.jdbc.Driver\n\t\t\t#hibernate.connection.url jdbc:mysql:///test\n\t\t\t#hibernate.connection.username gavin\n\t\t\t#hibernate.connection.password \n\t\t-->\n\t\t<property name=\"hibernate.connection.driver_class\">com.mysql.jdbc.Driver</property>\n\t\t<property name=\"hibernate.connection.url\">jdbc:mysql:///hibernate</property>\n\t\t<property name=\"hibernate.connection.username\">root</property>\n\t\t<property name=\"hibernate.connection.password\">root</property>\n\t\t\n\t\t<!-- 数据库方言\n\t\t\t不同的数据库中,sql语法略有区别. 指定方言可以让hibernate框架在生成sql语句时.针对数据库的方言生成.\n\t\t\tsql99标准: DDL 定义语言  库表的增删改查\n\t\t\t\t\t   DCL 控制语言  事务 权限\n\t\t\t\t\t   DML 操纵语言  增删改查\n\t\t\t注意: MYSQL在选择方言时,请选择最短的方言.\n\t\t -->\n\t\t<property name=\"hibernate.dialect\">org.hibernate.dialect.MySQLDialect</property>\n\t\t\n\t\t<!-- \n\t\t\t#hibernate.show_sql true 把自动生成的sql语句打印在控制台\n\t\t\t#hibernate.format_sql true 格式化sql语句不然都在一行 \n\t\t-->\n\t\t<property name=\"hibernate.show_sql\">true</property>\n\t\t<property name=\"hibernate.format_sql\">true</property>\n\t\t\n\t\t<!-- \n\t\t\t## auto schema export  自动导出表结构. 自动建表\n\t\t\t#hibernate.hbm2ddl.auto create\t\t自动建表.每次框架运行都会创建新的表.以前表将会被覆盖,表数据会丢失.(开发环境中测试使用)\n\t\t\t#hibernate.hbm2ddl.auto create-drop 自动建表.每次框架运行结束都会将所有表删除.(开发环境中测试使用)\n\t\t\t#hibernate.hbm2ddl.auto update(推荐使用) 自动生成表.如果已经存在不会再生成.如果表有变动.自动更新表(不会删除任何数据).表中没有的字段会自动添加\n\t\t\t#hibernate.hbm2ddl.auto validate\t校验.不自动生成表.每次启动会校验数据库中表是否正确.校验失败.\n\t\t -->\n\t\t <property name=\"hibernate.hbm2ddl.auto\">update</property>\n        \n        <!-- \n\t\tspecify a JDBC isolation level \t\t设置事物级别\n\t\thibernate.connection.isolation 4\t1，2，4，8   eg:0000\n\t\t -->\n\t\t<property name=\"hibernate.connection.isolation\">4</property>\n\t\t\n\t\t<!--配置session与threadLocal绑定 \t\t 注：还有其他方式-->\n\t\t<property name=\"hibernate.current_session_context_class\">thread</property>\n\t\t \n\t\t <!-- \n\t\t \t引入orm元数据\n\t\t\t路径书写: 填写src下的路径 相对于src\n\t\t -->\n\t\t <mapping resource=\"club/zzrfdsnsyl/domain/Customer.hbm.xml\"/>\n\t\t\n\t</session-factory>\n</hibernate-configuration>\n```\n\n\n\n## 实体类映射文件\n\n实体类\n\n- 提供一个**无参数** public访问控制符的构造器\n- 提供一个**标识属性**，映射数据表主键字段，提供id\n- 所有属性提供public访问控制符的 set  get 方法(javaBean)\n- 标识属性应尽量使用**基本数据类型的包装类型**\n- **不要用final修饰实体** （将无法生成代理对象进行优化）\n\n\n\n### 主键\n\n-  Java按**地址区**分同一个类的不同对象.l\n- 关系数据库用**主键区分同一条**记录l\n- Hibernate使用OID来建立内存中的对象和数据库中记录的对应关系结论: **对象的OID和数据库的表的主键对应。**\n- 为保证OID的唯一性，应该让**Hibernate来为OID赋值**\n\n\n\n- 主键需要具备: **不为空/不能重复/不能改变**\t\t\n- 自然主键:\t在业务中,某个属性符合主键的三个要求.那么该属性可以作为主键列.【例如：**登录名可以是自然主键**】\n- 代理主键: \t在业务中,不存符合以上3个条件的属性,那么就增加一个没有意义的列.作为主键.\n\n\n\n- 基本数据类型和包装类型对应hibernate的映射类型相同l\n- 基本类型无法表达null、数字类型的默认值为0。\n- 包装类默认值是null。当对于默认值有业务意义的时候需要使用包装类。\n\n\n\n`xxx.hbm.xml`\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE hibernate-mapping PUBLIC \n    \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n    \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n    \n    <!-- package代表class中配置的类所在的包名，可以不写但class中就要写全路径 -->\n    <hibernate-mapping package=\"club.zzrfdsnsyl.domain\">\n    \t<!-- \n    \t\tclass元素配置实体与表的对应关系\n    \t\tname代表实体类名 \n    \t\ttable代表数据库中的表名\n    \t\tcatalog代表数据库名称(可选)\n    \t -->\n    \t<class name=\"Customer\" table=\"cst_customer\">\n    \t\t<!-- \n    \t\tid配置主键映射关系(表中的主键)\n    \t\tname代表实体中的属性\n    \t\tcolumn代表表中的列名\n    \t\tcolumn(默认实体属性名) type(内部判断,java/hibernate/sql 如:java.lang.String/string/varchar) length(所用数据库最大长度) 均可省略 \n    \t\t-->\n    \t\t<id name=\"cust_id\" column=\"cust_id\">\n                <!-- \n\t\t\t\t\t主键生成策略\n\t    \t\t\tidentity：主键自增，由数据库维护 不需手动设置主键\n\t    \t\t\tsequence：Oracle的主键生成策略\n\t    \t\t\tincrement：主键自增 由hibernate维护 插入时先去查询最大值再+1\n\t    \t\t\thilo：高低位算法，主键自增 有hibernate维护 开发时不使用\n\t    \t\t\tnative：hilo+sequence+identity 自动三选一\n\t    \t\t\tuuid：产生长度为32的唯一字符串作为主键 主键类型必须是String\n\t    \t\t\tassigend：自然主键生成策略 就是自己设置\n    \t\t\t -->\n    \t\t\t<generator class=\"native\"></generator>\n    \t\t</id>\n            \n    \t\t<!-- 除id(主键)外普通属性 not-null：该列不能为空 -->\n    \t\t<property name=\"cust_name\" column=\"cust_name\" type=\"java.lang.String\" length=\"32\" not-null=\"true\"></property>\n            \n    \t\t<property name=\"cust_source\" column=\"cust_source\" type=\"java.lang.String\" length=\"32\"></property>\n            \n    \t\t<property name=\"cust_industry\" column=\"cust_industry\" type=\"java.lang.String\" length=\"32\"></property>\n            \n    \t\t<property name=\"cust_level\" column=\"cust_level\" type=\"java.lang.String\" length=\"32\"></property>\n            \n    \t\t<property name=\"cust_linkman\" column=\"cust_linkman\" type=\"java.lang.String\" length=\"64\"></property>\n            \n    \t\t<property name=\"cust_phone\" column=\"cust_phone\" type=\"java.lang.String\" length=\"64\"></property>\n            \n    \t\t<property name=\"cust_mobile\" column=\"cust_mobile\" type=\"java.lang.String\" length=\"16\"></property>\n            \n    \t</class>\n    </hibernate-mapping>\n```\n\n\n\n**class标签属性：**\n\ndynamic-insert=\"true/false\" 是否动态生成插入语句,**如果属性字段为空，就不会有该字段的插入语句**\n\ndynamic-update=\"true/false\" 同上\n\n\n\n## API\n\n```java\npackage club.zzrfdsnsyl.hibernateAPI;\n\nimport org.hibernate.Session;\nimport org.hibernate.SessionFactory;\nimport org.hibernate.Transaction;\nimport org.hibernate.cfg.Configuration;\n\nimport club.zzrfdsnsyl.domain.Customer;\n\npublic class A_api {\n\n\tpublic static void main(String[] args) {\n\t\t// 1.创建加载配置文件的对象\n\t\tConfiguration config = new Configuration();\n        \n\t\t// 2.加载配置文件 默认找src下的hibernate.cfg.xml\n\t\tconfig.configure();\n//\t\tconfig.addResource(\"\");\t\t\t\t\n//\t\tconfig.addClass(persistentClass)\n        \n\t\t//3.根据配置文件创建SessionFactory对象\n\t\tSessionFactory sessionFactory=config.buildSessionFactory();\n        \n\t\t//4.获取一个新的session对象（连接数据库对象）\n\t\tSession session = sessionFactory.openSession();\n\t\t//Session session= sessionFactory.getCurrentSession(); 获取当前线程绑定的session,需要在配置文件中配置\n        \n\t\t//5.获取事物对象\n\t\tTransaction transaction = session.getTransaction();\n        \n\t\t//6.开启事物\n\t\ttransaction.begin();\n        \n\t\t//7.创建实体对象\n\t\tCustomer customer=new Customer();\n//\t\tcustomer.setCust_id(1000L); ---目前好像没有 应该是配置文件中的那个没讲的标签问题\n\t\tcustomer.setCust_industry(\"电脑厂商\");\n\t\tcustomer.setCust_level(\"VIP\");\n\t\tcustomer.setCust_linkman(\"赵麻子\");\n\t\tcustomer.setCust_mobile(\"17533214759\");\n\t\tcustomer.setCust_name(\"华硕\");\n\t\tcustomer.setCust_phone(\"7845-84564847\");\n\t\tcustomer.setCust_source(\"互联网\");\n\t\t//8.保存--执行sql\n\t\tsession.save(customer);\n        \n\t\t//9.[回滚事物]\n\t\t//transaction.rollback();\n        \n\t\t//10.提交事物\n\t\ttransaction.commit(); \n        \n\t\t//11.关闭session连接\n\t\tsession.close();\n        \n\t\t//12.关闭工厂\n\t\tsessionFactory.close();\n\t\t\n\t}\n}\n\n```\n\n\n\n## 简单的增删改查\n\n``` java\npackage club.zzrfdsnsyl.hibernateAPI;\n\nimport org.hibernate.Session;\nimport org.hibernate.Transaction;\nimport org.junit.Test;\n\nimport club.zzrfdsnsyl.domain.Customer;\n\n/**\n * hibernate的增删改查\n * @author SYL\n *\n */\npublic class B_api {\n\tSession session = HmUtil.openSession();\n\t@Test\n\tpublic void save() {\n\t\tCustomer customer=new Customer();\n\t\tcustomer.setCust_industry(\"电脑厂商\");\n\t\tcustomer.setCust_level(\"VIP\");\n\t\tcustomer.setCust_linkman(\"lucy\");\n\t\tcustomer.setCust_mobile(\"17598754589\");\n\t\tcustomer.setCust_name(\"tonny\");\n\t\tcustomer.setCust_phone(\"7845-84564847\");\n\t\tcustomer.setCust_source(\"互联网\");\n\t\tsession.save(customer);\n\t\tsession.close();\n\t}\n\t@Test\n\tpublic void get() {\n\t\tCustomer customer = session.get(Customer.class, 1L);\n\t\tSystem.out.println(customer);\n\t\tsession.close();\n\t}\n\t\n\t@Test\n\t/**\n\t * 必须开启事物\n\t */\n\tpublic void update() {\n\t\t//先获取要修改的对象\n//\t\tTransaction t = session.beginTransaction();\n\t\tCustomer customer = session.get(Customer.class, 10L);\n\t\tcustomer.setCust_name(\"李雷\");\n\t\tcustomer.setCust_linkman(\"韩梅梅\");\n\t\tsession.update(customer);\n//\t\tt.commit();\n\t\tsession.close();\n\t}\n\t@Test\n\t/**\n\t * 必须开启事物\n\t */\n\tpublic void delete() {\n\t\t//先获取要删除的对象\n\t\tTransaction t = session.beginTransaction();\n\t\tCustomer customer = session.get(Customer.class, 3L);\n\t\tsession.delete(customer);\n\t\tt.commit();\n\t\tsession.close();\n\t}\n\t\n}\n\n```\n\n\n\n## 数据类型\n\n| Java数据类型                       | Hibernate数据类型 | 标准SQL数据类型 (PS:对于不同的DB可能有所差异) |\n| ---------------------------------- | ----------------- | --------------------------------------------- |\n| byte、java.lang.Byte               | byte              | TINYINT                                       |\n| short、java.lang.Short             | short             | SMALLINT                                      |\n| int、java.lang.Integer             | integer           | INGEGER                                       |\n| long、java.lang.Long               | long              | BIGINT                                        |\n| float、java.lang.Float             | float             | FLOAT                                         |\n| double、java.lang.Double           | double            | DOUBLE                                        |\n| java.math.BigDecimal               | big_decimal       | NUMERIC                                       |\n| char、java.lang.Character          | character         | CHAR(1)                                       |\n| boolean、java.lang.Boolean         | boolean           | BIT                                           |\n| java.lang.String                   | string            | VARCHAR                                       |\n| boolean、java.lang.Boolean         | yes_no            | CHAR(1)('Y'或'N')                             |\n| boolean、java.lang.Boolean         | true_false        | CHAR(1)('Y'或'N')                             |\n| java.util.Date、java.sql.Date      | date              | DATE                                          |\n| java.util.Date、java.sql.Time      | time              | TIME                                          |\n| java.util.Date、java.sql.Timestamp | timestamp         | TIMESTAMP                                     |\n| java.util.Calendar                 | calendar          | TIMESTAMP                                     |\n| java.util.Calendar                 | calendar_date     | DATE                                          |\n| byte[]                             | binary            | VARBINARY、BLOB                               |\n| java.lang.String                   | text              | CLOB                                          |\n| java.io.Serializable               | serializable      | VARBINARY、BLOB                               |\n| java.sql.Clob                      | clob              | CLOB                                          |\n| java.sql.Blob                      | blob              | BLOB                                          |\n| java.lang.Class                    | class             | VARCHAR                                       |\n| java.util.Locale                   | locale            | VARCHAR                                       |\n| java.util.TimeZone                 | timezone          | VARCHAR                                       |\n| java.util.Currency                 | currency          | VARCHAR                                       |","tags":["hibernate"],"categories":["hibernate"]},{"title":"mysql基本查询","url":"/2020/05/23/mysql/basicquery/","content":"\n# 基本查询\n\n> [SQL文件](https://www.lanzous.com/i763iqf)\n\n## SELECT 语句\n\n> **SELECT** *****|{[DISTINCT] **column**|expression [alias],...}**FROM** **table**\n\n- **SELECT** 标识选择哪些列。\n- **FROM** 标识从哪个表中选\n\n语法：\n\n``` mysql\nselect 查询列表 from 表名;\n```\n\n特点：\n\n1. 查询列表可以是：表中的字段、常量值、表达式、函数\n2. 查询的结果是一个虚拟的表格\n\n查询全部列:\n\n``` mysql\nSELECT *FROM 表名;\n```\n\n查询特定的列:\n\n``` mysql\nSELECT id, name FROM student;\n```\n\n查询表达式:\n\n``` mysql\n SELECT 100%98;\n```\n\n查询函数:\n\n``` mysql\nselect now();\n```\n\n## 查询时给列的别名\n\n别名使用双引号，以便在别名中包含空格或特殊的字符\n\n ①便于理解\n ②如果要查询的字段有重名的情况，使用别名可以区分开来\n\n1. 使用**as**\n\n   ``` mysql\n   SELECT 列名1 AS \"列1别名\",列名2 AS \"列2别名\" FROM 表名;\n   ```\n\n   案例:\n\n   ``` mysql\n   SELECT 100%98 AS \"结果\";\n   SELECT last_name AS \"姓\",first_name AS \"名\" FROM employees;\n   ```\n\n2. 使用**空格**\n\n   ``` mysql\n   SELECT 列名1 \"列1别名\",列名2 \"列2别名\" FROM 表名;\n   ```\n\n   案例:\n\n   ``` mysql\n   # 查询salary，显示结果为 out put\n   SELECT salary AS \"out put\" FROM employees;\n   ```\n\n   \n\n## 查询去重\n\n``` mysql\nselect distinct 字段名 from 表名;\n```\n\n``` mysql\n# 案例：查询员工表中涉及到的所有的部门编号\nSELECT DISTINCT department_id FROM employees;\n```\n\n## +号的作用\n\n`java`中的+号：\n①运算符，两个操作数都为数值型\n②连接符，只要有一个操作数为字符串\n\n`mysql`中的+号：\n仅仅只有一个功能：运算符\n\n``` mysql\n# 直接运算\nselect 数值+数值;\n\n# 先试图将字符转换成数值，如果转换成功，则继续运算；否则转换成0，再做运算\nselect 字符+数值;\n\n# 结果都为null\nselect null+值;\n```\n\n## concat函数\n\n功能：拼接字符，相当于java中的 `\"1\"+\"23\"=\"123\"`\n\n``` mysql\nselect concat(字符1，字符2，字符3,...);\n```\n\n## ifnull函数\n\n功能：判断某字段或表达式是否为null，如果为null 返回指定的值，否则返回原本的值\n\n``` mysql\n# 如果commission_pct列为空则返回0\nselect ifnull(commission_pct,0) from employees;\n```\n\n## isnull函数\n\n功能：判断某字段或表达式是否为null，如果是，则返回1，否则返回0","tags":["mysql"],"categories":["mysql"]},{"title":"DDL数据库定义语言","url":"/2020/05/23/mysql/ddl/","content":"\n# DDL数据库定义语言\n\n数据定义语言：简称DDL(Data Definition Language)，用来定义数据库对象：数据库，表，列等。关键字：create，alter，drop等 \n\n- 创建： create\n- 修改： alter\n- 删除： drop\n\n## 库的管理\n\n### 创建库\n\n```mysql\ncreate database 【if not exists】 库名【 character set 字符集名】;\n```\n\n``` mysql\nCREATE DATABASE IF NOT EXISTS books;\n```\n\n### 修改库\n\n```\nalter database 库名 character set 字符集名;\n```\n\n### 修改库名\n\n``` mysql\nRENAME DATABASE books TO 新库名;\n```\n\n### 修改库的字符集\n\n``` mysql\nALTER DATABASE books CHARACTER SET gbk;\n```\n\n\n\n### 删除库\n\n```\ndrop database 【if exists】 库名;\n```\n\n\n\n## 表的管理\n\n### 创建表\n\n```\ncreate table 表名(\n\t列名 列的类型【(长度) 约束】,\n\t列名 列的类型【(长度) 约束】,\n\t列名 列的类型【(长度) 约束】,\n\t...\n\t列名 列的类型【(长度) 约束】\n)\n```\n\n**创建表Book表**\n\n``` mysql\nCREATE TABLE book ( \n\tid INT, #编号\n\tbName VARCHAR ( 20 ), #图书名\n\tprice DOUBLE, #价格\n\tauthorId INT, #作者编号\n\tpublishDate DATETIME #出版日期\n);\n```\n\n**查看book表结构**\n\n``` mysql\nDESC book;\n```\n\n**创建表author**\n\n``` mysql\nCREATE TABLE IF NOT EXISTS author(\n\tid INT,\n\tau_name VARCHAR(20),\n\tnation VARCHAR(10)\n)\n```\n\n[数据类型](#mysql数据类型)\n\n### 修改表\n\n### 添加列\n\n```\nalter table 表名 add column 列名 类型 【first|after 字段名】;\n```\n\n### 修改列的类型或约束\n\n```\nalter table 表名 modify column 列名 新类型 【新约束】;\n```\n\n### 修改列名\n\n```\nalter table 表名 change column 旧列名 新列名 类型;\n```\n\n### 删除列\n\n```\nalter table 表名 drop column 列名;\n```\n\n### 修改表名\n\n```\nalter table 表名 rename 【to】 新表名;\n```\n\n### 删除表\n\n```\ndrop table【if exists】 表名;\n```\n\n### 复制表\n\n### 复制表的结构\n\n```\ncreate table 表名 like 旧表;\n```\n\n### 复制表的结构+数据\n\n```\ncreate table 表名 \nselect 查询列表 from 旧表【where 筛选】;\n```\n\n**案例**\n\n1. 向author表插入数据\n\n   ``` mysql\n   INSERT INTO author\n   VALUES\n   \t( 1, '村上春树', '日本' ),\n   \t( 2, '莫言', '中国' ),\n   \t( 3, '冯唐', '中国' ),\n   \t( 4, '金庸', '中国' );\n   ```\n\n2. 创建表copy，复制author表的结构\n\n   ```mysql\n   CREATE TABLE copy LIKE author;\n   ```\n\n3. 创建表copy2，复制author表的结构和数据\n\n   ```mysql\n   CREATE TABLE copy2 \n   SELECT * FROM author;\n   ```\n\n4. 创建表copy3，复制author表的`部分数据`\n\n   ```mysql\n   CREATE TABLE copy3\n   SELECT id,au_name\n   FROM author \n   WHERE nation='中国';\n   ```\n\n5. 创建表copy4，复制author表的`部分字段`\n\n   ``` mysql\n   CREATE TABLE copy4 \n   SELECT id,au_name\n   FROM author\n   WHERE 0;\n   ```\n\n   \n\n## MYSQL数据类型\n\n| **分类**             | **类型名称**   | **说明**                                                     |\n| -------------------- | -------------- | ------------------------------------------------------------ |\n| **整数类型**         | tinyInt        | 很小的整数                                                   |\n|                      | smallint       | 小的整数                                                     |\n|                      | mediumint      | 中等大小的整数                                               |\n|                      | int(integer)   | 普通大小的整数                                               |\n| **小数类型**         | float          | 单精度浮点数                                                 |\n|                      | double         | 双精度浮点数                                                 |\n|                      | decimal（m,d） | 压缩严格的定点数                                             |\n| **日期类型**         | year           | YYYY  1901~2155                                              |\n|                      | time           | HH : MM : SS -838:59 : 59~838 : 59 : 59                      |\n|                      | date           | YYYY-MM-DD 1000-01-01~9999-12-3                              |\n|                      | datetime       | YYYY-MM-DD HH : MM : SS 1000-01-01 00 : 00 : 00~ 9999-12-31 23 : 59 : 59 |\n|                      | timestamp      | YYYY-MM-DD HH : MM : SS 1970~01~01 00 : 00 : 01 UTC~2038-01-19 03 : 14 : 07UTC |\n| **文本、二进制类型** | CHAR(M)        | M为0~255之间的整数                                           |\n|                      | VARCHAR(M)     | M为0~65535之间的整数                                         |\n|                      | TINYBLOB       | 允许长度0~255字节                                            |\n|                      | BLOB           | 允许长度0~65535字节                                          |\n|                      | MEDIUMBLOB     | 允许长度0~167772150字节                                      |\n|                      | LONGBLOB       | 允许长度0~4294967295字节                                     |\n|                      | TINYTEXT       | 允许长度0~255字节                                            |\n|                      | TEXT           | 允许长度0~65535字节                                          |\n|                      | MEDIUMTEXT     | 允许长度0~167772150字节                                      |\n|                      | LONGTEXT       | 允许长度0~4294967295字节                                     |\n|                      | VARBINARY(M)   | 允许长度0~M个字节的变长字节字符串                            |\n|                      | BINARY(M)      | 允许长度0~M个字节的定长字节字符串                            |\n\n### 数值型\n\n### 整型\n\ntinyint、smallint、mediumint、int/integer、bigint\n\n**特点：**\n\n1. 都可以设置无符号和有符号，默认有符号，通过unsigned设置无符号\n2. 如果超出了范围，会报out or range异常，插入临界值\n3. 长度可以不指定，默认会有一个长度，长度代表显示的最大宽度，如果不够则左边用0填充，但需要搭配zerofill，并且默认变为无符号整型\n\n**如何设置无符号**\n\n``` mysql\nCREATE TABLE tab_int(\n\tt1 INT,\n\tt2 INT unsigned \n);\n```\n\n**显示长度**\n\n``` mysql\nCREATE TABLE tab_int(\n\tt1 INT(7) ZEROFILL,\n\tt2 INT(7) ZEROFILL \n);\n```\n\n\n\n### 浮点型\n\n**定点数**：decimal(M,D)\n**浮点数**:\n\tfloat(M,D) \n\tdouble(M,D)\n\n**特点：**\n\n1. M代表整数部位+小数部位的个数，D代表小数部位\n2. 如果超出范围，则报out or range异常，并且插入临界值\n3. M和D都可以省略，但对于定点数，M默认为10，D默认为0\n4. 如果精度要求较高，则优先考虑使用定点数\n\n### 字符型\n\nchar、varchar、binary、varbinary、enum(用于保存枚举)、set(用于保存集合)、text、blob\n\nchar：固定长度的字符，写法为char(M)，最大长度不能超过M，其中M可以省略，默认为1\n\nvarchar：可变长度的字符，写法为varchar(M)，最大长度不能超过M，其中M不可以省略\n\nEnum：又称为枚举类型哦，要求插入的值必须属于列表中指定的值之一。\n\nSet：和Enum类型类似，里面可以保存0~64个成员。和Enum类型最大的区别是：SET类型一次可以选取多个成员，而Enum只能选一个\n\n``` mysql\nCREATE TABLE tab_char(\n\tc1 ENUM('a','b','c')\n);\n\nINSERT INTO tab_char VALUES('a');\nINSERT INTO tab_char VALUES('b');\nINSERT INTO tab_char VALUES('c');\nINSERT INTO tab_char VALUES('m');\t--> 会插入空字符 ''\nINSERT INTO tab_char VALUES('A');\t-->  会插入 'a'\n```\n\n``` mysql\nCREATE TABLE tab_set(\n\ts1 SET('a','b','c','d')\n);\n\nINSERT INTO tab_set VALUES('a');\nINSERT INTO tab_set VALUES('A,B');\nINSERT INTO tab_set VALUES('a,c,d');\n```\n\n\n\n### 日期型\n\nyear年\ndate日期\ntime时间\ndatetime 日期+时间\ntimestamp 日期+时间 ，比较容易受时区、语法模式、版本的影响，更能反映当前时区的真实时间\n\n## 常见的约束\n\n- NOT NULL：非空，该字段的值必填\n- UNIQUE：唯一，该字段的值不可重复\n- DEFAULT：默认，该字段的值不用手动插入有默认值\n- CHECK：检查，mysql不支持（但是设置并不会报错，只是没有效果）\n- PRIMARY KEY：主键，该字段的值不可重复并且非空  unique+not null\n- FOREIGN KEY：外键，该字段的值引用了另外的表的字段\n\n添加约束的时机：\n\n1. 创建表时\n2. 修改表时\n\n**约束的添加分类**：\n\n\t\t列级约束：\n\t\t\n\t\t\t六大约束语法上都支持，但外键约束没有效果\n\t\t\t\n\t\t表级约束：\n\t\t\t\n\t\t\t除了非空、默认，其他的都支持\n### 主键和唯一\n\n**区别：**\n\n1. 一个表至多有一个主键，但可以有多个唯一\n2. 主键不允许为空，唯一可以为空\n\n|      | 保证唯一性 | 是否允许为空 | 一个表中可以有多少个 | 是否允许组合 |\n| :--: | :--------: | :----------: | :------------------: | ------------ |\n| 主键 |     √      |      ×       |      至多有1个       | √，但不推荐  |\n| 唯一 |     √      |      √       |      可以有多个      | √，但不推荐  |\n\n**外键：**\n\n1. 要求在从表设置外键关系\n2. 从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求\n3. 主表的关联列`必须是一个key`（一般是主键或唯一）\n4. 插入数据时，先插入主表，再插入从表\n5. 删除数据时，先删除从表，再删除主表\n\n### 创建表时添加约束\n\n```\nCREATE TABLE 表名(\n\t字段名 字段类型 列级约束,\n\t字段名 字段类型,\n\t表级约束\n)\n```\n\n### 添加列级约束\n\n直接在字段名和类型后面追加 约束类型即可。\n\n只支持：默认、非空、主键、唯一\n\n```mysql\n# 创建一个数据库\nCREATE DATABASE students;\nUSE students;\n```\n\n``` mysql\nCREATE TABLE stuinfo (\n\tid INT PRIMARY KEY,#主键\n\tstuName VARCHAR ( 20 ) NOT NULL UNIQUE,#非空并且唯一\n\tgender CHAR ( 1 ) CHECK ( gender = '男' OR gender = '女' ),#检查\n\tseat INT UNIQUE,#唯一\n\tage INT DEFAULT 18,#默认约束\n\tmajorId INT REFERENCES major ( id ) #外键，(没有效果)\n);\n\nCREATE TABLE major(\n\tid INT PRIMARY KEY,\n\tmajorName VARCHAR(20)\n);\n\n# 查看stuinfo中的所有索引，包括主键、外键、唯一\nSHOW INDEX FROM stuinfo;\n```\n\n### 添加表级约束\n\n在各个字段的最下面\n\n【constraint 约束名】 约束类型(字段名) \n\n``` mysql\nDROP TABLE IF EXISTS stuinfo;\nCREATE TABLE stuinfo (\n\tid INT,\n\tstuname VARCHAR ( 20 ),\n\tgender CHAR ( 1 ),\n\tseat INT,\n\tage INT,\n\tmajorid INT,\n\tCONSTRAINT pk PRIMARY KEY ( id ),#主键\n\tCONSTRAINT uq UNIQUE ( seat ),#唯一键\n\tCONSTRAINT ck CHECK ( gender = '男' OR gender = '女' ),#检查\n\tCONSTRAINT fk_stuinfo_major FOREIGN KEY ( majorid ) REFERENCES major ( id ) #外键\n\n);\n```\n\n### 通用写法\n\n``` mysql\nCREATE TABLE IF NOT EXISTS stuinfo (\n\t\tid INT PRIMARY KEY,\n\t\tstuname VARCHAR ( 20 ),\n\t\tsex CHAR ( 1 ),\n\t\tage INT DEFAULT 18,\n\t\tseat INT UNIQUE,\n\t\tmajorid INT,\n\tCONSTRAINT fk_stuinfo_major FOREIGN KEY ( majorid ) REFERENCES major ( id ) \n);\n```\n\n### 修改表时添加约束\n\n- 添加列级约束\n\n```\nalter table 表名 modify column 字段名 字段类型 新约束;\n```\n\n- 添加表级约束\n\n```\nalter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;\n```\n\n``` mysql\nDROP TABLE IF EXISTS stuinfo;\nCREATE TABLE stuinfo(\n\tid INT,\n\tstuname VARCHAR(20),\n\tgender CHAR(1),\n\tseat INT,\n\tage INT,\n\tmajorid INT\n)\n```\n\n1. 添加非空约束\n\n   ``` mysql\n   ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;\n   ```\n\n   \n\n2. 添加默认约束\n\n   ``` mysql\n   ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;\n   ```\n\n   \n\n3. 添加主键\n\n   ① 列级约束\n\n   ``` mysql\n   ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;\n   ```\n\n   ② 表级约束\n\n   ``` mysql\n   ALTER TABLE stuinfo ADD PRIMARY KEY(id);\n   ```\n\n   \n\n4. 添加唯一\n\n   ① 列级约束\n\n   ``` mysql\n   ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;\n   ```\n\n   ② 表级约束\n\n   ``` mysql\n   ALTER TABLE stuinfo ADD UNIQUE(seat);\n   ```\n\n\n\n5. 添加外键\n\n   ``` mysql\n   ALTER TABLE stuinfo \n   ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); \n   ```\n\n### 修改表时删除约束\n\n1. 删除非空约束\n\n   ``` mysql\n   ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;\n   ```\n\n   \n\n2. 删除默认约束\n\n   ``` mysql\n   ALTER TABLE stuinfo MODIFY COLUMN age INT ;\n   ```\n\n   \n\n3. 删除主键\n\n   ``` mysql\n   ALTER TABLE stuinfo DROP PRIMARY KEY;\n   ```\n\n   \n\n4. 删除唯一\n\n   ``` mysql\n   ALTER TABLE stuinfo DROP INDEX seat;\n   ```\n\n   \n\n5. 删除外键\n\n   ``` mysql\n   ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;\n   ```\n\n## 自增长列\n\n不用手动插入值，可以自动提供序列值，默认从1开始，步长为1\n\n`auto_increment_increment`\n\n如果要更改起始值：手动插入值\n\n如果要更改步长：更改系统变量：`set auto_increment_increment=值;`\n\n1. 一个表至多有一个自增长列\n2. 自增长列只能支持数值型\n3. 自增长列必须为一个key\n\n### 创建表时设置自增长列\n\n``` \ncreate table 表(\n\t字段名 字段类型 约束 auto_increment\n)\n```\n\n### 修改表时设置自增长列\n\n```\nalter table 表 modify column 字段名 字段类型 约束 auto_increment\n```\n\n### 删除自增长列\n\n```\nalter table 表 modify column 字段名 字段类型 约束 \n```\n\n","tags":["mysql"],"categories":["mysql"]},{"title":"hibernate查询语句","url":"/2020/05/23/hibernate/query/","content":"\n# hiberate查询语句\n\n## HQL\n\nHibernate Query Language的缩写,就是Hibernate的查询语言\n\n面向对象查询语言,最终底层要转成面向数据库查询语言\n\n```java\npackage club.zzrfdsnsyl.demo.d_sql;\n\nimport java.util.List;\n\nimport org.hibernate.Session;\nimport org.hibernate.Transaction;\nimport org.hibernate.query.Query;\nimport org.junit.Test;\n\nimport club.zzrfdsnsyl.Utils.HbUtil;\nimport club.zzrfdsnsyl.domain.Customer;\n\n@SuppressWarnings({\"unchecked\",\"unused\"})\n/**\n * hibernate query language\n * @author SYL\n *\n */\npublic class HQL {\n\tprivate Session session = HbUtil.getCurrentSession();\n\n\t@Test\n\t/**\n\t * 查询全部 必须开启事物\n\t */\n\tpublic void query() {\n\t\t// 当一个项目只有一个Customer可省略包名\n\t\t// 当查询所有列可省略select *\n\t\t// String hql=\"select * from club.zzrfdsnsyl.domain.Customer\";\n\t\tTransaction transaction = session.beginTransaction();\n\t\tString hql = \"from Customer\";\n\t\tQuery<Customer> query = session.createQuery(hql);\n\t\tList<Customer> list = query.list(); // 多个结果\n\t\t// Customer customer = (Customer) query.uniqueResult();//单个结果\n\t\tSystem.out.println(list);\n\t\t// System.out.println(customer);\n\t}\n\n\t@Test\n\t/**\n\t * where 条件查询 必须开启事物\n\t * 占位符 ?1 ?2 ?3 ?4 ...\n\t * 占位符 :m :t ...\n\t * \n\t */\n\tpublic void query2() {\n\t\t// 当一个项目只有一个Customer可省略包名\n\t\tTransaction transaction = session.beginTransaction();\n\t\t// String hql=\"from Customer where cust_id=1\";\n\t\t//String hql = \"from Customer where cust_id = ?0\";\n\t\tString hql = \"from Customer where cust_id = :cid\";\n\n\t\tQuery<Customer> query = session.createQuery(hql);\n\t\t//query.setParameter(0, 1L);\n\t\tquery.setParameter(\"cid\", 2L);\n\t\tCustomer customer = query.uniqueResult();// 单个结果\n\t\tSystem.out.println(customer);\n\t}\n\t\n\t/**\n\t * \t分页查询\n\t */\n\t@Test\n\tpublic void queryPage() {\n\t\tsession.beginTransaction();\n\t\tString hql=\"from Customer\";\n\t\tQuery<Customer> query = session.createQuery(hql);\n\t\tquery.setFirstResult(0);\t//起始\n\t\tquery.setMaxResults(2);\t\t//每页显示\n\t\tList<Customer> list =query.list();\n\t\tSystem.out.println(list);\n\t}\n}\n\n```\n\n\n\n## Criteria\n\nhibernate提供纯面向对象查询语言，提供直接使用PO对象进行操作。\n\n```java\npackage club.zzrfdsnsyl.demo.d_sql;\n\nimport java.util.List;\n\nimport javax.persistence.criteria.CriteriaBuilder;\nimport javax.persistence.criteria.CriteriaQuery;\nimport javax.persistence.criteria.Root;\nimport org.hibernate.Session;\nimport org.hibernate.criterion.Projections;\nimport org.hibernate.criterion.Restrictions;\nimport org.hibernate.query.Query;\nimport org.junit.Test;\n\nimport club.zzrfdsnsyl.Utils.HbUtil;\nimport club.zzrfdsnsyl.domain.Customer;\n\n/**\n * \thibernate的无语句查询 全部是调用方法\n * \t查询单表时使用\n * @author SYL\n *\n */\n@SuppressWarnings({\"deprecation\",\"unchecked\"})\npublic class Criteria {\n\tprivate Session session=HbUtil.getCurrentSession();\n\t\n\t@Test\n\t/**\n\t * 查询全部\n\t */\n\tpublic void ago() {\n\t\tsession.beginTransaction();\n\t\t//这种方法好像已经过时了\n\t\torg.hibernate.Criteria criteria =session.createCriteria(Customer.class);\n\t\tList<Customer> list = criteria.list();\n\t\tSystem.out.println(list);\n\t}\n\t\n\t/**\n\t * \t条件查询\n\t * .add方法添加条件\n\t * Restrictions.方法名()  比较规则\n\t * >\t\t\t\t\t.gt()\n\t * <\t\t\t\t\t.lt()\n\t * ==\t\t\t\t\t.eq()\n\t * >=\t\t\t\t\t.ge()\n\t * <=\t\t\t\t\t.le()\n\t * !=\t\t\t\t\t.ne()\n\t * in\t\t\t\t\t.in()\n\t * between and\t\t\t.between()\n\t * like\t\t\t\t\t.like()\n\t * is not null\t\t\t.isNotNull()\n\t * is null\t\t\t\t.isNull()\n\t * or\t\t\t\t\t.or()\n\t * and\t\t\t\t\t.and()\n\t * \n\t * \n\t */\n\t@Test\n\tpublic void ago2() {\n\t\tsession.beginTransaction();\n\t\torg.hibernate.Criteria criteria = session.createCriteria(Customer.class);\n\t\tcriteria.add(Restrictions.eq(\"cust_id\", 3L)); //add方法用于添加条件\n\t\tCustomer customer = (Customer) criteria.uniqueResult();\n\t\tSystem.out.println(customer);\n\t}\n\t\n\t@Test\n\t/**\n\t * 分页查询\n\t */\n\tpublic void ago3() {\n\t\tsession.beginTransaction();\n\t\torg.hibernate.Criteria criteria = session.createCriteria(Customer.class);\n\t\tcriteria.setFirstResult(0);\n\t\tcriteria.setMaxResults(2);\n\t\tList<Customer> list = criteria.list();\n\t\tSystem.out.println(list);\n\t\t\n\t}\n\t\n\t@Test\n\t/**\n\t * 聚合函数\n\t */\n\tpublic void ago4() {\n\t\tsession.beginTransaction();\n\t\torg.hibernate.Criteria criteria = session.createCriteria(Customer.class);\n\t\tcriteria.setProjection(Projections.rowCount());\t//查询总行数\n\t\tLong row = (Long)criteria.uniqueResult();\n\t\tSystem.out.println(row);\n\t\t\n\t}\n\t\n\t\n\t\n\t\n\t\n\t\n\t@Test\n\t/**\n\t * \t新方法\n\t * \t查询全部\n\t */\n\tpublic void query() {\n\t\tsession.beginTransaction();\n\t\tCriteriaBuilder criteriaBuilder = session.getCriteriaBuilder();\n\t\tCriteriaQuery<Customer> criteria = criteriaBuilder.createQuery(Customer.class);\n\t\tcriteria.from(Customer.class);\n\t\tQuery<Customer> query = session.createQuery(criteria);\n\t\tList<Customer> list = query.list();\n\t\tSystem.out.println(list);\n\t}\n}\n\n```\n\n\n\n## 原生SQL\n\n```java\npackage club.zzrfdsnsyl.demo.d_sql;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.hibernate.Session;\nimport org.hibernate.query.NativeQuery;\nimport org.hibernate.query.Query;\nimport org.junit.Test;\n\nimport club.zzrfdsnsyl.Utils.HbUtil;\nimport club.zzrfdsnsyl.domain.Customer;\n\n/**\n * \t原始的sql查询\n * @author SYL\n *\n */\npublic class SQL {\n\tprivate Session session=HbUtil.getCurrentSession();\n\t@Test\n\tpublic void query() {\n\t\tsession.beginTransaction();\n\t\tString sql =\"select * from customer\";\n\t\tQuery query = session.createSQLQuery(sql);\n\t\t//查询到的每条数据都是数组\n\t\tList<Object[]> list = query.list();\n\t\tfor(Object[] obj:list) {\n\t\t\tSystem.out.println(Arrays.toString(obj));\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void query2() {\n\t\tsession.beginTransaction();\n\t\tString sql =\"select * from customer\";\n\t\tNativeQuery<Customer> query = session.createNativeQuery(sql, Customer.class);\n\t\tList<Customer> list = query.list();\n\t\tSystem.out.println(list);\n\t}\n}\n\n```\n\n","tags":["hibernate"],"categories":["hibernate"]},{"title":"mysql增删改语法","url":"/2020/05/23/mysql/dml/","content":"\n# DML数据处理之增删改\n\nDML(Data Manipulation Language –数据操纵语言) 可以在下列条件下执行:\n\n- 向表中插入数据\n- 修改现存数据\n- 删除现存数据\n\n**事务是由完成若干项工作的DML语句组成的**\n\n运行以下脚本创建表my_employees\n\n``` mysql\nUSE myemployees;\nCREATE TABLE my_employees(\n\tId INT(10),\n\tFirst_name VARCHAR(10),\n\tLast_name VARCHAR(10),\n\tUserid VARCHAR(10),\n\tSalary DOUBLE(10,2)\n);\nCREATE TABLE users(\n\tid INT,\n\tuserid VARCHAR(10),\n\tdepartment_id INT\n\n);\n```\n\n显示表my_employees的结构\n\n```mysql\nDESC my_employees;\n```\n\n## INSERT\n\n### 方式一\n\n### 语法\n\n``` \ninsert into 表名(字段名,...) values(值,...);\n```\n\n### 特点\n\n1. 要求值的类型和字段的类型要一致或兼容\n\n2. 字段的个数和顺序不一定与原始表中的字段个数和顺序一致\n\n   `但必须保证值和字段一一对应`\n\n3. 假如表中有可以为null的字段，注意可以通过以下两种方式插入null值\n\n   ① 字段和值都省略  \n   ② 字段写上，值使用null\n\n4. 字段和值的个数必须一致\n5. 字段名可以省略，默认所有列\n\n### 方式二\n\n语法\n\n```\ninsert into 表名 set 字段=值,字段=值,...;\n```\n\n**两种方式的区别：**\n\n1. 方式一支持一次插入多行，语法如下：\n\n   ```\n   insert into 表名【(字段名,..)】 values(值，..),(值，...),...;\n   ```\n\n   \n\n2. 方式一支持子查询，语法如下：\n\n   ```\n   insert into 表名\n   查询语句;\n   ```\n\n### 向表中插入数据\n\n向my_employees表中插入下列数据\n\n| ID   | FIRST_NAME | LAST_NAME | USERID   | SALARY |\n| ---- | ---------- | --------- | -------- | ------ |\n| 1    | patel      | Ralph     | Rpatel   | 895    |\n| 2    | Dancs      | Betty     | Bdancs   | 860    |\n| 3    | Biri       | Ben       | Bbiri    | 1100   |\n| 4    | Newman     | Chad      | Cnewman  | 750    |\n| 5    | Ropeburn   | Audrey    | Aropebur | 155    |\n\n``` mysql\nINSERT INTO my_employees\nVALUES\n\t( 1, 'patel', 'Ralph', 'Rpatel', 895 ),\n\t( 2, 'Dancs', 'Betty', 'Bdancs', 860 ),\n\t( 3, 'Biri', 'Ben', 'Bbiri', 1100 ),\n\t( 4, 'Newman', 'Chad', 'Cnewman', 750 ),\n\t( 5, 'Ropeburn', 'Audrey', 'Aropebur', 1550 );\n```\n\n或者\n\n``` mysql\n# 先删除表数据\nDELETE FROM my_employees;\n# 再插入\nINSERT INTO my_employees\nSELECT 1,'patel','Ralph','Rpatel',895 UNION\nSELECT 2,'Dancs','Betty','Bdancs',860 UNION\nSELECT 3,'Biri','Ben','Bbiri',1100 UNION\nSELECT 4,'Newman','Chad','Cnewman',750 UNION\nSELECT 5,'Ropeburn','Audrey','Aropebur',1550;\n```\n\n向users表中插入数据\n\n``` mysql\nINSERT INTO users\nVALUES\n\t( 1, 'Rpatel', 10 ),\n\t( 2, 'Bdancs', 10 ),\n\t( 3, 'Bbiri', 20 );\n```\n\n## UPDATE\n\n### 修改单表的记录\n\n### 语法\n\n```\nupdate 表名 set 字段=值,字段=值 【where 筛选条件】;\n```\n\n1. 将3号员工的last_name修改为“drelxer”\n\n   ``` mysql\n   UPDATE my_employees SET last_name='drelxer' WHERE id = 3;\n   ```\n\n2. 将所有工资少于900的员工的工资修改为1000\n\n   ``` mysql\n   UPDATE my_employees SET salary=1000 WHERE salary<900;\n   ```\n\n### 修改多表的记录\n\n### 语法\n\n``` \nupdate 表1 别名 \nleft|right|inner join 表2 别名 \non 连接条件  \nset 字段=值,字段=值 \n【where 筛选条件】;\n```\n\n## DELETE\n\n### 删除单表的记录\n\n### 语法\n\n```\ndelete from 表名 【where 筛选条件】【limit 条目数】\n```\n\n### 级联删除\n\n### 语法\n\n```\ndelete 别名1,别名2 from 表1 别名 \ninner|left|right join 表2 别名 \non 连接条件\n 【where 筛选条件】\n```\n\n1. 将userid 为Bbiri的user表和my_employees表的记录全部删除\n\n   ``` mysql\n   DELETE u,e \n   FROM\n   \tusers u\n   \tJOIN my_employees e \n   ON u.`userid` = e.`Userid` \n   WHERE\n   \tu.`userid` = 'Bbiri';\n   ```\n\n   \n\n2. 删除所有数据\n\n   ```\n   DELETE FROM my_employees;\n   DELETE FROM users;\n   ```\n\n## TRUNCATE\n\n清空表\n\n### 语法\n\n```\ntruncate table 表名\n```\n\n## DELETE和TRUNCATE的区别\n\n1. truncate删除后，如果再插入，标识列从1开始。delete删除后，如果再插入，标识列从断点开始\n2. delete可以添加筛选条件，truncate不可以添加筛选条件\n3. truncate效率较高\n4. truncate没有返回值，delete可以返回受影响的行数\n5. truncate不可以回滚，delete可以回滚","tags":["mysql"],"categories":["mysql"]},{"title":"数据库和SQL概述","url":"/2020/05/23/mysql/dbandsql/","content":"\n# 数据库和SQL概述\n\n## 数据库的好处\n\n- 实现数据持久化\n- 使用完整的管理系统统一管理，易于查询\n\n## 数据库的概念\n\nDB\nDBMS\nSQL\n数据库（database）：存储数据的“仓库”。它保存了一系列有组织的数据。\n数据库管理系统（Database Management System）。数据库是通过DBMS创\n建和操作的容器\n结构化查询语言（Structure Query Language）：专门用来与数据库通信的语\n言\n\n常见的数据库管理系统：MySQL、Oracle、DB2、SqlServe\n\n## SQL语言\n\n数据库是不认识JAVA语言的，但是我们同样要与数据库交互，这时需要使用到数据库认识的语言SQL语句，它是数据库的代码。\n\n结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询和[程序设计语言](http://baike.baidu.com/view/128511.htm)，用于存取数据以及查询、更新和管理[关系数据库系统](http://baike.baidu.com/view/549699.htm)。\n\n创建数据库、创建数据表、向数据表中添加一条条数据信息均需要使用SQL语句。\n\n### DML\n\nDML（Data Manipulation Language):数据操纵语句，用于添加、删除、修改、查询数据库记录，并检查数据完整性。包括如下SQL语句等：\n\n- INSERT：添加数据到数据库中\n- UPDATE：修改数据库中的数据\n- DELETE：删除数据库中的数据\n- **SELECT：选择（查询）数据**\n  - SELECT是SQL语言的基础，最为重要。\n\n### DDL\n\nDDL（Data Definition Language):数据定义语句，用于库和表的创建、修改、删除。包括如下SQL语句等：\n\n- CREATE TABLE：创建数据库表\n- ALTER TABLE：更改表结构、添加、删除、修改列长度\n- DROP TABLE：删除表\n- CREATE INDEX：在表上建立索引\n- DROP INDEX：删除索引\n\n### DCL\n\nDCL（Data Control Language):数据控制语句，用于定义用户的访问权限和安全级别包括如下SQL语句等：\n\n- GRANT：授予访问权限\n- REVOKE：撤销访问权限\n- COMMIT：提交事务处理\n- ROLLBACK：事务处理回退\n- SAVEPOINT：设置保存点\n- LOCK：对数据库的特定部分进行锁定\n\n### DQL\n\n数据查询语言：简称DQL(Data Query Language)，用来查询数据库中表的记录。关键字：select，from，where等","tags":["mysql"],"categories":["mysql"]},{"title":"mysql条件查询","url":"/2020/05/23/mysql/filterquery/","content":"\n# 条件查询\n\n过滤：使用WHERE 子句，将不满足条件的行过滤掉。\n\n语法：\n\n``` mysql\nselect 查询列表 from 表名 where 筛选条件;\n```\n\n| 比较运算符 | >、< 、>=、<=、= 、<> | 大于、小于、大于等于、小于等于、等于、不等于                 |\n| ---------- | --------------------- | ------------------------------------------------------------ |\n|            | BETWEEN  ...AND...    | 显示在某一区间的值(含头含尾)                                 |\n|            | IN(set)               | 显示在in列表中的值，例：in(100,200)                          |\n|            | LIKE 通配符           | 模糊查询，Like语句中有两个通配符：% 用来匹配多个字符；例first_name like ‘a%’；_ 用来匹配一个字符。例first_name like ‘a_’; |\n|            | IS NULL               | 判断是否为空is null; 判断为空；is not null; 判断不为空       |\n| 逻辑运算符 | and (&&)              | 多个条件同时成立                                             |\n|            | or (\\|\\|)             | 多个条件任一成立                                             |\n|            | not (!)               | 不成立，例：where not(salary>100);                           |\n\n## 案例\n\n### 按条件表达式筛选\n\n1. 查询工资>12000的员工信息\n\n   ``` mysql\n   SELECT \n   \t*\n   FROM\n   \temployees\n   WHERE\n   \tsalary>12000;\n   ```\n\n2. 查询部门编号不等于90号的员工名和部门编号\n\n   ``` mysql\n   SELECT \n   \tlast_name,\n   \tdepartment_id\n   FROM\n   \temployees\n   WHERE\n   \tdepartment_id<>90;\n   ```\n\n### 按逻辑表达式筛选\n\n1. 查询工资在10000到20000之间的员工名、工资以及奖金\n\n   ``` mysql\n   SELECT\n   \tlast_name,\n   \tsalary,\n   \tcommission_pct\n   FROM\n   \temployees\n   WHERE\n   \tsalary>=10000 AND salary<=20000;\n   ```\n\n   或者\n\n   ``` mysql\n   SELECT\n   \tlast_name,\n   \tsalary,\n   \tcommission_pct \n   FROM\n   \temployees \n   WHERE\n   \tsalary BETWEEN 10000 \n   \tAND 20000;\n   ```\n\n2. 查询部门编号不是在90到110之间，或者工资高于15000的员工信息\n\n   ``` mysql\n   SELECT\n   \t* \n   FROM\n   \temployees \n   WHERE\n   \tNOT ( department_id >= 90 AND department_id <= 110 ) \n   \tOR salary > 15000;\n   ```\n\n   或者\n\n   ``` mysql\n   SELECT\n   \t* \n   FROM\n   \temployees \n   WHERE\n   \tNOT ( department_id BETWEEN 90 AND 110 ) \n   \tOR salary > 15000;\n   ```\n\n\n### 模糊查询\n\n1. 查询员工名中包含字符a的员工信息\n\n   ``` mysql\n   select \n   \t*\n   from\n   \temployees\n   where\n   \tlast_name like '%a%';\n   ```\n\n2. 查询员工名中第三个字符为e，第五个字符为a的员工名和工资\n\n   ``` mysql\n   select\n   \tlast_name,\n   \tsalary\n   FROM\n   \temployees\n   WHERE\n   \tlast_name LIKE '__e_a%';\n   ```\n\n3. 查询员工名中第二个字符为_的员工名\n\n   ESCAPE：定义转义标识\n\n   ``` mysql\n   SELECT\n   \tlast_name\n   FROM\n   \temployees\n   WHERE\n   \tlast_name LIKE '_$_%' ESCAPE '$';\n   ```\n\n### IN\n\n含义：判断某字段的值是否属于in列表中的某一项\n特点：\n\n1. 使用in提高语句简洁度\n2. 列表的值类型必须一致或兼容\n3. 列表中不支持通配符\n\n查询员工的工种编号是 IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号\n\n``` mysql\nSELECT\n\tlast_name,\n\tjob_id\nFROM\n\temployees\nWHERE\n\tjob_id IN( 'IT_PROT' ,'AD_VP','AD_PRES');\n```\n\n或者\n\n``` mysql\nSELECT\n\tlast_name,\n\tjob_id\nFROM\n\temployees\nWHERE\n\tjob_id = 'IT_PROT' OR job_id = 'AD_VP' OR JOB_ID ='AD_PRES';\n```\n\n### IS NULL\n\n**=或<>不能用于判断null值**\nis null或is not null 可以判断null值\n\n1. 查询没有奖金的员工名和奖金率\n\n   ``` mysql\n   SELECT\n   \tlast_name,\n   \tcommission_pct\n   FROM\n   \temployees\n   WHERE\n   \tcommission_pct IS NULL;\n   ```\n\n2. 查询有奖金的员工名和奖金率\n\n   ``` mysql\n   SELECT\n   \tlast_name,\n   \tcommission_pct\n   FROM\n   \temployees\n   WHERE\n   \tcommission_pct IS NOT NULL;\n   ```\n\n### 安全等于  <=>\n\n1. 查询没有奖金的员工名和奖金率\n\n   ``` mysql\n   SELECT\n   \tlast_name,\n   \tcommission_pct\n   FROM\n   \temployees\n   WHERE\n   \tcommission_pct <=>NULL;\n   ```\n\n2. 查询工资为12000的员工信息\n\n   ``` mysql\n   SELECT\n   \tlast_name,\n   \tsalary\n   FROM\n   \temployees\n   \n   WHERE \n   \tsalary <=> 12000;\n   ```\n\n   \n\nIS NULL:仅仅可以判断NULL值，可读性较高，建议使用\n<=>    :既可以判断NULL值，又可以判断普通的数值，可读性较低\n\n<span style=\"color:red\">错误的写法：</span>\n\n<del>\n\n``` mysql\nSELECT\n\tlast_name,\n\tcommission_pct\nFROM\n\temployees\n\nWHERE \n\tsalary IS 12000;\n```\n\n</del>","tags":["mysql"],"categories":["mysql"]},{"title":"mysql存储函数","url":"/2020/05/23/mysql/function/","content":"\n\n# 存储函数\n\n## 存储过程与存储函数的区别\n\n> 存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新\n>\n> 存储函数：有且仅有1 个返回，适合做处理数据后返回一个结果\n\n\n\n## 创建语法\n\n```\nCREATE FUNCTION 函数名(参数列表) RETURNS 返回类型\nBEGIN\n\t函数体\nEND\n```\n\n\n\n- 参数列表 包含两部分：参数名，参数类型\n- 函数体：\n  - 肯定会有return语句，如果没有会报错 如果return语句没有放在函数体的最后也不报错，但不建议\n  - 函数体中仅有一句话，则可以省略begin end\n- 使用 delimiter语句设置结束标记\n\n## 调用语法\n\n```\nSELECT 函数名(参数列表);\n```\n\n\n\n## 无参有返回\n\n返回公司的员工个数\n\n``` mysql\nUSE myemployees;\nDELIMITER //\nCREATE FUNCTION myf1() RETURNS INT\nBEGIN\n\n\tDECLARE c INT DEFAULT 0;\t#定义局部变量\n\tSELECT COUNT(*) INTO c \t#赋值\n\tFROM employees;\n\tRETURN c;\n\t\nEND //\n```\n\n``` mysql\nSELECT myf1();\n```\n\n\n\n## 有参有返回\n\n根据员工名，返回它的工资\n\n``` mysql\nDELIMITER //\nCREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLE\nBEGIN\n\tSET @sal=0;\t#定义用户变量 \n\tSELECT salary INTO @sal\t#赋值\n\tFROM employees\n\tWHERE last_name = empName;\n\t\n\tRETURN @sal;\n\t\nEND //\n```\n\n``` mysql\nSELECT myf2('Kochhar');\n\nSELECT @sal;\n```\n\n根据部门名，返回该部门的平均工资\n\n``` mysql\nDELIMITER //\nCREATE FUNCTION myf3(deptName VARCHAR(20)) RETURNS DOUBLE\nBEGIN\n\tDECLARE sal DOUBLE ;\n\tSELECT AVG(salary) INTO sal\n\tFROM employees e\n\tJOIN departments d ON e.department_id = d.department_id\n\tWHERE d.department_name=deptName;\n\tRETURN sal;\nEND //\n```\n\n``` mysql\nSELECT myf3('IT');\n```\n\n\n\n## 查看函数\n\n``` mysql\nSHOW CREATE FUNCTION myf3;\n```\n\n\n\n### 删除函数\n\n``` mysql\nDROP FUNCTION myf3;\n```\n\n\n\n创建函数，实现传入两个float，返回二者之和\n\n``` mysql\nDELIMITER //\nCREATE OR REPLACE FUNCTION myf3(num1 FLOAT,num2 FLOAT) RETURNS FLOAT(3,1)\nBEGIN\n\tDECLARE SUM FLOAT(3,1) DEFAULT 0;\n\tSET SUM=num1+num2;\n\tRETURN SUM;\nEND //\n```\n\n``` mysql\nSELECT myf3(15.5,15.3);\t--> 30.8\n```\n\n","tags":["mysql"],"categories":["mysql"]},{"title":"mysql分组函数","url":"/2020/05/23/mysql/groupfunctions/","content":"\n# 分组函数\n\n用作统计使用，又称为聚合函数或统计函数或组函数\n\n## SUM(expression)\n\n​\t求和\n\n```mysql\nSELECT SUM(salary) FROM employees;\n```\n\n## AVG(expression)\n\n​\t平均值\n\n``` mysql\nSELECT AVG(salary) FROM employees;\n```\n\n\n\n## MAX(expression)\n\n​\t最大值\n\n``` mysql\nSELECT MAX(salary) FROM employees;\n```\n\n\n\n## MIN(expression)\n\n​\t最小值\n\n``` mysql\nSELECT MIN(salary) FROM employees;\n```\n\n\n\n## COUNT(expression)\n\n​\t计算个数\n\n``` mysql\nSELECT COUNT(salary) FROM employees;\n```\n\n``` mysql\nSELECT COUNT(*) FROM employees;\n```\n\n``` mysql\nSELECT COUNT(1) FROM employees;\n```\n\n效率：\n`MYISAM`存储引擎下  ，COUNT(*)的效率高\n`INNODB`存储引擎下，COUNT(*)和COUNT(1)的效率差不多，比COUNT(字段)要高一些\n\n------\n\n\n\n``` mysql\nSELECT\n\tSUM( salary ) 和,\n\tAVG( salary ) 平均,\n\tMAX( salary ) 最高,\n\tMIN( salary ) 最低,\n\tCOUNT( salary ) 个数 \nFROM\n\temployees;\n```\n\n平均工资保留两位小数(四舍五入)\n\n``` mysql\nSELECT\n\tSUM( salary ) 和,\n\tROUND( AVG( salary ), 2 ) 平均,\n\tMAX( salary ) 最高,\n\tMIN( salary ) 最低,\n\tCOUNT( salary ) 个数 \nFROM\n\temployees;\n```\n\n## 参数支持哪些类型\n\n### 字符\n\n先试图将字符转换成数值，如果转换成功，则继续运算；否则转换成0，再做运算\n\n``` mysql\nSELECT\n\tSUM( last_name ),\n\tAVG( last_name ) \nFROM\n\temployees;\n\t\n--> 0,0\n```\n\n与排序差不多\n\n``` mysql\nSELECT\n\tMAX( last_name ),\n\tMIN( last_name ) \nFROM\n\temployees;\n```\n\n\n\n### 日期\n\n``` mysql\nSELECT SUM(hiredate) ,AVG(hiredate) FROM employees;\n```\n\n\n\n``` mysql\nSELECT MAX(hiredate),MIN(hiredate) FROM employees;\n```\n\n\n\n\n\n## 特点\n\n1. sum、avg一般用于处理数值型\n\n2. max、min、count可以处理任何类型\n3. 以上分组函数都忽略null值\n4. 可以和distinct搭配实现去重的运算\n5. 一般使用count(*)用作统计行数\n6. 和分组函数一同查询的字段要求是group by后的字段\n\n## 案例\n\n1. 查询员工表中的最大入职时间和最小入职时间的相差天数 （DIFFRENCE）\n\n   ``` mysql\n   SELECT\n   \tMAX( hiredate ) 最大,\n   \tMIN( hiredate ) 最小,\n   \t(MAX( hiredate )- MIN( hiredate ))/ 1000 / 3600 / 24 DIFFRENCE \n   FROM\n   \temployees;\n   ```\n\n   使用DATEDIFF(d1,d2)函数，计算日期 d1～d2 之间相隔的天数\n\n   ``` mysql\n   SELECT DATEDIFF(MAX(hiredate),MIN(hiredate)) DIFFRENCE;\n   ```\n\n   \n\n2. 查询部门编号为90的员工个数\n\n   ``` mysql\n   SELECT\n   \tCOUNT(*) \n   FROM\n   \temployees \n   WHERE\n   \tdepartment_id = 90;\n   ```\n\n   ","tags":["mysql"],"categories":["mysql"]},{"title":"mysql的安装与使用","url":"/2020/05/23/mysql/install/","content":"\n# mysql的安装与使用\n\n## mysql的安装\n\n- [Windows](https://www.runoob.com/mysql/mysql-install.html) （下拉看**Windows 上安装 MySQL部分**）\n- [Linux](https://note.zzrfdsn.cn/note/root/cloudlandboy/linux/1566488563139.html)\n\n## 启动和停止MySQL服务\n\n- Windows\n\n  - 方式一：通过计算机管理方式\n\n    右击计算机—管理—服务—启动或停止MySQL服务\n\n  - 方式二：通过命令行方式\n\n    启动：net start mysql服务名\n\n    停止：net stop mysql服务名\n\n- Linux\n\n  启动：service mysql(mysqld) start\n\n  停止：service mysql(mysqld) stop\n\n  状态：service mysql(mysqld) status\n\n## MySQL服务端的登录和退出\n\n- 登录\n\n  mysql –u用户名 –p密码\n\n- 远程登录\n\n  mysql -h 主机名 -P 端口号 -u root -proot\n\n- 退出\n\n  exit(quit)\n\n## MySql数据库的使用\n\n- 不区分大小写(Linux上区分，可以通过配置文件修改)\n- 每句话用;或\\g结尾\n- 各子句一般分行写\n- 关键字不能缩写也不能分行\n- 用缩进提高语句的可读性\n\n## 基本命令\n\n查看 mysql 中有哪些个数据库: \n\n``` mysql\nshow databases;\n```\n\n 使用一个数据库: \n\n``` mysql\nuse 数据库名称;\n```\n\n查看当前使用数据库中的表：\n\n``` mysql\nshow tables;\n```\n\n查看指定数据库中的表：\n\n``` mysql\nshow tables from 库名;\n```\n\n新建一个数据库: \n\n``` mysql\n#创建数据库 数据库中数据的编码采用的是安装数据库时指定的默认编码 utf8\nCREATE DATABASE 数据库名;\n\n#创建数据库 并指定数据库中数据的编码\nCREATE DATABASE 数据库名 CHARACTER SET utf8;\n```\n\n查看当前选择的数据库:\n\n``` mysql\nselect database();\n```\n\n创建表:\n\n``` mysql\ncreate table stuinfo(\n    id int,\n    name varchar(20));\n```\n\n查看表结构:\n\n``` mysql\ndesc 表名;\n```\n\n查看表中的所有记录: \n\n``` mysql\nselect * from 表名;\n```\n\n向表中插入记录：\n\n``` mysql\ninsert into 表名(列名1,列名,...,列名n) values(列1值,列2值,...,列n值);\n```\n\n<mark><small>注意：插入 varchar 或 date 型的数据要用 单引号 引起来<small></mark>","tags":["mysql"],"categories":["mysql"]},{"title":"mysql连接查询","url":"/2020/05/23/mysql/joinquery/","content":"\n# 连接查询\n\n## 含义\n\n又称多表查询，当查询的字段来自于多个表时，就会用到连接查询\n\n```\nselect 字段1，字段2\n\nfrom 表1，表2,...;\n```\n\n## 笛卡尔乘积现象\n\n当查询多个表时，没有添加有效的连接条件，导致多个表所有行实现完全连接\n\n表1 有m行，表2有n行，结果=m*n行\n\n发生原因：没有有效的连接条件\n如何避免：添加有效的连接条件\n\n## 分类\n\n按年代分类：\n\tsql92标准:仅仅支持内连接\n\tsql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接\n\t\n\n\t按功能分类：\n\t\t内连接：\n\t\t\t等值连接\n\t\t\t非等值连接\n\t\t\t自连接\n\t\t外连接：\n\t\t\t左外连接\n\t\t\t右外连接\n\t\t\t全外连接（mysql不支持）\n\t\t\n\t\t交叉连接\n## 等值连接\n\n1. 多表等值连接的结果为多表的交集部分\n2. n表连接，至少需要n-1个连接条件\n3. 表的顺序没有要求\n4. 一般需要为表起别名\n5. 可以搭配前面介绍的所有子句使用，比如排序、分组、筛选\n\n### 案例1\n\n1. 查询女神名和对应的男神名\n\n   ``` mysql\n   SELECT NAME,boyName \n   FROM\n   \tboys,\n   \tbeauty \n   WHERE\n   \tbeauty.boyfriend_id = boys.id;\n   ```\n\n   \n\n2. 查询员工名和对应的部门名\n\n   ``` mysql\n   SELECT\n   \tlast_name,\n   \tdepartment_name \n   FROM\n   \temployees,\n   \tdepartments \n   WHERE\n   \temployees.`department_id` = departments.`department_id`;\n   ```\n\n   \n\n### 为表起别名\n\n1. 提高语句的简洁度\n2. 区分多个重名的字段\n\n`注意`：如果为表起了别名，则查询的字段就不能使用原来的表名去限定\n\n1. 查询员工名、工种号、工种名\n\n   ``` mysql\n   SELECT\n   \te.last_name,\n   \te.job_id,\n   \tj.job_title \n   FROM\n   \temployees e,\n   \tjobs j \n   WHERE\n   \te.`job_id` = j.`job_id`;\n   ```\n\n### 加筛选条件\n\n1. 查询有奖金的员工名、部门名\n\n   ``` mysql\n   SELECT\n   \tlast_name,\n   \tdepartment_name,\n   \tcommission_pct \n   FROM\n   \temployees e,\n   \tdepartments d \n   WHERE\n   \te.`department_id` = d.`department_id` \n   \tAND e.`commission_pct` IS NOT NULL;\n   ```\n\n   \n\n2. 查询城市名中第二个字符为o的部门名和城市名\n\n   ``` mysql\n   SELECT\n   \tdepartment_name,\n   \tcity \n   FROM\n   \tdepartments d,\n   \tlocations l \n   WHERE\n   \td.`location_id` = l.`location_id` \n   \tAND city LIKE '_o%';\n   ```\n\n   \n\n### 加分组\n\n1. 查询每个城市的部门个数\n\n   ``` mysql\n   SELECT\n   \tCOUNT(*) 个数,\n   \tcity \n   FROM\n   \tdepartments d,\n   \tlocations l \n   WHERE\n   \td.`location_id` = l.`location_id` \n   GROUP BY\n   \tcity;\n   ```\n\n   \n\n2. 查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资\n\n   ``` mysql\n   SELECT\n   \tdepartment_name,\n   \td.`manager_id`,\n   \tMIN( salary ) \n   FROM\n   \tdepartments d,\n   \temployees e \n   WHERE\n   \td.`department_id` = e.`department_id` \n   \tAND commission_pct IS NOT NULL \n   GROUP BY\n   \tdepartment_name,\n   \td.`manager_id`;\n   ```\n\n   \n\n3. 查询每个工种的工种名和员工的个数，并且按员工个数降序\n\n   ``` mysql\n   SELECT\n   \tjob_title,\n   \tCOUNT(*) \n   FROM\n   \temployees e,\n   \tjobs j \n   WHERE\n   \te.`job_id` = j.`job_id` \n   GROUP BY\n   \tjob_title \n   ORDER BY\n   \tCOUNT(*) DESC;\n   ```\n\n   \n\n4. 查询员工名、部门名和所在的城市，并且城市名以s开头，按部门名称降序\n\n   ``` mysql\n   SELECT\n   \te.last_name 员工名,\n   \td.department_name 部门名,\n   \tl.city 城市 \n   FROM\n   \temployees e,\n   \tdepartments d,\n   \tlocations l \n   WHERE\n   \te.department_id = d.department_id \n   \tAND d.location_id = l.location_id \n   \tAND city LIKE 's%' \n   ORDER BY\n   \tdepartment_name DESC;\n   ```\n\n## 非等值连接\n\n### 语法\n\n   ```\n   \tselect 查询列表\n   \tfrom 表1 别名,表2 别名\n   \twhere 非等值的连接条件\n   \t【and 筛选条件】\n   \t【group by 分组字段】\n   \t【having 分组后的筛选】\n   \t【order by 排序字段】\n   ```\n\n### 案例2\n\n1. 查询员工的工资和工资级别\n\n   ``` mysql\n   SELECT\n   \te.salary 工资,\n   \tj.grade_level 工资级别 \n   FROM\n   \temployees e,\n   \tjob_grades j \n   WHERE\n   \te.salary BETWEEN j.lowest_sal \n   \tAND j.highest_sal;\n   ```\n\n   \n\n2. 查询员工的工资和工资级别并筛选出级别为A的\n\n   ``` mysql\n   SELECT\n   \te.salary 工资,\n   \tj.grade_level 工资级别 \n   FROM\n   \temployees e,\n   \tjob_grades j \n   WHERE\n   \te.salary BETWEEN j.lowest_sal \n   \tAND j.highest_sal \n   \tAND j.grade_level = 'A';\n   ```\n\n## 自连接\n\n连接的相同的表\n\n### 语法\n\n``` mysql\n\tselect 查询列表\n\tfrom 表 别名1,表 别名2\n\twhere 等值的连接条件\n\t【and 筛选条件】\n\t【group by 分组字段】\n\t【having 分组后的筛选】\n\t【order by 排序字段】\n```\n\n1. 查询员工名和上级的名称\n\n   ``` mysql\n   SELECT\n   \te.last_name 员工名,\n   \tm.last_name 上级名称 \n   FROM\n   \temployees e,\n   \temployees m \n   WHERE\n   \te.manager_id = m.employee_id;\n   ```\n\n   \n\n## SQL99语法-内连接\n\n\tselect 查询列表\n\tfrom 表1 别名\n\t【inner】 join 表2 别名 on 连接条件\n\twhere 筛选条件\n\tgroup by 分组列表\n\thaving 分组后的筛选\n\torder by 排序列表\n\tlimit 子句;\n### 特点\n\n1. 表的顺序可以调换\n2. 内连接的结果=多表的交集\n3. n表连接至少需要n-1个连接条件\n4. 添加排序、分组、筛选\n5. inner可以省略\n6. 筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读\n7. inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集\n\n### 分类\n\n- 等值连接\n- 非等值连接\n- 自连接\n\n### 内连接-等值连接\n\n1. 查询员工名、部门名\n\n   ``` mysql\n   SELECT\n   \tlast_name,\n   \tdepartment_name \n   FROM\n   \tdepartments d\n   \tINNER JOIN employees e ON e.`department_id` = d.`department_id`;\n   ```\n\n   \n\n2. 查询名字中包含e的员工名和工种名（添加筛选）\n\n   ``` mysql\n   SELECT\n   \tlast_name,\n   \tjob_title \n   FROM\n   \temployees e\n   \tJOIN jobs j ON e.`job_id` = j.`job_id` \n   WHERE\n   \te.`last_name` LIKE '%e%';\n   ```\n\n   \n\n3. 查询部门个数>3的城市名和部门个数，（添加分组+筛选）\n\n   ``` mysql\n   SELECT\n   \tCOUNT( department_id ) 部门个数,\n   \tcity 城市名 \n   FROM\n   \tdepartments d\n   \tJOIN locations l ON d.location_id = l.location_id \n   GROUP BY\n   \tl.city \n   HAVING\n   \tCOUNT( department_id )> 3;\n   ```\n\n   \n\n4. 查询哪个部门的员工个数>3的部门名和员工个数，并按个数降序（添加排序）\n\n   ``` mysql\n   SELECT\n   \tCOUNT(*) 员工个数,\n   \td.department_name 部门名称 \n   FROM\n   \tdepartments d\n   \tJOIN employees e ON d.department_id = e.department_id \n   GROUP BY\n   \td.department_id \n   HAVING\n   \tCOUNT(\n   \t*)> 3 \n   ORDER BY\n   \t1 DESC\n   ```\n\n   \n\n5. 查询员工名、部门名、工种名，并按部门名降序（添加三表连接）\n\n   ``` mysql\n   SELECT\n   \te.last_name 员工名,\n   \td.department_name 部门号,\n   \tj.job_title 工种名 \n   FROM\n   \temployees e\n   \tJOIN departments d ON e.department_id = d.department_id\n   \tJOIN jobs j ON e.job_id = j.job_id \n   ORDER BY\n   \td.department_name DESC;\n   ```\n\n### 内连接-非等值连接\n\n1. 查询员工的工资级别\n\n   ``` mysql\n   SELECT\n   \te.last_name 员工名,\n   \te.salary 薪水,\n   \tj.grade_level 工资级别 \n   FROM\n   \temployees e\n   \tJOIN job_grades j ON e.salary BETWEEN j.lowest_sal \n   \tAND j.highest_sal;\n   ```\n\n   \n\n2. 查询工资级别的个数>20的个数，并且按工资级别降序\n\n   ``` mysql\n   SELECT\n   \tj.grade_level 工资级别,\n   \tCOUNT( * ) 个数 \n   FROM\n   \temployees e\n   \tJOIN job_grades j ON e.salary BETWEEN j.lowest_sal \n   \tAND j.highest_sal \n   GROUP BY\n   \tj.grade_level \n   HAVING\n   \tCOUNT( * ) > 20 \n   ORDER BY\n   \t2 DESC;\n   ```\n\n   \n\n### 内连接-自连接\n\n1. 查询员工的名字、上级的名字\n\n   ``` mysql\n   SELECT\n   \te.last_name 员工名,\n   \tm.last_name 上级名 \n   FROM\n   \temployees e\n   \tJOIN employees m ON e.manager_id = m.employee_id;\n   ```\n\n   \n\n2. 查询姓名中包含字符k的员工的名字、上级的名字\n\n   ``` mysql\n   SELECT\n   \te.last_name 员工名,\n   \tm.last_name 上级名 \n   FROM\n   \temployees e\n   \tJOIN employees m ON e.manager_id = m.employee_id \n   WHERE\n   \te.last_name LIKE '%k%'\n   ```\n\n   \n\n## SQL99语法-外连接\n\n### 语法\n\n```\nselect 查询列表\nfrom 表1 别名\nleft|right|full【outer】 join 表2 别名 on 连接条件\nwhere 筛选条件\ngroup by 分组列表\nhaving 分组后的筛选\norder by 排序列表\nlimit 子句;\n```\n\n### 应用场景\n\n用于查询一个表中有，另一个表没有的记录\n\n### 特点\n\n1. 外连接的查询结果为主表中的所有记录\n\n   如果从表中有和它匹配的，则显示匹配的值\n\n   如果从表中没有和它匹配的，则显示null\n\n   外连接查询结果=内连接结果+主表中有而从表没有的记录\n\n2. 左外连接，`left join` 左边的是主表\n\n3. 右外连接，`right join` 右边的是主表\n\n4. 左外和右外交换两个表的顺序，可以实现同样的效果 \n\n5. 全外连接=内连接的结果+表1中有但表2没有的+表2中有但表1没有的\n\n### 左外连接\n\n1. 查询哪个部门没有员工\n\n   ``` mysql\n   SELECT\n   \td.* \n   FROM\n   \tdepartments d\n   \tLEFT JOIN employees e ON d.department_id = e.department_id \n   WHERE\n   \te.department_id IS NULL\n   ```\n\n### 右外连接\n\n1. 查询哪个部门没有员工(调换位置使用RIGHT JOIN)\n\n   ``` mysql\n   SELECT\n   \td.* \n   FROM\n   \temployees e\n   \tRIGHT JOIN departments d ON d.department_id = e.department_id \n   WHERE\n   \te.department_id IS NULL\n   ```\n\n### 全外连接\n\nmysql不支持全外连接\n\n<del>\n\n``` sql\n USE girls;\n SELECT b.*,bo.*\n FROM beauty b\n FULL OUTER JOIN boys bo\n ON b.`boyfriend_id` = bo.id;\n```\n\n</del>\n\nbeauty表中有其他的数据与boys表没有关系(就是这些女神还是单身)，就把boys表的那部分全部显示为空，\n\n同样boys表有的beauty没有的也是显示null\n\n### 交叉连接\n\n交叉联接返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积。    \n\n``` mysql\n SELECT b.*,bo.*\n FROM beauty b\n CROSS JOIN boys bo;\n```\n\n","tags":["mysql"],"categories":["mysql"]},{"title":"mysql分组查询","url":"/2020/05/23/mysql/groupquery/","content":"\n# 分组查询\n\n## 语法\n\n``` \nselect 分组函数，分组后的字段\nfrom 表\n【where 筛选条件】\n group by 分组的字段\n【having 分组后的筛选】\n【order by 排序列表】\n```\n\n## 特点\n\n1. 和分组函数一同查询的字段`必须`是group by后出现的字段\n2. 筛选分为两类：分组前筛选和分组后筛选\n\n|    筛选    |      针对的表      | 连接的关键字 |\n| :--------: | :----------------: | :----------: |\n| 分组前筛选 |       原始表       |    where     |\n| 分组后筛选 | group by后的结果集 |    having    |\n\n## 问题\n\n1. 分组函数做筛选能不能放在where后面\n\n   不能，原表中没有分组后的数据\n\n\n\n## 案例\n\n### 简单的分组\n\n1. 查询每个工种的员工平均工资\n\n   ``` mysql\n   SELECT AVG(salary),job_id\n   FROM employees\n   GROUP BY job_id;\n   ```\n\n2. 查询每个位置的部门个数\n\n   ``` mysql\n   SELECT COUNT(*),location_id\n   FROM departments\n   GROUP BY location_id;\n   ```\n\n### 分组前筛选\n\n1. 查询邮箱中包含a字符的 每个部门的最高工资\n\n   ``` mysql\n   SELECT MAX(salary),department_id\n   FROM employees\n   WHERE email LIKE '%a%'\n   GROUP BY department_id;\n   ```\n\n   \n\n2. 查询有奖金的每个领导手下员工的平均工资\n\n   ``` mysql\n   SELECT\n   \tAVG( salary ),\n   \tmanager_id \n   FROM\n   \temployees \n   WHERE\n   \tcommission_pct IS NOT NULL \n   GROUP BY\n   \tmanager_id;\n   ```\n\n### 分组后筛选\n\n1. 查询哪个部门的员工个数>5\n\n   ① 首先查询每个部门的员工个数\n\n   ``` mysql\n   SELECT COUNT(*),department_id\n   FROM employees\n   GROUP BY department_id;\n   ```\n\n   ② 筛选刚才①结果\n\n   ``` mysql\n   SELECT COUNT(*),department_id\n   FROM employees\n   \n   GROUP BY department_id\n   \n   HAVING COUNT(*)>5;\n   ```\n\n   \n\n2. 每个工种有奖金的员工的最高工资>12000的工种编号和最高工资\n\n   ``` mysql\n   SELECT\n   \tMAX( salary ) 最高工资,\n   \tjob_id 工种编号 \n   FROM\n   \temployees \n   WHERE\n   \tcommission_pct IS NOT NULL \n   GROUP BY\n   \tjob_id \n   HAVING\n   \tMAX( salary )> 12000;\n   ```\n\n   \n\n3. 领导编号>102的每个领导手下的最低工资大于5000的领导编号和最低工资\n\n   ``` mysql\n   SELECT\n   \tmanager_id 领导编号,\n   \tMIN( salary ) 最低工资 \n   FROM\n   \temployees \n   WHERE\n   \tmanager_id > 102 \n   GROUP BY\n   \tmanager_id \n   HAVING\n   \tMIN( salary )> 5000\n   ```\n\n   \n\n### 添加排序\n\n1. 每个工种有奖金的员工的最高工资>6000的工种编号和最高工资,按最高工资升序\n\n   ``` mysql\n   SELECT\n   \tjob_id 工种编号,\n   \tMAX( salary ) 最高工资 \n   FROM\n   \temployees \n   WHERE\n   \tcommission_pct IS NOT NULL \n   GROUP BY\n   \tjob_id \n   HAVING\n   \tMAX( salary )> 6000 \n   ORDER BY\n   \tMAX( salary );\n   ```\n\n   \n\n### 按多个字段分组\n\n1. 查询每个工种每个部门的最低工资,并按最低工资降序\n\n   ``` mysql\n   SELECT\n   \tMIN( salary ) 最低工资,\n   \tdepartment_id 部门,\n   \tjob_id 工种 \n   FROM\n   \temployees \n   GROUP BY\n   \tdepartment_id,\n   \tjob_id \n   ORDER BY\n   \tMIN( salary ) DESC;\n   ```\n\n   \n\n","tags":["mysql"],"categories":["mysql"]},{"title":"mysql分页查询","url":"/2020/05/23/mysql/limitquery/","content":"\n# 分页查询\n\n## 应用场景\n\n当要显示的数据，一页显示不全，需要分页提交sql请求\n\n## 语法\n\n```\n\tselect 查询列表\n\tfrom 表\n\t【join type】 join 表2\n\ton 连接条件\n\twhere 筛选条件\n\tgroup by 分组字段\n\thaving 分组后的筛选\n\torder by 排序的字段】\n\tlimit 【offset,】size;\n```\n\n`offset`要显示条目的起始索引（起始索引从0开始）\n\n`size` 要显示的条目个数\n\n## 分页公式\n\n`(page-1)*size,size`\n\n## 案例\n\n1. 查询前五条员工信息\n\n   ``` mysql\n   SELECT * FROM  employees LIMIT 0,5;\n   # 或者\n   SELECT * FROM  employees LIMIT 5;\n   ```\n\n   \n\n2. 查询第11条~第25条\n\n   ``` mysql\n   SELECT * FROM  employees LIMIT 10,15;\n   ```\n\n3. 有奖金的员工信息，并且工资较高的前10名显示出来\n\n   ``` mysql\n   SELECT \n       * \n   FROM\n       employees \n   WHERE commission_pct IS NOT NULL \n   ORDER BY salary DESC \n   LIMIT 10;\n   ```\n\n   ","tags":["mysql"],"categories":["mysql"]},{"title":"mysql-SQL练习-01","url":"/2020/05/23/mysql/practice01/","content":"\n# SQL练习-01\n\n## TOPIC1\n\n> 用一条SQL 语句 查询出每门课都大于80 分的学生姓名\n\n```sql\nDROP TABLE IF EXISTS student;\nCREATE TABLE student(\n\tname VARCHAR(10) COMMENT '姓名',\n\tkecheng VARCHAR(10) COMMENT '课程',\n\tfenshu TINYINT UNSIGNED COMMENT '姓名'\n);\n\nINSERT INTO student VALUES('张三','语文',81);\nINSERT INTO student VALUES('张三','数学',75);\nINSERT INTO student VALUES('李四','语文',76);\nINSERT INTO student VALUES('李四','数学',90);\nINSERT INTO student VALUES('王五','语文',81);\nINSERT INTO student VALUES('王五','数学',100);\nINSERT INTO student VALUES('王五','英语',90);\nINSERT INTO student VALUES('赵六','语文',90);\nINSERT INTO student VALUES('赵六','英语',90);\n```\n\n<details>\n    <summary>答案</summary>\n\n```sql\n# A. 使用子查询\nSELECT DISTINCT `name` FROM student WHERE `name` NOT IN (SELECT `name` FROM student WHERE fenshu<=80);\n\n# B. 使用分组过滤查询\nSELECT `name` FROM student GROUP BY `name` HAVING MIN(fenshu)>80;\n```\n\n</details>\n\n\n\n## TOPIC2\n\n> 删除除了编号不同, 其他都相同的学生冗余信息\n\n```sql\nDROP TABLE IF EXISTS student;\n CREATE TABLE student(\n\tid BIGINT(10) COMMENT '编号',\n\tsid VARCHAR(10) COMMENT '学号',\n\tname VARCHAR(10) COMMENT '姓名',\n\tcid VARCHAR(10) COMMENT '课程编号',\n\tcname VARCHAR(10) COMMENT '课程名称',\n\tscore TINYINT UNSIGNED COMMENT '分数'\n);\n\nINSERT INTO student VALUES(1,'2005001','张三','0001','数学',69);\nINSERT INTO student VALUES(2,'2005002','李四','0001','数学', 89);\nINSERT INTO student VALUES(3,'2005001','张三','0001','数学', 69);\n```\n\n<details>\n    <summary>答案</summary>\n\n思路：对编号以外的其他字段进行分组，然后只保留最小的，删除其他的\n\n```sql\nDELETE FROM student WHERE id NOT IN (SELECT MIN(id) FROM student GROUP BY sid,`name`,cid,cname,score);\n```\n\n上面可能会报错，说是查询和删除的是同一张表，那就再查询一次虚表\n\n![1576832038562](https://cdn.static.note.zzrfdsn.cn/images/mysql/1576832038562.png)\n\n```sql\nDELETE FROM student WHERE id NOT IN (SELECT * FROM (SELECT MIN(id) FROM student GROUP BY sid,`name`,cid,cname,score) temp);\n```\n\n</details>\n\n\n\n## TOPIC3\n\n> 一个叫 team 的表，里面只有一个字段name, 一共有4 条纪录，分别是a,b,c,d, 对应四个球对，现在四个球对进行比赛，用一条sql 语句显示所有可能的比赛组合.\n>\n> *eg*：ab，ac ，ad，bc，......\n\n```sql\nDROP TABLE IF EXISTS team;\nCREATE TABLE team(\n\tname VARCHAR(1) COMMENT '球队名称'\n)\nINSERT INTO team VALUES('a'),('b'),('c'),('d');\n```\n\n<details>\n    <summary>答案</summary>\n\n```sql\nSELECT CONCAT(a.name,b.name) \"组合名\" FROM team a,team b WHERE a.name<b.name \n```\n\n</details>\n\n\n\n## TOPIC4\n\n> 怎么把这样一个表儿：\n\n```sql\nDROP TABLE IF EXISTS temp;\nCREATE TABLE temp(\n\tyear INT UNSIGNED,\n\tMONTH INT UNSIGNED,\n\tamount DECIMAL\n);\n\nINSERT INTO temp VALUES(1991,1,1.1);\nINSERT INTO temp VALUES(1991,2,1.2);\nINSERT INTO temp VALUES(1991,3,1.3);\nINSERT INTO temp VALUES(1991,4,1.4);\nINSERT INTO temp VALUES(1992,1,2.1);\nINSERT INTO temp VALUES(1992,2,2.2);\nINSERT INTO temp VALUES(1992,3,2.3);\nINSERT INTO temp VALUES(1992,4,2.4);\n```\n\n> 查成这样一个结果：\n\n| year | m1   | m2   | m3   | m4   |\n| ---- | ---- | ---- | ---- | ---- |\n| 1991 | 1.1  | 1.2  | 1.3  | 1.4  |\n| 1992 | 2.1  | 2.2  | 2.3  | 2.4  |\n\n<details>\n    <summary>答案</summary>\n\n```sql\nSELECT \n`year`,\n( SELECT amount FROM temp m WHERE MONTH = 1 AND m.YEAR = temp.YEAR ) AS m1,\n( SELECT amount FROM temp m WHERE MONTH = 2 AND m.YEAR = temp.YEAR ) AS m2,\n( SELECT amount FROM temp m WHERE MONTH = 3 AND m.YEAR = temp.YEAR ) AS m3,\n( SELECT amount FROM temp m WHERE MONTH = 4 AND m.YEAR = temp.YEAR ) AS m4 \nFROM\n\ttemp \nGROUP BY\nYEAR\n```\n\n</details>\n\n\n\n## TOPIC5\n\n> 成绩表\n\n```sql\nDROP TABLE IF EXISTS grade;\nCREATE TABLE grade(\n\tcourseid INT PRIMARY KEY auto_increment,\n\tcoursename VARCHAR(10),\n\tscore INT\n);\nINSERT INTO grade VALUES(NULL,'Java',70);\nINSERT INTO grade VALUES(NULL,'oracle',90);\nINSERT INTO grade VALUES(NULL,'xml',40);\nINSERT INTO grade VALUES(NULL,'jsp',30);\nINSERT INTO grade VALUES(NULL,'servlet',80);\n```\n\n\n\n> 要求查询所有课程成绩，60分及格，及格显示pass，否则显示fail，如下：\n\n| courseid | coursename | score | 考试结果 |\n| -------- | ---------- | ----- | -------- |\n| 4        | jsp        | 30    | fail     |\n| 5        | servlet    | 80    | pass     |\n\n<details>\n    <summary>答案</summary>\n\n```sql\nSELECT g.*,IF(g.score>60,'pass','fail') \"考试结果\" FROM grade g; \n```\n\n</details>\n\n\n​\t\t\t","tags":["mysql"],"categories":["mysql"]},{"title":"mysql分支和循环","url":"/2020/05/23/mysql/processcontrol/","content":"\n# 流程控制结构\n\n## 分支结构\n\n### if函数\n\n**语法**：`if(条件,值1，值2)`\n\n**功能**：实现双分支\n\n应用在begin end中或外面\n\n### case结构\n\n类似java中的switch\n\n**功能**：实现多分支\n\n应用在begin end 中或外面\n\n**语法一**：\n\n```\ncase 表达式或字段\nwhen 值1 then 语句1;\nwhen 值2 then 语句2；\n...\nelse 语句n;\nend [case];\n```\n\n**语法二**：\n\n```\ncase \nwhen 条件1 then 语句1;\nwhen 条件2 then 语句2；\n...\nelse 语句n;\nend [case];\n```\n\n\n\n创建函数，实现传入成绩，如果成绩>90,返回A，如果成绩>80,返回B，如果成绩>60,返回C，否则返回D\n\n```mysql\nDELIMITER //\nCREATE OR REPLACE FUNCTION test_case(score DOUBLE) RETURNS CHAR\nBEGIN\n-- DECLARE result CHAR;\nCASE  \n\tWHEN score>90 THEN\n\t\tRETURN 'A';\n\tWHEN score>80 THEN \n\t\tRETURN 'B';\n\tWHEN score>60 THEN\n\t\tRETURN 'C';\n\tELSE\n\t\tRETURN 'D';\nEND CASE;\n\nEND //\n```\n\n```mysql\nSELECT test_case(95);\n\nSELECT test_case(85);\n\nSELECT test_case(75);\n\nSELECT test_case(55);\n```\n\n\n\n### if结构\n\n**功能**：实现多分支\n\n只能放在begin end中\n\n**语法：**\n\n```\nif 条件1 then 语句1;\nelseif 条件2 then 语句2;\n...\nelse 语句n;\nend if;\n```\n\n创建函数，实现传入成绩，如果成绩>90,返回A，如果成绩>80,返回B，如果成绩>60,返回C，否则返回D\n\n```mysql\nDELIMITER //\nCREATE OR REPLACE FUNCTION test_if(score DOUBLE) RETURNS CHAR \nBEGIN \n\tDECLARE result CHAR;\n\tIF score>90 THEN\n\t\tSET result:='A';\n\tELSEIF score>80 THEN\n\t\tSET result:='B';\n\tELSEIF score>60 THEN\n\t\tSET result:='C';\n\tELSE\n\t\tSET result:='D';\n\tEND IF;\n\tRETURN result;\nEND //\n```\n\n``` mysql\nSELECT test_if(95);\n\nSELECT test_if(85);\n\nSELECT test_if(75);\n\nSELECT test_if(55);\n```\n\n创建存储过程，如果工资<2000,则删除，如果5000>工资>2000,则涨工资1000，否则涨工资500\n\n```mysql\nDELIMITER //\nCREATE OR REPLACE PROCEDURE test_if2(IN salary DOUBLE)\nBEGIN\n\n\tIF salary<2000 THEN\n\t\t\tDELETE FROM employees WHERE employees.salary=salary;\n\tELSEIF 2000<salary<5000 THEN \n\t\t\tUPDATE employees SET employees.salary=employees.salary+1000 WHERE employees.salary=salary; \n\tELSE\n\t\t\tUPDATE employees SET employees.salary=employees.salary+500 WHERE employees.salary=salary; \n\tEND IF;\nEND //\n```\n\n```mysql\nCALL test_if2(3300.00);\n```\n\n\n\n## 循环结构\n\n**分类**：`while`、`loop`、`repeat`\n\n**循环控制**：\n\n`iterate`类似于 `continue`，继续，结束本次循环，继续下一次\n\n`leave` 类似于  `break`，跳出，结束当前所在的循环\n\n只能放在begin end中\n\n**标签**：用上循环控制就必须要加\n\n### while\n\n```\n[标签:] while 循环条件 do\n\t循环体;\nend while [标签];\n```\n\n批量插入，根据次数插入到admin表中多条记录\n\n```mysql\nUSE girls;\n\nDELIMITER //\nCREATE OR REPLACE PROCEDURE test_while(IN total INT)\nBEGIN\n\nDECLARE i INT DEFAULT 0;\n\nWHILE i<total DO\n\tINSERT INTO admin VALUES(NULL,CONCAT('员工',i),'8888');\n\tSET i:=i+1;\nEND WHILE;\n\nEND //\n```\n\n```mysql\nCALL test_while(10);\n```\n\n批量插入，根据次数插入到admin表中多条记录，如果次数>20则停止 <span style=\"color:red\">（需要加标签）</span>\n\n````mysql\nDELIMITER //\nCREATE OR REPLACE PROCEDURE test_while(IN total INT)\nBEGIN\n\nDECLARE i INT DEFAULT 1;\n\na:WHILE i<=total DO\n\tIF i>20 THEN LEAVE a;\n\tEND IF;\n\tINSERT INTO admin VALUES(NULL,CONCAT('员工',i),'8888');\n\tSET i:=i+1;\nEND WHILE a;\n\nEND //\n````\n\n```mysql\nTRUNCATE TABLE admin;\nCALL test_while(100);\n```\n\n\n\n批量插入，根据次数插入到admin表中多条记录，只插入偶数次\n\n```mysql\nDELIMITER //\nCREATE OR REPLACE PROCEDURE test_while(IN total INT)\nBEGIN\n\nDECLARE i INT DEFAULT 0;\n\na:WHILE i<=total DO\n\tSET i:=i+1;\n\tIF MOD(i,2)!=0 THEN ITERATE a;\n\tEND IF;\n\tINSERT INTO admin VALUES(NULL,CONCAT('员工',i),'8888');\n\t\nEND WHILE a;\n\nEND //\n\n```\n\n```mysql\nTRUNCATE TABLE admin;\nCALL test_while(20);\n```\n\n\n\n\n\n### loop\n\n```\n[标签:] loop\n\n\t循环体;\n\nend loop [标签];\n\n```\n\n\n\n### repeat\n\n```\n[标签] repeat\n\t循环体;\nuntil 结束循环的条件\nend repeat [标签];\n```\n\n","tags":["mysql"],"categories":["mysql"]},{"title":"mysql单行函数","url":"/2020/05/23/mysql/singlerowfunctions/","content":"\n\n# 单行函数\n\n## 字符函数\n\n### length(s)\n\n获取参数值的字符个数\n\n``` mysql\nSELECT LENGTH('john');\nSELECT LENGTH('张三丰hahaha');\n```\n\n### CONCAT(s1,s2...sn)\n\n 拼接字符串\n\n``` mysql\nSELECT CONCAT(last_name,'_',first_name) 姓名 FROM employees;\n```\n\n### UPPER(s)\n\n将字符串转换为大写\n\n``` mysql\nSELECT UPPER('john');\n```\n\n### LOWER(s)\n\n将字符串转换为小写\n\n``` mysql\nSELECT LOWER('joHn');\n```\n\n``` mysql\n# 示例：将姓变大写，名变小写，然后拼接\nSELECT CONCAT(UPPER(last_name),LOWER(first_name))  姓名 FROM employees;\n```\n\n### SUBSTR(s, start, length)、SUBSTRING()\n\nSUBSTR(s, start, length)：从字符串 s 的 start 位置截取长度为 length 的子字符串\n\n\n\n截取字符串（注意：索引从1开始）\n\n``` mysql\nSELECT SUBSTR('李莫愁爱上了陆展元',7)  out_put;\n```\n\n``` mysql\nSELECT SUBSTRING('李莫愁爱上了陆展元',7)  out_put;\n```\n\n``` mysql\nSELECT SUBSTR('李莫愁爱上了陆展元',1,3)  out_put;\n```\n\n``` mysql\n# 案例：姓名中首字符大写，其他字符小写然后用_拼接，显示出来\n\nSELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),'_',LOWER(SUBSTR(last_name,2)))  out_put\nFROM employees;\n```\n\n\n\n### INSTR(s,s)\n\n返回子串第一次出现的索引，如果找不到返回0\n\n``` mysql\nSELECT INSTR('杨不殷六侠悔爱上了殷六侠','殷八侠') AS out_put;\n```\n\n\n\n### TRIM(s)\n\nLTRIM(s)：去掉字符串 s **开始**处的空格\n\nRTRIM(s)：去掉字符串 s **结尾**处的空格\n\n 去掉字符串开始和结尾处的空格\n\n``` mysql\nSELECT LENGTH(TRIM('    张翠山    ')) AS out_put;\n```\n\n\n\n### LPAD(s1,len,s2)\n\n在字符串 s1 的`开始`处填充字符串 s2，使字符串长度达到 len\n\n如果长度小于原字符串，则只取前len个字符\n\n``` mysql\nSELECT LPAD('殷素素',5,'*') AS out_put;\t--> **殷素素\n```\n\n``` mysql\nSELECT LPAD('殷素素',2,'*') AS out_put;\t--> 殷素\n```\n\n\n\n### RPAD(s1,len,s2)\n\n 在字符串 s1 的`结尾`处添加字符串 s2，使字符串的长度达到 len\n\n如果长度小于原字符串，则只取前len个字符\n\n``` mysql\nSELECT RPAD('殷素素',5,'*') AS out_put;\t--> 殷素素**\n```\n\n``` mysql\nSELECT RPAD('殷素素',2,'*') AS out_put;\t--> 殷素\n```\n\n### REPLACE(s,s1,s2)\n\n用字符串 s2 替代字符串 s 中的字符串 s1\n\n``` mysql\nSELECT REPLACE('张无忌爱上了周芷若','周芷若','赵敏') AS out_put;\t-->张无忌爱上了赵敏\n```\n\n\n\n## 数学函数\n\n### ROUND(x)\n\nROUND(x,d)：保留d位小数\n\n四舍五入\n\n``` mysql\nSELECT ROUND(-1.55);\t--> -2\n```\n\n``` mysql\nSELECT ROUND(1.567,2);\t--> 1.57\n```\n\n### CEIL(x)\n\n向上取整\n\n``` mysql\nSELECT CEIL(-1.02);\t--> -1\n```\n\n``` mysql\nSELECT CEIL(1.02);\t--> 2\n```\n\n### FLOOR(x)\n\n向下取整\n\n``` mysql\nSELECT FLOOR(-1.58);\t--> -2\n```\n\n``` mysql\nSELECT FLOOR(1.58);\t--> 1\n```\n\n### TRUNCATE(x,y)\n\n返回数值 x 保留到小数点后 y 位的值（与 ROUND 最大的区别是`不会`进行四舍五入）\n\n``` mysql\nSELECT TRUNCATE(1.567,2);    --> 1.56\n```\n\n### MOD(x,y)\n\n返回 x 除以 y 以后的余数　\n\n``` mysql\nSELECT MOD(10,-3);\t--> 1\n```\n\n等价于\n\n``` mysql\nSELECT 10%-3;\t--> 1\n```\n\n余数的符号取决于被除数的符号\n\n``` mysql\nSELECT MOD(-10,3);\t--> -1\n```\n\n``` mysql\nSELECT MOD(-10,-3);\t--> -1\n```\n\n\n\n## 日期函数\n\n### NOW()\n\n返回当前系统时间(注：日期+时间)\n\n``` mysql\nSELECT NOW();\t--> 2019-10-05 09:56:57\n```\n\n### CURDATE()\n\n返回当前系统日期，不包含时间\n\n``` mysql\nSELECT CURDATE();\t--> 2019-10-05\n```\n\n### CURTIME()\n\n``` mysql\nSELECT CURTIME();\t-->09:56:57\n```\n\n### YEAR(d)\n\n返回年份\n\n``` mysql\nSELECT YEAR(NOW());\t-->2019\n```\n\n``` mysql\nSELECT YEAR('1998-1-1');\t-->1998\n```\n\n``` mysql\nSELECT  YEAR(hiredate) 入职时间 FROM employees;\n```\n\n### MONTH(d)\n\n返回日期d中的月份值，1 到 12\n\n``` mysql\nSELECT MONTH(NOW());\t--> 10\n```\n\n### MONTHNAME(d)\n\n 返回日期当中的月份名称，如 November\n\n``` mysql\nSELECT MONTHNAME(NOW());\t--> October\n```\n\n### STR_TO_DATE(s, f)\n\n将字符通过指定的格式转换成日期\n\n``` mysql\nSELECT STR_TO_DATE('1998-3-2','%Y-%c-%d') AS out_put;\t--> 1998-03-02\n```\n\n查询入职日期为1992-4-3的员工信息\n\n``` mysql\nSELECT * FROM employees WHERE hiredate = '1992-4-3';\n\n# 或者\n\nSELECT * FROM employees WHERE hiredate = STR_TO_DATE('4-3 1992','%c-%d %Y');\n```\n\n### DATE_FORMAT(d,f)\n\n将日期通过指定的格式转换成字符\n\n``` mysql\nSELECT DATE_FORMAT(NOW(),'%Y年%m月%d日') AS out_put;\t--> 2019年10月05日\n```\n\n查询有奖金的员工名和入职日期(xx月/xx日 xx年)\n\n``` mysql\nSELECT last_name,DATE_FORMAT(hiredate,'%m月/%d日 %y年') 入职日期\nFROM employees\nWHERE commission_pct IS NOT NULL;\n```\n\n## 其他函数\n\n### VERSION()\n\n返回数据库的版本号\n\n``` mysql\nSELECT VERSION();\n```\n\n### DATABASE()\n\n 返回当前数据库名\n\n``` mysql\nSELECT DATABASE();\n```\n\n### USER()\n\n返回当前用户\n\n``` mysql\nSELECT USER();\n```\n\n## 流程控制函数\n\n### IF(expr,v1,v2)\n\n如果表达式 expr 成立，返回结果 v1；否则，返回结果 v2。\n\n``` mysql\nSELECT IF(1 > 0,'正确','错误');\t--> 正确\n```\n\n``` mysql\nSELECT\n\tlast_name,\n\tcommission_pct,\nIF\n\t( commission_pct IS NULL, '没奖金，呵呵', '有奖金，嘻嘻' ) 备注 \nFROM\n\temployees;\n```\n\n### CASE\n\n```\nCASE expression\n    WHEN condition1 THEN result1\n    WHEN condition2 THEN result2\n   ...\n    WHEN conditionN THEN resultN\n    ELSE result\nEND\n```\n\nCASE 表示函数开始，END 表示函数结束。如果 condition1 成立，则返回 result1, 如果 condition2 成立，则返回 result2，当全部不成立则返回 result，而当有一个成立之后，后面的就不执行了。\n\n```\ncase 要判断的字段或表达式\nwhen 常量1 then 要显示的值1或语句1;\nwhen 常量2 then 要显示的值2或语句2;\n...\nelse 要显示的值n或语句n;\nend\n```\n\n``` mysql\nSELECT CASE \n　　WHEN 1 > 0\n　　THEN '1 > 0'\n　　WHEN 2 > 0\n　　THEN '2 > 0'\n　　ELSE '3 > 0'\n　　END\n　　\n--> 1 > 0\n```\n\n查询员工的工资，要求\n\n1. 部门号=30，显示的工资为1.1倍\n2. 部门号=40，显示的工资为1.2倍\n3. 部门号=50，显示的工资为1.3倍\n4. 其他部门，显示的工资为原工资\n\n``` mysql\nSELECT salary 原始工资,department_id,\nCASE department_id\nWHEN 30 THEN salary*1.1\nWHEN 40 THEN salary*1.2\nWHEN 50 THEN salary*1.3\nELSE salary\nEND AS 新工资\nFROM employees;\n```\n\n查询员工的工资的情况\n\n1. 如果工资>20000,显示A级别\n2. 如果工资>15000,显示B级别\n3. 如果工资>10000，显示C级别\n4. 否则，显示D级别\n\n``` mysql\nSELECT salary,\nCASE \nWHEN salary>20000 THEN 'A'\nWHEN salary>15000 THEN 'B'\nWHEN salary>10000 THEN 'C'\nELSE 'D'\nEND AS 工资级别\nFROM employees;\n\n```\n\n","tags":["mysql"],"categories":["mysql"]},{"title":"mysql排序查询","url":"/2020/05/23/mysql/sortquery/","content":"\n# 排序查询\n\nORDER BY\n\n- 使用 ORDER BY 子句排序\n  - ASC（ascend）: 升序\n  - DESC（descend）: 降序\n\n## 语法\n\n``` mysql\nselect 查询列表\n\nfrom 表名\n\n【where  筛选条件】\n\norder by 排序的字段或表达式;\n\n```\n\n## 特点\n\n1. asc代表的是升序，可以省略\n2. order by子句可以支持 单个字段、别名、表达式、函数、多个字段\n3. order by子句在查询语句的最后面，除了limit子句\n\n## 案例\n\n### 单个字段排序\n\n1. 查询员工表按薪水降序\n\n   ```\n   SELECT * FROM employees ORDER BY salary DESC;\n   ```\n\n2. 查询部门编号>=90的员工信息，并按员工编号降序\n\n   ``` mysql\n   SELECT *\n   FROM employees\n   WHERE department_id>=90\n   ORDER BY employee_id DESC;\n   ```\n\n### 按表达式排序\n\n1. 查询员工信息 按年薪降序\n\n   ```mysql\n   SELECT *,salary*12*(1+IFNULL(commission_pct,0))\n   FROM employees\n   ORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC;\n   ```\n\n   \n\n### 按别名排序\n\n1. 查询员工信息 按年薪升序\n\n   ``` mysql\n   SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪\n   FROM employees\n   ORDER BY 年薪 ASC;\n   ```\n\n### 按函数排序\n\n1. 查询员工名，并且按名字的长度降序\n\n   ``` mysql\n   SELECT LENGTH(last_name),last_name \n   FROM employees\n   ORDER BY LENGTH(last_name) DESC;\n   ```\n\n### 多个字段排序\n\n1. 查询员工信息，要求先按工资降序，再按employee_id升序\n\n   ``` mysql\n   SELECT *\n   FROM employees\n   ORDER BY salary DESC,employee_id ASC;\n   ```\n\n   \n\n\n\n","tags":["mysql"],"categories":["mysql"]},{"title":"mysql事物","url":"/2020/05/23/mysql/transaction/","content":"\n# MySQL事物\n\nTCL：`Transaction Control Language` 事务控制语言\n\n> 事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个MySQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事物开始以前的状态；如果单元中的所有SQL语句均执行成功，则事物被顺利执行。\n\n!> 一个或一组sql语句组成一个执行单元，这个执行单元要么**全部执行**，要么**全部不执行**。\n\n- 概念：在mysql中的数据用各种不同的技术存储在文件（或内存）中。\n- 通过show engines；来查看mysql支持的存储引擎。\n- 在mysql中用的最多的存储引擎有：innodb，myisam ,memory 等。其中`innodb`支持事务，而myisam、memory等不支持\n\n## 转账案例\n\n张三丰转给郭襄500元\n\n```\n# 张三丰  1000\n# 郭襄\t1000\n\nupdate 表 set 张三丰的余额=张三丰的余额-500 where name='张三丰'\n\n#　中间发生意外，张三丰的余额少了500，而郭襄的余额并没有增加\n\nupdate 表 set 郭襄的余额=郭襄的余额+500 where name='郭襄'\n```\n\n\n\n## 事务的特性(ACID)\n\n1. **原子性**（Atomicity）\n\n   原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。\n\n2. **一致性**（Consistency）\n\n   事务必须使数据库从一个一致性状态变换到另外一个一致性状态。\n\n3. **隔离性**（Isolation）\n\n   事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。\n\n4. **持久性**（Durability）\n\n   持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响\n\n## 事务的创建\n\n### 隐式事务\n\n事务没有明显的开启和结束的标记，比如insert、update、delete语句\n\n``` mysql\n# 执行完表中id列为1的那一行数据就直接被删除了\ndelete from 表 where id =1;\n```\n\n### 显式事务\n\n事务具有明显的开启和结束的标记\n\n!> 前提：必须先设置自动提交功能为禁用 `set autocommit=0;`\n\n\n\n``` mysql\n# 查看自动提交是否开启\nSHOW VARIABLES LIKE 'autocommit';\n\n# 查看数据库引擎\nSHOW ENGINES;\n```\n\n\n\n### 开启事物步骤\n\n1. 开启事务\n\n   ``` mysql\n   # 关闭自动提交\n   set autocommit=0;\n   \n   #　开启事物（可选）\n   start transaction;\n   ```\n\n   \n\n2. 编写事务中的sql语句(select insert update delete)\n\n3. 可选：`savepoint 节点名`;设置回滚点\n\n4. 结束事务\n\n   ``` mysql\n   commit;提交事务\n   # 或者\n   rollback;回滚事务\n   # 或者\n   rollback to 回滚点名;回滚到指定的地方\n   ```\n\n   \n\n## 并发事务\n\n1. 事务的并发问题是如何发生的？\n\n   多个事务 同时 操作 同一个数据库的相同数据时\n\n2. 并发问题都有哪些？\n\n   **<span style='color: red'>脏读: </span>**对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段. 之后, 若 T2 回滚, T1读取的内容就是临时且无效的\n\n   **<span style='color: red'>不可重复读: </span>**对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段. \n   之后, T1再次读取同一个字段, 值就不同了(在一个事物中不管读多少次，读取的数据应该都一样)\n\n   **<span style='color: red'>幻读: </span>**对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行\n\n3. 如何解决并发问题\n\n   通过设置隔离级别来解决并发问题\n\n## 事物隔离级别\n\n√：已解决\n\n| 隔离级别                  | 脏读 | 不可重复读 | 幻读 |\n| ------------------------- | :--: | :--------: | :--: |\n| read uncommitted:读未提交 |  ×   |     ×      |  ×   |\n| read committed：读已提交  |  √   |     ×      |  ×   |\n| repeatable read：可重复读 |  √   |     √      |  ×   |\n| serializable：串行化      |  √   |     √      |  √   |\n\n`mysql`中默认 第三个隔离级别 `repeatable read`\n\n`oracle`中默认第二个隔离级别 `read committed`\n\n**查看隔离级别**\n\n``` mysql\nselect @@tx_isolation;\n```\n\n**设置隔离级别**\n\n``` mysql\n# 设置当前 mySQL 连接的隔离级别: \nset transaction isolation level read committed;\n\n# 设置数据库系统的全局的隔离级别:\nset global transaction isolation level read committed;\n```\n\n## 案例\n\n1. 事务的使用步骤\n\n   ``` mysql\n   # 开启事务\n   SET autocommit=0;\n   START TRANSACTION;\n   # 编写一组事务的语句\n   UPDATE account SET balance = 1000 WHERE username='张无忌';\n   UPDATE account SET balance = 1000 WHERE username='赵敏';\n   \n   # 结束事务\n   ROLLBACK;\n   # COMMIT;\n   \n   SELECT * FROM account;\n   ```\n\n2. 事务对于delete和truncate的处理的区别\n\n   ```mysql\n   SET autocommit=0;\n   START TRANSACTION;\n   \n   DELETE FROM account;\n   ROLLBACK;\n   ```\n\n   TRUNCATE 无法回滚\n\n   ``` mysql\n   SET autocommit=0;\n   START TRANSACTION;\n   \n   TRUNCATE TABLE account;\n   ROLLBACK;\n   ```\n\n3. savepoint 的使用\n\n   ``` mysql\n   SET autocommit=0;\n   START TRANSACTION;\n   DELETE FROM account WHERE id=25;\n   SAVEPOINT a;#设置保存点\n   DELETE FROM account WHERE id=28;\n   ROLLBACK TO a;#回滚到保存点\n   \n   SELECT * FROM account;\n   ```\n\n   \n\n   \n\n","tags":["mysql"],"categories":["mysql"]},{"title":"mysql-SQL练习-02","url":"/2020/05/23/mysql/practice02/","content":"\n# （学生表、教师表、课程表、成绩表）多表查询\n\n\n\n## 建表语句\n\n```sql\nCREATE TABLE student ( s_id INT, sname VARCHAR (32), sage INT, ssex VARCHAR (8) );\n\nCREATE TABLE course ( c_id INT, cname VARCHAR (32), t_id INT );\n\nCREATE TABLE sc ( s_id INT, c_id INT, score INT );\n\nCREATE TABLE teacher ( t_id INT, tname VARCHAR (16) );\n```\n\n```sql\ninsert into student select 1,N'刘一',18,N'男' union all\n select 2,N'钱二',19,N'女' union all\n select 3,N'张三',17,N'男' union all\n select 4,N'李四',18,N'女' union all\n select 5,N'王五',17,N'男' union all\n select 6,N'赵六',19,N'女' ;\n \n insert into teacher select 1,N'叶平' union all\n select 2,N'贺高' union all\n select 3,N'杨艳' union all\n select 4,N'周磊';\n \n insert into course select 1,N'语文',1 union all\n select 2,N'数学',2 union all\n select 3,N'英语',3 union all\n select 4,N'物理',4;\n \n insert into sc\n select 1,1,56 union all \n select 1,2,78 union all \n select 1,3,67 union all \n select 1,4,58 union all \n select 2,1,79 union all \n select 2,2,81 union all \n select 2,3,92 union all \n select 2,4,68 union all \n select 3,1,91 union all \n select 3,2,47 union all \n select 3,3,88 union all \n select 3,4,56 union all \n select 4,2,88 union all \n select 4,3,90 union all \n select 4,4,93 union all \n select 5,1,46 union all \n select 5,3,78 union all \n select 5,4,53 union all \n select 6,1,35 union all \n select 6,2,68 union all \n select 6,4,71;\n```\n\n## TOPIC1\n\n>  查询“1”课程比“2”课程成绩高的所有学生的学号；\n\n<details>\n    <summary>查看答案</summary>\n\n```sql\nSELECT\n\tc1.s_id \"学号\" \nFROM\n\t(SELECT s_id, score FROM sc WHERE c_id = 1) c1,\n\t(SELECT s_id, score FROM sc WHERE c_id = 2) c2 \nWHERE\n\tc1.score > c2.score \n\tAND c1.s_id = c2.s_id;\n```\n\n</details>\n\n\n\n## TOPIC2\n\n> 查询平均成绩大于60分的同学的学号和平均成绩\n\n<details>\n    <summary>查看答案</summary>\n\n```sql\nSELECT\n\ts_id \"学号\",\n\tAVG( score ) avg \nFROM\n\tsc \nGROUP BY\n\ts_id \nHAVING\n\tavg > 60\n```\n\n</details>\n\n\n\n## TOPIC3\n\n> 查询所有同学的学号、姓名、选课数、总成绩\n\n<details>\n    <summary>查看答案</summary>\n\n```sql\nSELECT\n\ts.s_id \"学号\",\n\ts.sname \"姓名\",\n\tCOUNT(*) \"选课数\",\n\tSUM(sc.score) \"总成绩\" \nFROM\n\tstudent s\n\tLEFT JOIN sc ON s.s_id = sc.s_id \nGROUP BY\n\tsc.s_id;\n```\n\n</details>\n\n\n\n## TOPIC4\n\n> 查询姓“李”的老师的个数；\n\n<details>\n    <summary>查看答案</summary>\n\n```sql\nSELECT\n\tCOUNT(*) \nFROM\n\tteacher \nWHERE\n\ttname LIKE '李%'\n```\n\n</details>\n\n\n\n## TOPIC5\n\n> 查询没学过“叶平”老师课的同学的学号、姓名； \n\n<details>\n    <summary>查看答案</summary>\n\n```sql\nSELECT DISTINCT\n\ts.s_id,\n\ts.sname \nFROM\n\tstudent s \nWHERE\n\ts.s_id NOT IN (\n\tSELECT\n\t\tsc.s_id \n\tFROM\n\t\tsc\n\t\tINNER JOIN course c ON sc.c_id = c.c_id\n\t\tLEFT JOIN teacher t ON c.t_id = t.t_id \nWHERE\n\tt.tname = '叶平')\n```\n\n</details>\n\n\n\n## TOPIC6\n\n> 查询学过“1”并且也学过编号“2”课程的同学的学号、姓名；\n\n<details>\n    <summary>查看答案</summary>\n\n```sql\nSELECT\n\ts.s_id \"学号\",\n\ts.sname \"姓名\" \nFROM\n\tstudent s\n\tINNER JOIN sc ON s.s_id = sc.s_id \nWHERE\n\tsc.c_id = 1 \n\tOR sc.c_id = 2 \nGROUP BY\n\tsc.s_id \nHAVING\n\tCOUNT(*)>1\n```\n\n```sql\nSELECT\n\ts.s_id \"学号\",\n\ts.sname \"姓名\" \nFROM\n\tstudent s\n\tINNER JOIN sc ON s.s_id = sc.s_id \nWHERE\n\tsc.c_id = 1 \n\tAND EXISTS ( SELECT * FROM sc sc2 WHERE sc2.s_id = sc.s_id AND sc2.c_id = 2 )\n```\n\n</details>\n\n\n\n## TOPIC7\n\n> 查询课程编号“2”的成绩比课程编号“1”课程低的所有同学的学号、姓名；\n\n<details>\n    <summary>查看答案</summary>\n\n```sql\nSELECT\n\ts.s_id,\n\ts.sname \nFROM\n\tsc sc1,\n\tsc sc2,\n\tstudent s \nWHERE\n\tsc1.c_id = 1 \n\tAND sc2.c_id = 2 \n\tAND sc1.s_id = sc2.s_id \n\tAND sc2.score < sc1.score \n\tAND sc2.s_id = s.s_id\n```\n\n```sql\nSELECT\n\ts.s_id,\n\ts.sname \nFROM\n\tstudent s\nWHERE\n\ts_id IN (\n\tSELECT\n\t\tc1.s_id \n\tFROM\n\t\t( SELECT s_id, score FROM sc WHERE c_id = 1 ) c1,\n\t\t( SELECT s_id, score FROM sc WHERE c_id = 2 ) c2 \n\tWHERE\n\tc2.score < c1.score \n\tAND c1.s_id = c2.s_id\n)\n```\n\n</details>\n\n\n\n## TOPIC8\n\n> 查询学过“叶平”老师所教的所有课的同学的学号、姓名；\n\n<details>\n    <summary>查看答案</summary>\n\n```sql\nSELECT DISTINCT\n\ts.s_id,\n\ts.sname \nFROM\n\tstudent s \nWHERE\n\ts.s_id IN (\n\tSELECT\n\t\tsc.s_id \n\tFROM\n\t\tsc\n\t\tINNER JOIN course c ON sc.c_id = c.c_id\n\t\tLEFT JOIN teacher t ON c.t_id = t.t_id \nWHERE\n\tt.tname = '叶平')\n```\n\n</details>\n\n\n\n## TOPIC9\n\n> 查询所有课程成绩小于60分的同学的学号、姓名；\n\n<details>\n    <summary>查看答案</summary>\n\n```sql\nSELECT\n\ts.s_id,\n\ts.sname \nFROM\n\tstudent s \nWHERE\n\ts.s_id NOT IN (SELECT DISTINCT sc.s_id FROM sc WHERE score>60)\n```\n\n</details>\n\n\n\n## TOPIC10\n\n> 查询没有学全所有课的同学的学号、姓名；\n\n<details>\n    <summary>查看答案</summary>\n\n```sql\nSELECT\n\ts.s_id,\n\ts.sname \nFROM\n\tstudent s,\n\tsc \nWHERE\n\ts.s_id = sc.s_id \nGROUP BY\n\tsc.s_id \nHAVING\n\tCOUNT(*) < (SELECT COUNT(*) FROM course)\n```\n\n</details>\n\n","tags":["mysql"],"categories":["mysql"]},{"title":"mysql-SQL练习-03","url":"/2020/05/23/mysql/practice03/","content":"\n\n# 查询两张表不同的数据\n\n有两张表：一张A表和一张B表\n\n- left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 ；\n- right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录；\n- inner join(等值连接) 只返回两个表中联结字段相等的行；\n\n**表A数据：**\n\n| a_id | bookName       | price |\n| ---- | -------------- | ----- |\n| 1    | java教程       | 84    |\n| 2    | javascript教程 | 80    |\n| 3    | mysql教程      | 69    |\n| 4    | c语言          | 102   |\n\n**表B数据：**\n\n| b_id | bookName       | price |\n| ---- | -------------- | ----- |\n| 1    | java教程       | 84    |\n| 2    | javascript教程 | 80    |\n| 5    | linux教程      | 80    |\n| 6    | android教程    | 68    |\n\n```sql\nDROP TABLE IF EXISTS a;\nDROP TABLE IF EXISTS b;\n\nCREATE TABLE a(\n\ta_id INT,\n\tbookName VARCHAR(50),\n\tprice FLOAT\n);\nCREATE TABLE b(\n\ta_id INT,\n\tbookName VARCHAR(50),\n\tprice FLOAT\n);\n\nINSERT INTO a VALUES\n(1,'java教程',84),\n(2,'javascript教程',80),\n(3,'mysql教程',69),\n(4,'c语言',102);\n\nINSERT INTO b VALUES\n(1,'java教程',84),\n(2,'javascript教程',80),\n(5,'linux教程',80),\n(6,'android教程',68);\n```\n\n\n\n> 查询两张表中都有的记录（相同数据）\n>\n\n```sql\nSELECT a.* FROM a INNER JOIN b ON a.a_id = b.b_id;\n```\n\n> 查询表A中有，表B中没有的数据\n\n先使用连接查询a表的全部\n\n![1577093558538](https://cdn.static.note.zzrfdsn.cn/images/mysql/1577093558538.png)\n\n然后筛选出b中没有的数据\n\n```sql\nSELECT a.* FROM a LEFT JOIN b ON a.a_id = b.b_id WHERE b.b_id IS NULL;\n```\n\n\n\n> 查询表A中没有，表B中有的数据\n\n```sql\nSELECT b.* FROM a RIGHT JOIN b ON a.a_id = b.b_id WHERE a.a_id IS NULL;\n```\n\n\n\n> 查询表A表和B表中不相同的数据\n\n将上面两个结果连接在一起\n\n```sql\nSELECT a.* FROM a LEFT JOIN b ON a.a_id = b.b_id WHERE b.b_id IS NULL UNION SELECT b.* FROM a RIGHT JOIN b ON a.a_id = b.b_id WHERE a.a_id IS NULL;\n```\n\n","tags":["mysql"],"categories":["mysql"]},{"title":"mysql子查询","url":"/2020/05/23/mysql/subquery/","content":"\n# 子查询\n\n## 含义\n\n嵌套在其他语句内部的select语句称为子查询或内查询，\n外面的语句可以是insert、update、delete、select等，一般select作为外面语句较多\n外面如果为select语句，则此语句称为外查询或主查询\n\n## 分类\n\n### 按出现位置\n\n```\nselect后面：\n\t\t仅仅支持标量子查询\nfrom后面：\n\t\t表子查询\nwhere或having后面：\n\t\t标量子查询\n\t\t列子查询\n\t\t行子查询\nexists后面：\n\t\t标量子查询\n\t\t列子查询\n\t\t行子查询\n\t\t表子查询\n```\n\n### 按结果集的行列\n\n标量子查询（单行子查询）：结果集为一行一列\n列子查询（多行子查询）：结果集为多行一列\n行子查询：结果集为多行多列\n表子查询：结果集为多行多列\n\n## 示例\n\n### where或having后面\n\n1. 标量子查询（单行单列）\n2. 列子查询（多行单列）\n3. 行子查询（多行多列）\n\n### 特点\n\n① 子查询放在小括号内  \n② 子查询一般放在条件的右侧  \n③ 标量子查询，一般搭配着单行操作符使用  \n\n> <、>、<=、>=、=、<>\n\n④ 列子查询，一般搭配着多行操作符使用  \n\n> in、any/some、all\n\n⑤ 子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果  \n\n### 标量子查询\n\n1. 谁的工资比 Abel 高?\n\n   ① 查询Abel的工资\n\n   ``` mysql\n   SELECT salary\n   FROM employees\n   WHERE last_name = 'Abel'\n   ```\n\n   ②查询员工的信息，满足 salary>①结果\n\n   ``` mysql\n   SELECT *\n   FROM employees\n   WHERE salary>(\n   \n   \tSELECT salary\n   \tFROM employees\n   \tWHERE last_name = 'Abel'\n   \n   );\n   ```\n\n   \n\n2. 返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资\n\n   ① 查询141号员工的job_id\n\n   ``` mysql\n   SELECT job_id\n   FROM employees\n   WHERE employee_id = 141\n   ```\n\n   ② 查询143号员工的salary\n\n   ``` mysql\n   SELECT salary\n   FROM employees\n   WHERE employee_id = 143\n   ```\n\n   ③ 查询员工的姓名，job_id 和工资，要求job_id=①并且salary>②\n\n   ``` mysql\n   SELECT last_name,job_id,salary\n   FROM employees\n   WHERE job_id = (\n   \tSELECT job_id\n   \tFROM employees\n   \tWHERE employee_id = 141\n   ) AND salary>(\n   \tSELECT salary\n   \tFROM employees\n   \tWHERE employee_id = 143\n   \n   );\n   ```\n\n   \n\n3. 返回公司工资最少的员工的last_name,job_id和salary\n\n   ① 查询公司的 最低工资\n\n   ``` mysql\n   SELECT MIN(salary)\n   FROM employees\n   ```\n\n   ② 查询last_name,job_id和salary，要求salary=①\n\n   ``` mysql\n   SELECT last_name,job_id,salary\n   FROM employees\n   WHERE salary=(\n   \tSELECT MIN(salary)\n   \tFROM employees\n   );\n   ```\n\n   \n\n4. 查询最低工资大于50号部门最低工资的部门id和其最低工资\n\n   ① 查询50号部门的最低工资\n\n   ``` mysql\n   SELECT  MIN(salary)\n   FROM employees\n   WHERE department_id = 50\n   ```\n\n   ② 查询每个部门的最低工资\n\n   ``` mysql\n   SELECT MIN(salary),department_id\n   FROM employees\n   GROUP BY department_id\n   ```\n\n   ③ 在②基础上筛选，满足min(salary)>①\n\n   ``` mysql\n   SELECT MIN(salary),department_id\n   FROM employees\n   GROUP BY department_id\n   HAVING MIN(salary)>(\n   \tSELECT  MIN(salary)\n   \tFROM employees\n   \tWHERE department_id = 50\n   );\n   ```\n\n   \n\n5. <span style=\"color:red\">非法使用标量子查询</span>\n\n   <del>\n\n   ``` mysql\n   SELECT MIN(salary),department_id\n   FROM employees\n   GROUP BY department_id\n   HAVING MIN(salary)>(\n   \tSELECT  salary\n   \tFROM employees\n   \tWHERE department_id = 250\n   );\n   ```\n\n   </del>\n\n   这里250号部门的员工可能不止一个人，查询的是多行单列，就是列子查询了\n\n### 列子查询\n\n|  操作符   |            含义            |\n| :-------: | :------------------------: |\n| IN/NOT IN |    等于列表中的任意一个    |\n| ANY\\|SOME | 和子查询返回的某一个值比较 |\n|    ALL    |  和子查询返回的所有值比较  |\n\n\n\n1. 返回location_id是1400或1700的部门中的所有员工姓名\n\n   ①查询location_id是1400或1700的`部门编号`\n\n   ``` mysql\n   SELECT DISTINCT department_id\n   FROM departments\n   WHERE location_id IN(1400,1700)\n   ```\n\n   ② 查询员工姓名，要求部门号是①列表中的某一个\n\n   ``` mysql\n   SELECT last_name\n   FROM employees\n   WHERE department_id IN(\n   \tSELECT DISTINCT department_id\n   \tFROM departments\n   \tWHERE location_id IN(1400,1700)\n   );\n   ```\n\n   \n\n2. 返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary\n\n   ① 查询job_id为‘IT_PROG’部门任一工资\n\n   ``` mysql\n   SELECT DISTINCT salary\n   FROM employees\n   WHERE job_id = 'IT_PROG';\n   ```\n\n   ② 查询员工号、姓名、job_id 以及salary，salary<(①)的任意一个\n\n   ``` mysql\n   SELECT last_name,employee_id,job_id,salary\n   FROM employees\n   WHERE salary<ANY(\n   \tSELECT DISTINCT salary\n   \tFROM employees\n   \tWHERE job_id = 'IT_PROG'\n   \n   ) AND job_id<>'IT_PROG';\n   ```\n\n   或者(小于最大值，就肯定满足任意一个)\n\n   ``` mysql\n   SELECT last_name,employee_id,job_id,salary\n   FROM employees\n   WHERE salary<(\n   \tSELECT MAX(salary)\n   \tFROM employees\n   \tWHERE job_id = 'IT_PROG'\n   \n   ) AND job_id<>'IT_PROG';\n   ```\n\n   \n\n3. 返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工   的员工号、姓名、job_id 以及salary\n\n   ``` mysql\n   SELECT last_name,employee_id,job_id,salary\n   FROM employees\n   WHERE salary<ALL(\n   \tSELECT DISTINCT salary\n   \tFROM employees\n   \tWHERE job_id = 'IT_PROG'\n   \n   ) AND job_id<>'IT_PROG';\n   ```\n\n   或者（小于最小的）\n\n   ``` mysql\n   SELECT last_name,employee_id,job_id,salary\n   FROM employees\n   WHERE salary<(\n   \tSELECT MIN( salary)\n   \tFROM employees\n   \tWHERE job_id = 'IT_PROG'\n   \n   ) AND job_id<>'IT_PROG';\n   ```\n\n   \n\n### 行子查询\n\n1. 查询员工编号最小并且工资最高的员工信息\n\n   ``` mysql\n   SELECT * \n   FROM employees\n   WHERE (employee_id,salary)=(\n   \tSELECT MIN(employee_id),MAX(salary)\n   \tFROM employees\n   );\n   ```\n\n   或者\n\n   ``` mysql\n   SELECT *\n   FROM employees\n   WHERE employee_id=(\n   \tSELECT MIN(employee_id)\n   \tFROM employees\n   )AND salary=(\n   \tSELECT MAX(salary)\n   \tFROM employees\n   );\n   ```\n\n### select后面\n\n仅仅支持标量子查询\n\n1. 查询每个部门的员工个数\n\n   ``` mysql\n   SELECT d.*,(\n   \tSELECT COUNT(*)\n   \tFROM employees e\n   \tWHERE e.department_id = d.`department_id`\n    ) 个数\n    FROM departments d;\n   ```\n\n   或者(使用外连接)\n\n   ``` mysql\n   SELECT\n   \td.*,\n   \tcount( e.employee_id ) 个数 \n   FROM\n   \temployees e\n   \tRIGHT JOIN departments d ON e.department_id = d.department_id \n   GROUP BY\n   \td.department_id;\n   ```\n\n   \n\n2. 查询员工号=102的部门名\n\n   ``` mysql\n   SELECT department_id,( \n       SELECT department_name \n       FROM departments d \n       WHERE department_id = e.department_id \n   ) \n   FROM\n   \temployees e \n   WHERE\n   \te.employee_id = 102;\n   ```\n\n   或者\n\n   ``` mysql\n   \tSELECT department_name,e.department_id\n   \tFROM departments d\n   \tINNER JOIN employees e\n   \tON d.department_id=e.department_id\n   \tWHERE e.employee_id=102;\n   ```\n\n   \n\n### from后面\n\n将子查询结果充当一张表，要求必须起别名\n\n1. 查询每个部门的平均工资的工资等级\n\n   ``` mysql\n   SELECT  ag_dep.*,g.`grade_level`\n   FROM (\n   \tSELECT AVG(salary) ag,department_id\n   \tFROM employees\n   \tGROUP BY department_id\n   ) ag_dep\n   INNER JOIN job_grades g\n   ON ag_dep.ag BETWEEN lowest_sal AND highest_sal;\n   ```\n\n   \n\n### exists后面（相关子查询）\n\n判断子查询是否存在结果，存在返回1，不能存在返回0，可用于筛选判断\n\n1. 查询有员工的部门名\n\n   ``` mysql\n   SELECT department_name\n   FROM departments d\n   WHERE EXISTS(\n   \tSELECT *\n   \tFROM employees e\n   \tWHERE d.`department_id`=e.`department_id`\n   );\n   ```\n\n2. 查询没有女朋友的男神信息\n\n   ``` mysql\n   SELECT bo.*\n   FROM boys bo\n   WHERE NOT EXISTS(\n   \tSELECT boyfriend_id\n   \tFROM beauty b\n   \tWHERE bo.`id`=b.`boyfriend_id`\n   );\n   \n   ```\n\n   ``` mysql\n   SELECT bo.*\n   FROM boys bo\n   WHERE bo.id NOT IN(\n   \tSELECT boyfriend_id\n   \tFROM beauty\n   )\n   ```\n\n   \n\n能用exists的地方就都可以用In替代","tags":["mysql"],"categories":["mysql"]},{"title":"mysql变量","url":"/2020/05/23/mysql/variable/","content":"\n# 变量\n\n## 系统变量\n\n系统变量：\n\n- 全局变量\n- 会话变量\n\n说明：变量由系统定义，不是用户定义，属于服务器层面\n\n注意：全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认会话级别\n\n\n\n1. 查看所有系统变量\n\n   ``` mysql\n   # 全局\n   show global variables;\n   \n   #会话\n   show【session】variables;\n   ```\n\n2. 查看满足条件的部分系统变量\n\n   ``` mysql\n   show global |【session】 variables like '%char%';\n   ```\n\n3. 查看指定的系统变量的值（`带.`）\n\n   ``` mysql\n   select @@global |【@@session】.系统变量名;\n   ```\n\n4. 为某个系统变量赋值\n\n   - 方式一 \n\n     ``` mysql\n     set global|【session】系统变量名=值;\n     ```\n\n   - 方式二（`带.`）\n\n     ``` mysql\n     set @@global|【@@session】.系统变量名=值;\n     ```\n\n     \n\n**例如：**\n\n``` mysql\n# 查看所有全局变量\nSHOW GLOBAL VARIABLES;\n# 查看满足条件的部分系统变量\nSHOW GLOBAL VARIABLES LIKE '%char%';\n# 查看指定的系统变量的值\nSELECT @@global.autocommit;\n# 为某个系统变量赋值\nSET @@global.autocommit=0;\nSET GLOBAL autocommit=0;\n```\n\n\n\n``` mysql\n# 查看所有会话变量\nSHOW SESSION VARIABLES;\n# 查看满足条件的部分会话变量\nSHOW SESSION VARIABLES LIKE '%char%';\n# 查看指定的会话变量的值\nSELECT @@autocommit;\nSELECT @@session.tx_isolation;\n# 为某个会话变量赋值\nSET @@session.tx_isolation='read-uncommitted';\nSET SESSION tx_isolation='read-committed';\n```\n\n\n\n## 自定义变量\n\n变量由用户自定义，而不是系统提供的\n\n作用域：针对于当前会话（连接）有效，作用域同于会话变量\n\n**声明并初始化**\n\n赋值操作符：`=`或`:=`\n\n``` mysql\nSET @变量名=值;\nSET @变量名:=值;\nSELECT @变量名:=值;\n```\n\n**更新变量的值**\n\n- 方式一\n\n  ``` mysql\n  SET @变量名=值;\n  SET @变量名:=值;\n  SELECT @变量名:=值;\n  ```\n\n- 方式二\n\n  ``` mysql\n  SELECT 字段 INTO @变量名\n  FROM 表;\n  ```\n\n**查看变量的值**\n\n``` mysql\nSELECT @变量名;\n```\n\n\n\n## 局部变量\n\n作用域：仅仅在定义它的begin end块中有效\n\n应在 begin end中的第一句话声明\n\n**声明**\n\n``` mysql\nDECLARE\n\t变量名 类型;\n\t...\nEND\n\n# \n\nDECLARE \n\t变量名 类型 【DEFAULT 值】;\n\t...\nEND\n```\n\n**赋值（更新变量的值）**\n\n- 方式一\n\n  ``` mysql\n  SET 局部变量名=值;\n  SET 局部变量名:=值;\n  SELECT 局部变量名:=值;\n  ```\n\n- 方式二\n\n  ``` mysql\n  SELECT 字段 INTO 具备变量名\n  FROM 表;\n  ```\n\n\n\n**查看变量的值**\n\n``` mysql\nSELECT 局部变量名;\n```\n\n\n\n## 案例\n\n1. 声明两个用户变量，求和并打印\n\n   ``` mysql\n   SET @m=1;\n   SET @n=1;\n   SET @sum=@m+@n;\n   SELECT @sum;\n   ```","tags":["mysql"],"categories":["mysql"]},{"title":"mysql联合查询","url":"/2020/05/23/mysql/unionquery/","content":"\n# 联合查询\n\n合并、联合，将多次查询结果合并成一个结果\n\n## 语法\n\n```\n查询语句1\nunion 【all】\n查询语句2\nunion 【all】\n...\n```\n\n## 意义\n\n1. 将一条比较复杂的查询语句拆分成多条语句\n2. 适用于查询多个表的时候，查询的列基本是一致\n\n## 特点\n\n1. 要求多条查询语句的查询列数是一致的！\n2. 要求多条查询语句的查询的每一列的类型和顺序最好一致\n3. union关键字默认去重，如果使用union all 可以包含重复项\n\n## 案例\n\n1. 查询部门编号>90或邮箱包含a的员工信息\n\n   ``` mysql\n   SELECT * FROM employees WHERE email LIKE '%a%' OR department_id>90;\n   ```\n\n   ``` mysql\n   SELECT * FROM employees  WHERE email LIKE '%a%'\n   UNION\n   SELECT * FROM employees  WHERE department_id>90;\n   ```","tags":["mysql"],"categories":["mysql"]},{"title":"Eureka详解","url":"/2020/05/23/springCloud/eureka/","content":"\n\n# Eureka高可用和详解\n\n## 基础架构\n\nEureka架构中的三个核心角色：\n\n- 服务注册中心\n\n  Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的`springcloud-eureka-server`。\n\n- 服务提供者\n\n  提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。上节案例中就是我们实现的`springcloud-eureka-service-provider`。\n\n- 服务消费者\n\n  消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。上节案例中就是我们实现的`springcloud-eureka-service-consumer`。\n\n\n\n## 高可用的Eureka Server\n\nEureka Server即服务的注册中心，在上节的案例中，我们只有一个EurekaServer，事实上EurekaServer也可以是一个集群，形成高可用的Eureka中心。\n\n> 服务同步\n\n多个Eureka Server之间也会互相注册为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现**数据同步**。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息。\n\n> 动手搭建高可用的EurekaServer\n\n我们假设要运行两个EurekaServer的集群，端口分别为：10001和10002。只需要把`springcloud-eureka-server`启动两次即可。\n\n\n\n```yaml\nserver:\n  port: 10001\nspring:\n  application:\n    name: eureka-server\neureka:\n  client:\n    service-url:\n      defaultZone: http://127.0.0.1:10002/eureka\n```\n\n\n\n所谓的高可用注册中心，其实就是把EurekaServer自己也作为一个服务进行注册，这样多个EurekaServer之间就能互相发现对方，从而形成集群。因此我们做了以下修改：\n\n- 把service-url的值改成了另外一台EurekaServer的地址，而不是自己\n\n启动报错，很正常。因为10002服务没有启动：\n\n![1574732128406](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574732128406.png)\n\n再次修改springcloud-eureka-server的配置(将10002注册给10001)：\n\n```yaml\nserver:\n  port: 10002\nspring:\n  application:\n    name: eureka-server\neureka:\n  client:\n    service-url:\n      defaultZone: http://127.0.0.1:10001/eureka\n\n```\n\n将应用复制一份，换个名字，点击应用然后启动，如果没有services这个窗口，参考这里：[RunDashboard如何显示出来](<https://jingyan.baidu.com/article/ce4366495a1df73773afd3d3.html>)，也可以使用[第二种方式](#second-way)\n\n![1574732908137](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574732908137.png)\n\n![1574732983985](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574732983985.png)\n\n![1574733028306](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574733028306.png)\n\n![1574733235604](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574733235604.png)\n\n<details id=\"second-way\">\n\n​    <summary>第二种方式</summary>\n\n![1574733492084](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574733492084.png)\n\n![1574733572547](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574733572547.png)\n\n![1574733661113](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574733661113.png)\n\n</details>\n\n启动后访问集群，测试\n\n分别访问：<http://localhost:10001/>和<http://localhost:10002/>\n\n![1574734126761](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574734126761.png)\n\n> 多个如何注册？\n\n例如有3个，地址分别为：\n\n1. 127.0.0.1:10001\n2. 127.0.0.1:10002\n3. 127.0.0.1:10003\n\n注册时就把1注册给2,2注册给3,3注册给1\n\n\n\n## 服务提供者\n\n启动`springcloud-eureka-service-provider`\n\n服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。\n\n> 服务注册\n\n服务提供者在启动时，会检测配置属性中的：`eureka.client.register-with-eureka=true`参数是否正确，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka Server会把这些信息保存到一个双层Map结构中。\n\n- 第一层Map的Key就是服务id，一般是配置中的`spring.application.name`属性\n- 第二层Map的key是服务的实例id。一般host+ serviceId + port，例如：`locahost:service-provider:8081`\n- 值则是服务的实例对象，也就是说一个服务，可以同时启动多个不同实例，形成集群。\n\n> 服务续约\n\n在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）；\n\n有两个重要参数可以修改服务续约的行为：\n\n```yaml\neureka:\n  instance:\n    lease-renewal-interval-in-seconds: 30\n    lease-expiration-duration-in-seconds: 90\n```\n\n- `lease-renewal-interval-in-seconds`：服务续约(renew)的间隔，默认为30秒\n- `lease-expiration-duration-in-seconds`：服务失效时间，默认值90秒\n\n也就是说，默认情况下每隔30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。\n\n但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。\n\n```yaml\neureka:\n  instance:\n    lease-expiration-duration-in-seconds: 10 # 10秒即过期\n    lease-renewal-interval-in-seconds: 5 # 5秒一次心跳\n```\n\n\n\n## 服务消费者\n\n启动`springcloud-eureka-service-customer`\n\n> 获取服务列表\n\n当服务消费者启动时，会检测`eureka.client.fetch-registry=true`参数的值，如果为true，则会拉取Eureka Server服务的列表只读备份，然后缓存在本地(默认为true)。并且`每隔30秒`会重新获取并更新数据。我们可以通过下面的参数来修改：\n\n```yaml\neureka:\n  client:\n    registry-fetch-interval-seconds: 5\n```\n\n生产环境中，我们不需要修改这个值。\n\n但是为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点。\n\n\n\n## 失效剔除和自我保护\n\n> 服务下线\n\n当服务进行正常关闭操作时，它会触发一个服务下线的REST请求给Eureka Server，告诉服务注册中心：“我要下线了”。服务中心接受到请求之后，将该服务置为下线状态。\n\n> 失效剔除\n\n有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应的服务）进行剔除。\n\n可以通过`eureka.server.eviction-interval-timer-in-ms`参数对其进行修改，单位是毫秒，生产环境不要修改。\n\n这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如：10秒\n\n```yaml\neureka:\n  client:\n    service-url:\n      defaultZone: http://127.0.0.1:10001/eureka\n  server:\n    eviction-interval-timer-in-ms: 10000\n```\n\n\n\n> 自我保护\n\n我们关停一个服务，就会在Eureka面板看到一条警告：\n\n![1525618396076](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1525618396076.png)\n\n这是触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。\n\n但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式：（springcloud-eureka-server）\n\n```yaml\neureka:\n  server:\n    enable-self-preservation: false # 关闭自我保护模式（缺省为打开）\n    eviction-interval-timer-in-ms: 1000 # 扫描失效服务的间隔时间（缺省为60*1000ms）\n```","tags":["springcloud"],"categories":["springcloud"]},{"title":"Feign远程服务调用","url":"/2020/05/23/springCloud/feign/","content":"\n\n# Feign\n\n在前面的学习中，我们使用了Ribbon的负载均衡功能，大大简化了远程调用时的代码：\n\n```java\n    @Autowired\n    private RestTemplate restTemplate;\n\n    @GetMapping(\"/{id}\")\n    @HystrixCommand\n    public String getUserById(@PathVariable Long id) {\n        if (id == 1) {\n            throw new RuntimeException(\"忙碌中......\");\n        }\n        //直接通过服务名称调用\n        String baseUrl = \"http://service-provider/user/\";\n        return restTemplate.getForObject(baseUrl + id, String.class);\n    }\n```\n\n如果就学到这里，你可能以后需要编写类似的大量重复代码，格式基本相同，无非参数不一样。有没有更优雅的方式，来对这些代码再次优化呢？\n\n这就是我们接下来要学的Feign的功能了。\n\n\n\n## 简介\n\n![1528855057359](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1528855057359.png)\n\n为什么叫伪装？\n\nFeign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。\n\n![1525652009416](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1525652009416.png)\n\n\n\n## 快速入门\n\n改造`springcloud-eureka-service-consumer`工程\n\n### 导入依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n```\n\n\n\n### 开启Feign功能\n\n我们在启动类上，**添加`@EnableFeignClients`注解**，开启Feign功能，也不需要我们向容器中注入`Resttemplate`了\n\n```java\n@SpringCloudApplication\n@EnableFeignClients\npublic class SpringcloudEurekaServiceConsumerApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringcloudEurekaServiceConsumerApplication.class, args);\n    }\n\n//    @Bean\n//    @LoadBalanced\n//    public RestTemplate restTemplate() {\n//        return new RestTemplate();\n//    }\n\n}\n\n```\n\n> feign已经自动集成了Ribbon负载均衡的RestTemplate。所以，不需要我们再注册RestTemplate。\n\n\n\n### Feign的客户端\n\n添加`UserClient`接口，一般这种接口都放在client包下\n\n![1574771935226](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574771935226.png)\n\n```java\n@FeignClient(value = \"service-provider\")\n@RequestMapping(\"user\")\npublic interface UserClient {\n\n    @GetMapping(\"/{id}\")\n    TbUser getUserById(@PathVariable Long id);\n}\n```\n\n- 首先这是一个接口，Feign会通过动态代理，帮我们生成实现类。这点跟mybatis的mapper很像\n- `@FeignClient`，声明这是一个Feign客户端，类似`@Mapper`注解。同时通过`value`属性指定服务名称\n- 接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果\n- 接口的方法名随意，但是注解上的请求路径，方法参数要和服务方的相同，返回值可以换成String\n\n\n\n改造原来的调用逻辑，调用UserClient接口：\n\n```java\n@RestController\n@RequestMapping(\"user\")\npublic class UserController {\n\n    @Autowired\n    private UserClient userClient;\n\n    @GetMapping(\"/{id}\")\n    public TbUser getUserById(@PathVariable Long id) {\n        return userClient.getUserById(id);\n    }\n}\n```\n\n重启`springcloud-eureka-service-consumer`\n\n![1574772714973](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574772714973.png)\n\n!> 这是由于我们在UserClient类上使用了@RequestMapping注解，这是一个坑需要留意\n\n修改UserClient\n\n```java\n@FeignClient(value = \"service-provider\")\npublic interface UserClient {\n\n    @GetMapping(\"/user/{id}\")\n    TbUser getUserById(@PathVariable Long id);\n}\n```\n\n\n\n### 负载均衡\n\nFeign中本身已经集成了Ribbon依赖和自动配置：\n\n因此我们不需要额外引入依赖，也不需要再注册`RestTemplate`对象。\n\n> Feign、Hystrix、Eureka都集成了Ribbon，版本有springcloud管理，所以不用我们去管理依赖\n\n\n\n### Hystrix支持\n\nFeign默认也有对Hystrix的集成：\n\n只不过，默认情况下是关闭的。我们需要通过下面的参数来开启：(在配置添加如下内容)\n\n```yaml\nfeign:\n  hystrix:\n    enabled: true # 开启Feign的熔断功能\n```\n\n但是，Feign中的Fallback配置不像hystrix中那样简单了。\n\n首先，我们要定义一个类去实现刚才编写的`UserClient`接口，作为fallback的处理类。并将该类`添加到容器中`\n\n```java\npackage cn.clboy.springcloud.eureka.service.consumer.client;\n\nimport cn.clboy.springcloud.eureka.service.consumer.pojo.TbUser;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class UserClientFallback implements UserClient {\n\n    @Override\n    public TbUser getUserById(Long id) {\n        TbUser tbUser=new TbUser();\n        tbUser.setUsername(\"服务器繁忙，请稍后再试！\");\n        return tbUser;\n    }\n}\n```\n\n\n\n然后在`UserClient`接口的`@FeignClient`注解中，指定刚才编写的实现类\n\n```java\n@FeignClient(value = \"service-provider\", fallback = UserClientFallback.class)\npublic interface UserClient {\n\n    @GetMapping(\"/user/{id}\")\n    TbUser getUserById(@PathVariable Long id);\n}\n```\n\n重启访问测试：<http://localhost:8083/user/1>\n\n将服务提供方关闭，再访问测试\n\n\n\n## 请求压缩\n\nSpring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可开启请求与响应的压缩功能：\n\n```yaml\nfeign:\n  compression:\n    request:\n      enabled: true # 开启请求压缩\n    response:\n      enabled: true # 开启响应压缩\n```\n\n同时，我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置：\n\n```yaml\nfeign:\n  compression:\n    request:\n      enabled: true # 开启请求压缩\n      mime-types: text/html,application/xml,application/json # 设置压缩的数据类型\n      min-request-size: 2048 # 设置触发压缩的大小下限\n```\n\n注：上面的数据类型、压缩大小下限均为默认值。\n\n\n\n## 日志级别\n\nspringboot可以通过`logging.level.xx=debug`来设置日志级别。然而这个对Fegin客户端而言不会产生效果。因为`@FeignClient`注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。我们需要额外指定这个日志的级别才可以。\n\n1. 设置cn.clboy.springcloud.eureka.service.consumer包下的日志级别都为debug\n\n   ```yaml\n   logging:\n     level:\n       cn.clboy.springcloud.eureka.service.consumer: debug\n   ```\n\n2. 编写配置类，定义日志级别\n\n   ```java\n   @Configuration\n   public class FeignLogConfiguration {\n   \n       @Bean\n       Logger.Level feignLoggerLevel(){\n           return Logger.Level.FULL;\n       }\n   }\n   ```\n\n   这里指定的Level级别是FULL，Feign支持4种级别：\n\n   ![1528863525224](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1528863525224.png)\n\n   - `NONE`：不记录任何日志信息，这是默认值。\n   - `BASIC`：仅记录请求的方法，URL以及响应状态码和执行时间\n   - `HEADERS`：在BASIC的基础上，额外记录了请求和响应的头信息\n   - `FULL`：记录所有请求和响应的明细，包括头信息、请求体、元数据。\n\n\n\n3. 在FeignClient中指定配置类：\n\n   ```java\n   @FeignClient(\n       value = \"service-provider\", \n       fallback = UserClientFallback.class,\n       configuration = FeignLogConfiguration.class)\n   public interface UserClient {\n   \n       @GetMapping(\"/user/{id}\")\n       TbUser getUserById(@PathVariable Long id);\n   }\n   ```\n\n   \n\n4. 重启项目，即可看到每次访问的日志：\n\n   ![1574775914183](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574775914183.png)\n\n   \n\n\n\n","tags":["springcloud"],"categories":["springcloud"]},{"title":"mysql视图","url":"/2020/05/23/mysql/view/","content":"\n# MySQL视图\n\n> MySQL从5.0.1版本开始提供视图功能。一种虚拟存在的表，行和列的数据来自定义视图的查询中 使用的表，并且是在使用视图时动态生成的，只保存了sql逻辑，不保存查询结果\n\n## 应用场景\n\n- 多个地方用到同样的查询结果\n- 该查询结果使用的sql语句较复杂\n\n## 优点\n\n1. 简化sql语句\n\n2. 提高了sql的重用性\n3. 保护基表的数据，提高了安全性\n\n## 创建视图\n\n``` mysql\ncreate view 视图名\nas\n查询语句;\n```\n\n1. 创建视图emp_v1,要求查询电话号码以‘011’开头的员工姓名和工资、邮箱\n\n   ``` mysql\n   CREATE VIEW emp_v1 AS SELECT\n   \tlast_name,\n   \tsalary,\n   \temail \n   FROM\n   \temployees \n   WHERE\n   \tphone_number LIKE '011%';\n   ```\n\n2. 创建视图emp_v2，要求查询部门的最高工资高于12000的部门信息\n\n   ``` mysql\n   # 创建视图，查询每个部门的最高工资,筛选出高于12000的\n   DROP VIEW emp_v2;\n   CREATE VIEW emp_v2 AS SELECT\n   department_id,\n   MAX( salary ) max_salary \n   FROM\n   \temployees \n   GROUP BY\n   \tdepartment_id \n   HAVING\n   \tmax_salary > 12000;\n   \t\n   # 根据创建的视图连接departments表查询部门信息\n   SELECT\n   \td.*,\n   \tev2.max_salary \n   FROM\n   \tdepartments d\n   \tJOIN emp_v2 ev2 \n   \tON d.department_id = ev2.department_id;\n   ```\n\n3. 查询姓名中包含a字符的员工名、部门名和工种信息\n\n   ```\n   # 查询员工名、部门名和工种信息\n   CREATE VIEW emp_v3 AS SELECT\n   e.last_name,\n   d.department_name,\n   j.job_title \n   FROM\n   \temployees e\n   \tLEFT JOIN departments d ON e.department_id = d.department_id\n   \tLEFT JOIN jobs j ON e.job_id = j.job_id;\n   \n   # 筛选出姓名中包含a字符的员工\n   SELECT * FROM emp_v3 WHERE last_name LIKE '%a%';\n   ```\n\n4. 查询各部门的平均工资级别\n\n   ``` mysql\n   # 查询各部门的平均工资\n   CREATE VIEW emp_v4 AS SELECT\n   AVG( salary ) avg_salary,\n   department_id \n   FROM\n   \temployees \n   GROUP BY\n   \tdepartment_id;\n   \t\n   # 查询各部门的平均工资级别\n   SELECT\n   \tdepartment_id,\n   \tj.grade_level \n   FROM\n   \temp_v4 ev4\n   \tLEFT JOIN job_grades j \n   \tON ev4.avg_salary BETWEEN j.lowest_sal \n   \tAND j.highest_sal\n   ```\n\n5. 查询平均工资最低的部门信息\n\n   ``` mysql\n   SELECT\n   \td.*,\n   \tev4.avg_salary \n   FROM\n   \tdepartments d\n   \tJOIN ( SELECT * FROM emp_v4 ORDER BY avg_salary LIMIT 1 ) ev4 \n   \tON d.department_id = ev4.department_id\n   ```\n\n   \n\n## 修改视图\n\n### 方式一\n\n```\ncreate or replace view  视图名\nas\n查询语句;\n```\n\n### 方式二\n\n```\nalter view 视图名\nas \n查询语句;\n```\n\n\n\n## 删除视图\n\n```\ndrop view 视图名,视图名,...\n```\n\n``` mysql\nDROP VIEW emp_v1,emp_v2,emp_v3,emp_v4;\n```\n\n\n\n## 查看视图\n\n```\nDESC 视图名;\n\nSHOW CREATE VIEW 视图名;\n```\n\n``` mysql\nCREATE VIEW emp_v1 AS SELECT\n* \nFROM\n\temployees;\n\nDESC emp_v1;\n\nSHOW CREATE VIEW emp_v1;\n```\n\n\n\n## 视图的更新\n\n视图的可更新性和视图中查询的定义有关系，以下类型的视图是不能更新的。\n\n- 包含以下关键字的sql语句：分组函数、distinct、group by\n- having、union或者union all\n- 常量视图\n- Select中包含子查询\n- join\n- from一个不能更新的视图\n- where子句的子查询引用了from子句中的表\n\n\n\n### 案例\n\n1. <details> <summary>张飞能否成功插入？</summary>不能，原表中没有annual salary那一列 </details>\n\n   ``` mysql\n   # 创建视图，查询员工的姓名，邮箱和年薪\n   \n   CREATE \n   \tOR REPLACE VIEW myv1 AS SELECT\n   \tlast_name,\n   \temail,\n   \tsalary * 12 *(1+IFNULL ( commission_pct, 0 )) \"annual salary\" \n   FROM\n   \temployees;\n   \t\n   # 插入一条数据\n   INSERT INTO myv1 VALUES('张飞','zf@qq.com',94862.00);\n   ```\n\n   \n\n2. <details> <summary>张飞能否成功插入？</summary>能，并且原表中也存在 </details>\n\n   ``` mysql\n   # 创建视图，查询员工的姓名和邮箱\n   \n   CREATE \n   \tOR REPLACE VIEW myv1 AS SELECT\n   \tlast_name,\n   \temail\n   FROM\n   \temployees;\n   \t\n   # 插入一条数据\n   INSERT INTO myv1 VALUES('张飞','zf@qq.com');\n   ```\n\n3. <details> <summary>能否将张飞修改为张无忌？</summary>能 </details>\n\n   ``` mysql\n   UPDATE myv1 SET last_name = '张无忌' WHERE last_name='张飞';\n   ```\n\n4. <details> <summary>能否干掉张无忌？</summary>能 </details>\n\n   ``` mysql\n   DELETE FROM myv1 WHERE last_name = '张无忌';\n   ```\n\n5. <details> <summary>能否将10号部门的最高薪水改为9000？</summary>不能 ，包含group by和分组函数</details>\n\n   ``` mysql\n   #　创建视图，查询每个部门的最高工资\n   CREATE \n   \tOR REPLACE VIEW myv1 AS SELECT\n   \tMAX( salary ) m,\n   \tdepartment_id \n   FROM\n   \temployees \n   GROUP BY\n   \tdepartment_id;\n   \n   ＃ 将10号部门的最高薪水改为9000\n   UPDATE myv1 SET m=9000 WHERE department_id=10;\n   ```\n\n6. <details> <summary>能否更改？</summary>不能，常量视图 </details>\n\n   ``` mysql\n   CREATE OR REPLACE VIEW myv2\n   AS\n   SELECT 'john' NAME;\n   \n   #更新\n   UPDATE myv2 SET NAME='lucy';\n   ```\n\n7. <details> <summary>能够将最高工资列修改为100000？</summary>不能，select中包含子查询 </details>\n\n   ``` mysql\n   CREATE OR REPLACE VIEW myv3 AS \n   SELECT department_id,( SELECT MAX( salary ) FROM employees ) 最高工资 \n   FROM\n   \tdepartments;\n   \n   # 修改\n   \n   UPDATE myv3 SET 最高工资=100000;\n   ```\n\n8. <details> <summary>修改和插入能成功吗？</summary>可以更新，但是不能插入 </details>\n\n   ``` mysql\n   # 创建视图，查询员工名与部门名\n   CREATE \n   \tOR REPLACE VIEW myv4 AS SELECT\n   \tlast_name,\n   \tdepartment_name \n   FROM\n   \temployees e\n   \tJOIN departments d ON e.department_id = d.department_id;\n   \n   # 修改\n   UPDATE myv4 SET last_name  = '张飞' WHERE last_name='Whalen';\n   # 插入\n   INSERT INTO myv4 VALUES('陈真','Acc');\n   ```\n\n9. <details> <summary>能修改吗？</summary>不能，from一个不能更新的视图，myv3中select使用了子查询 </details>\n\n   ``` mysql\n   CREATE \n   \tOR REPLACE VIEW myv5 AS SELECT\n   \t* \n   FROM\n   \tmyv3;\n   \t\n   # 修改\n   UPDATE myv5 SET 最高工资=10000 WHERE department_id=60;\n   ```\n\n10. <details> <summary>能修改吗？</summary>不能，where子句的子查询引用了from子句中的表</details>\n\n    ``` mysql\n    # 查询所有的领导信息\n    CREATE OR REPLACE VIEW myv6\n    AS\n    \n    SELECT last_name,email,salary\n    FROM employees\n    WHERE employee_id IN(\n    \tSELECT  manager_id\n    \tFROM employees\n    \tWHERE manager_id IS NOT NULL\n    );\n    \n    # 修改\n    UPDATE myv6 SET salary=10000 WHERE last_name = 'k_ing';\n    ```\n\n    查询领导Id（将所有员工的上级Id查出来，这些Id就是领导Id）：\n\n    `SELECT DISTINCT manager_id FROM employees WHERE manager_id IS NOT NULL`\n\n## 视图和表的对比\n\n|      | 关键字 | 是否占用物理空间        | 使用         |\n| ---- | ------ | ----------------------- | ------------ |\n| 视图 | view   | 占用较小，只保存sql逻辑 | 一般用于查询 |\n| 表   | table  | 保存实际的数据          | 增删改查     |\n\n​\t\t\t\t\t\n​\t\t\t\t\t\t\t","tags":["mysql"],"categories":["mysql"]},{"title":"Hystrix服务熔断","url":"/2020/05/23/springCloud/hystrix/","content":"\n\n# Hystrix\n\n## 简介\n\nHystrix,英文意思是豪猪，全身是刺，看起来就不好惹，是一种保护机制。\n\nHystrix也是Netflix公司的一款组件。\n\n![1525658740266](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1525658740266.png)\n\n那么Hystix的作用是什么呢？具体要保护什么呢？\n\nHystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。\n\n\n\n## 雪崩问题\n\n微服务中，服务间调用关系错综复杂，一个请求，可能需要调用多个微服务接口才能实现，会形成非常复杂的调用链路：\n\n ![1533829099748](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1533829099748.png)\n\n如图，一次业务请求，需要调用A、P、H、I四个服务，这四个服务又可能调用其它服务。\n\n如果此时，某个服务出现异常：\n\n![1533829198240](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1533829198240.png)\n\n例如微服务I发生异常，请求阻塞，用户不会得到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞：\n\n ![1533829307389](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1533829307389.png)\n\n服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，形成雪崩效应。\n\n这就好比，一个汽车生产线，生产不同的汽车，需要使用不同的零件，如果某个零件因为种种原因无法使用，那么就会造成整台车无法装配，陷入等待零件的状态，直到零件到位，才能继续组装。  此时如果有很多个车型都需要这个零件，那么整个工厂都将陷入等待的状态，导致所有生产都陷入瘫痪。一个零件的波及范围不断扩大。 \n\nHystix解决雪崩问题的手段有两个：\n\n- 线程隔离\n- 服务熔断\n\n\n\n## 线程隔离，服务降级\n\n### 原理\n\n线程隔离示意图：\n\n ![1533829598310](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1533829598310.png)\n\n解读：\n\nHystrix为每个依赖服务调用分配一个小的线程池，如果线程池已满调用将被立即拒绝，默认不采用排队.加速失败判定时间。\n\n用户的请求将不再直接访问服务，而是通过线程池中的空闲线程来访问服务，如果**线程池已满**，或者**请求超时**，则会进行降级处理，什么是服务降级？\n\n> 服务降级：优先保证核心服务，而非核心服务不可用或弱可用。\n\n用户的请求故障时，不会被阻塞，更不会无休止的等待或者看到系统崩溃，至少可以看到一个执行结果（例如返回友好的提示信息） 。\n\n服务降级虽然会导致请求失败，但是不会导致阻塞，而且最多会影响这个依赖服务对应的线程池中的资源，对其它服务没有响应。\n\n触发Hystix服务降级的情况：\n\n- 线程池已满\n- 请求超时\n\n\n\n## 动手实践\n\n### 引入依赖\n\n!> 虽然Eureka已经集成了`Hystrix`，但是还缺少一些依赖，还是要手动添加hystrix的场景依赖\n\n首先在`springcloud-eureka-service-consumer`的pom.xml中引入`Hystrix`依赖：\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n</dependency>\n```\n\n### 开启熔断\n\n在启动类上添加`@EnableCircuitBreaker`注解，表示开启熔断\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\n@EnableCircuitBreaker\npublic class SpringcloudEurekaServiceConsumerApplication \n```\n\n\n\n####  @SpringCloudApplication\n\n可以看到，我们类上的注解越来越多，在微服务中，经常会引入上面的三个注解，于是Spring就提供了一个组合注解：`@SpringCloudApplication`\n\n```java\n@SpringCloudApplication\npublic class SpringcloudEurekaServiceConsumerApplication \n```\n\n\n\n### 编写降级逻辑\n\n我们改造`springcloud-eureka-service-consumer`，当目标服务的调用出现故障，我们希望快速失败，给用户一个友好提示。因此需要提前编写好失败时的降级处理逻辑，要使用HystixCommond来完成：\n\n```java\n@RestController\n@RequestMapping(\"user\")\npublic class UserController {\n\n    @Autowired\n    private RestTemplate restTemplate;\n\n    @GetMapping(\"/{id}\")\n    @HystrixCommand(fallbackMethod = \"getUserByIDFallback\")\n    public String getUserById(@PathVariable Long id) {\n        //直接通过服务名称调用\n        String baseUrl = \"http://service-provider/user/\";\n        return restTemplate.getForObject(baseUrl+id, String.class);\n    }\n\n    public String getUserByIDFallback(Long id){\n        return id+\"查询失败，原因：请求繁忙！\";\n    }\n}\n```\n\n`@HystrixCommand(fallbackMethod = \"getUserByIDFallback\")`：用来声明一个降级逻辑的方法\n\n!> 要注意，因为熔断的降级逻辑方法必须跟正常逻辑方法保证：**相同的参数列表和返回值声明**。失败逻辑中返回实体类对象没有太大意义，一般会返回友好提示。所以我们把getUserById的方法改造为返回String，反正也是Json数据。这样失败逻辑中返回一个错误说明，会比较方便。\n\n\n\n然后重启`springcloud-eureka-service-consumer`，访问<http://localhost:8083/user/1>\n\n这是正常情况所以和以前一样返回请求的数据\n\n接下来把两个服务提供应用都关闭，再重新访问\n\n会发现页面返回了降级处理信息：\n\n\n\n### 默认FallBack\n\n我们刚才把fallback写在了某个业务方法上，如果这样的方法很多，那岂不是要写很多。所以我们可以把Fallback配置加在类上，实现默认fallback\n\n```java\n@RestController\n@RequestMapping(\"user\")\n@DefaultProperties(defaultFallback = \"defaultFallback\")\npublic class UserController {\n\n    @Autowired\n    private RestTemplate restTemplate;\n\n    @GetMapping(\"/{id}\")\n    @HystrixCommand\n    public String getUserById(@PathVariable Long id) {\n        //直接通过服务名称调用\n        String baseUrl = \"http://service-provider/user/\";\n        return restTemplate.getForObject(baseUrl+id, String.class);\n    }\n\n    public String defaultFallback(){\n        return \"请求繁忙，请稍后再试！\";\n    }\n}\n```\n\n- `@DefaultProperties(defaultFallback = \"defaultFallBack\")`：在类上指明统一的失败降级方法\n- `@HystrixCommand`：在方法上直接使用该注解，使用默认的降级方法。\n- `defaultFallback()`：默认降级方法，<span style=\"color:red\">不能有任何参数，且返回值一定要一致</span>，以匹配更多方法\n\n### 设置超时\n\n在之前的案例中，请求在超过1秒后都会返回错误信息，这是因为Hystix的默认超时时长为1，我们可以通过配置修改这个值：\n\n```yaml\nhystrix:\n  command:\n    default:\n      execution:\n        isolation:\n          thread:\n            timeoutInMilliseconds: 6000 # 设置hystrix的超时时间为6000ms(6秒)\n```\n\n这里我们修改服务提供方，模拟网络延迟，在服务提供方睡眠8秒，启动\n\n```java\n@RestController\n@RequestMapping(\"user\")\npublic class UserController {\n\n    @Autowired\n    private IUserService userService;\n\n    @GetMapping(\"/{id}\")\n    public TbUser queryUserById(@PathVariable Long id) {\n        try {\n            Thread.sleep(8000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return userService.queryById(id);\n    }\n}\n```\n\n重启`springcloud-eureka-service-consumer`\n\n再访问：\n\n这次就不是立马返回结果了，而是6秒之后\n\n![1574764520930](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574764520930.png)\n\n\n\n## 服务熔断\n\n### 熔断原理\n\n熔断器，也叫断路器，其英文单词为：Circuit Breaker \n\n![1525658640314](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1525658640314.png)\n\n熔断状态机3个状态：\n\n- `Closed`：关闭状态，所有请求都正常访问。\n- `Open`：打开状态，所有请求都会被降级。Hystix会对请求情况计数，当一定时间内失败请求百分比达到阈值，则触发熔断，断路器会完全打开。默认失败比例的阈值是50%，请求次数最少不低于20次。\n- `Half Open`：半开状态，open状态不是永久的，打开后会进入休眠时间（默认是5S）。随后断路器会自动进入半开状态。此时会释放部分请求通过，若这些请求都是健康的，则会完全关闭断路器，否则继续保持打开，再次进行休眠计时\n\n\n\n### 动手实践\n\n为了能够精确控制请求的成功或失败，我们在consumer的调用业务中加入一段逻辑：\n\n```java\n@RestController\n@RequestMapping(\"user\")\n@DefaultProperties(defaultFallback = \"defaultFallback\")\npublic class UserController {\n\n    @Autowired\n    private RestTemplate restTemplate;\n\n\n    @GetMapping(\"/{id}\")\n    @HystrixCommand\n    public String getUserById(@PathVariable Long id) {\n        if (id==1){\n            throw new RuntimeException(\"忙碌中......\");\n        }\n        //直接通过服务名称调用\n        String baseUrl = \"http://service-provider/user/\";\n        return restTemplate.getForObject(baseUrl+id, String.class);\n    }\n\n    public String defaultFallback(){\n        return \"请求繁忙，请稍后再试！\";\n    }\n}\n```\n\n这样如果参数是id为1，一定失败，其它情况都成功。\n\n!> 不要忘了删掉service-provider中的休眠逻辑\n\n接下来\n\n1. 请求<http://localhost:8083/user/2>，一切正常\n2. 然后慢悠悠的请求，<http://localhost:8083/user/1>，20次，慢一点\n3. 然后再访问2，还是正常\n4. 接下来，疯狂请求<http://localhost:8083/user/1>，20次，快，一定要快\n5. 接着再访问2，咦！发现2也无法访问，也被降级了\n6. 然后，数5秒后再访问1后再访问2，依旧无法访问\n7. 最后再数5秒后访问2，就可以访问了，结合熔断状态机3个状态想想，应该知道是怎么回事了吧\n\n\n\n### 修改熔断策略\n\n我们可以注解修改熔断策略：\n\n```yaml\n@RestController\n@RequestMapping(\"user\")\n@DefaultProperties(\n        defaultFallback = \"defaultFallback\",\n        commandProperties = {\n                @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\", value = \"5\"),\n                @HystrixProperty(name = \"circuitBreaker.sleepWindowInMilliseconds\", value = \"10000\"),\n                @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\", value = \"50\")\n        })\npublic class UserController {\n\n    @Autowired\n    private RestTemplate restTemplate;\n\n\n    @GetMapping(\"/{id}\")\n    @HystrixCommand\n    public String getUserById(@PathVariable Long id) {\n        if (id == 1) {\n            throw new RuntimeException(\"忙碌中......\");\n        }\n        //直接通过服务名称调用\n        String baseUrl = \"http://service-provider/user/\";\n        return restTemplate.getForObject(baseUrl + id, String.class);\n    }\n\n    public String defaultFallback() {\n        return \"请求繁忙，请稍后再试！\";\n    }\n}\n```\n\n\n\n- `requestVolumeThreshold`：触发熔断的最小请求次数，默认20\n- `sleepWindowInMilliseconds`：休眠时长，默认是5000毫秒\n- `errorThresholdPercentage`：触发熔断的失败请求最小占比，默认50%\n\n","tags":["springcloud"],"categories":["springcloud"]},{"title":"SpringCloud简介","url":"/2020/05/23/springCloud/getting/","content":"\n# 初识SpringCloud\n\n微服务是一种架构方式，最终肯定需要技术架构去实施。\n\n微服务的实现方式很多，但是最火的莫过于Spring Cloud了。为什么？\n\n- 后台硬：作为Spring家族的一员，有整个Spring全家桶靠山，背景十分强大。\n- 技术强：Spring作为Java领域的前辈，可以说是功力深厚。有强力的技术团队支撑，一般人还真比不了\n- 群众基础好：可以说大多数程序员的成长都伴随着Spring框架，试问：现在有几家公司开发不用Spring？SpringCloud与Spring的各个框架无缝整合，对大家来说一切都是熟悉的配方，熟悉的味道。\n- 使用方便：相信大家都体会到了SpringBoot给我们开发带来的便利，而SpringCloud完全支持SpringBoot的开发，用很少的配置就能完成微服务框架的搭建\n\n\n\n## 简介\n\nSpringCloud是Spring旗下的项目之一，官网：<https://spring.io/projects/spring-cloud>\n\nSpring最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。\n\nSpringCloud也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括：\n\n- Eureka：注册中心\n- Zuul：服务网关\n- Ribbon：负载均衡\n- Feign：服务调用\n- Hystix：熔断器\n\n以上只是其中一部分，架构图：\n\n![1525575656796](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1525575656796.png)\n\n\n\n## SpringCloud的版本\n\n因为Spring Cloud不同其他独立项目，它拥有很多子项目的大项目。所以它的版本是版本名+版本号 （如Angel.SR6）。  \n\n版本名：是伦敦的地铁名  \n\n版本号：SR（Service Releases）是固定的 ,大概意思是稳定版本。后面会有一个递增的数字。 \n\n所以 Edgware.SR3就是Edgware的第3个Release版本。  \n\n\n\n## 微服务场景模拟\n\n首先，我们需要模拟一个服务调用的场景，搭建两个工程：springcloud-service-provider（服务提供方）和springcloud-service-consumer（服务调用方）。方便后面学习微服务架构\n\n服务提供方：使用mybatis操作数据库，实现对数据的增删改查；并对外提供rest接口服务。\n\n服务消费方：使用restTemplate远程调用服务提供方的rest接口服务，获取数据。\n\n步骤几乎和[HttpClient](http://localhost:3000/#/backend/springCloud/rpc?id=httpclient)调一致\n\n\n\n### 服务提供方\n\n1. 创建项目命名为`springcloud-service-provider`，选择web场景和mysql驱动，添加通用mapper场景\n\n   <details>\n\n   <summary>pom.xml</summary>\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n       <modelVersion>4.0.0</modelVersion>\n       <parent>\n           <groupId>org.springframework.boot</groupId>\n           <artifactId>spring-boot-starter-parent</artifactId>\n           <version>2.2.1.RELEASE</version>\n           <relativePath/> <!-- lookup parent from repository -->\n       </parent>\n       <groupId>cn.clboy</groupId>\n       <artifactId>springcloud-service-provider</artifactId>\n       <version>0.0.1-SNAPSHOT</version>\n       <name>springcloud-service-provider</name>\n       <description>Demo project for Spring Boot</description>\n   \n       <properties>\n           <java.version>1.8</java.version>\n       </properties>\n   \n       <dependencies>\n           <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-starter-web</artifactId>\n           </dependency>\n   \n           <dependency>\n               <groupId>mysql</groupId>\n               <artifactId>mysql-connector-java</artifactId>\n               <scope>runtime</scope>\n           </dependency>\n           <dependency>\n               <groupId>tk.mybatis</groupId>\n               <artifactId>mapper-spring-boot-starter</artifactId>\n               <version>2.1.5</version>\n           </dependency>\n           \n       </dependencies>\n   \n       <build>\n           <plugins>\n               <plugin>\n                   <groupId>org.springframework.boot</groupId>\n                   <artifactId>spring-boot-maven-plugin</artifactId>\n               </plugin>\n           </plugins>\n       </build>\n   \n   </project>\n   ```\n\n   </details>\n\n2. 配置数据库连接\n\n   ```yaml\n   spring:\n     datasource:\n       url: jdbc:mysql://localhost:3306/leyoumall\n       username: root\n       password: root\n       driver-class-name: com.mysql.cj.jdbc.Driver\n   ```\n\n3. 将用户实体类添加到项目中\n\n   <details>\n\n   ​    <summary>User.java</summary>\n\n   ```java\n   package cn.clboy.httpclientservice.pojo;\n   \n   import javax.persistence.*;\n   import java.util.Date;\n   \n   @Table(name = \"tb_user\")\n   public class TbUser {\n   \n       @Id\n       @GeneratedValue(strategy = GenerationType.IDENTITY)\n       private Long id;\n       private String username;\n       private String password;\n       private String phone;\n       private Date created;\n   \n       public Long getId() {\n           return id;\n       }\n   \n       public void setId(Long id) {\n           this.id = id;\n       }\n   \n       public String getUsername() {\n           return username;\n       }\n   \n       public void setUsername(String username) {\n           this.username = username;\n       }\n   \n       public String getPassword() {\n           return password;\n       }\n   \n       public void setPassword(String password) {\n           this.password = password;\n       }\n   \n       public String getPhone() {\n           return phone;\n       }\n   \n       public void setPhone(String phone) {\n           this.phone = phone;\n       }\n   \n       public Date getCreated() {\n           return created;\n       }\n   \n       public void setCreated(Date created) {\n           this.created = created;\n       }\n   }\n   ```\n\n   \n\n   </details>\n\n4. 添加`UserMapper`\n\n   ```java\n   package cn.clboy.service.provider.mapper;\n   \n   import cn.clboy.service.provider.pojo.TbUser;\n   import tk.mybatis.mapper.common.Mapper;\n   \n   public interface UserMapper extends Mapper<TbUser> {\n   \n   }\n   ```\n\n5. UserService\n\n   <details>\n\n   ​    <summary>service接口和实现</summary>\n\n   ```java\n   public interface IUserService {\n   \n       /**\n        * 根据ID查询\n        * @param id\n        * @return\n        */\n       public TbUser queryById(Long id);\n   }\n   ```\n\n   ```java\n   @Service\n   public class UserServiceImpl implements IUserService {\n   \n       @Autowired\n       private UserMapper userMapper;\n   \n       @Override\n       public TbUser queryById(Long id) {\n           return userMapper.selectByPrimaryKey(id);\n       }\n   }\n   ```\n\n   </details>\n\n6. UserController\n\n   ```java\n   @RestController\n   @RequestMapping(\"user\")\n   public class UserController {\n   \n       @Autowired\n       private IUserService userService;\n   \n       @GetMapping(\"/{id}\")\n       public TbUser queryUserById(@PathVariable Long id) {\n           return userService.queryById(id);\n       }\n   }\n   ```\n\n7. 在启动类上添加mapper扫描注解\n\n   <details>\n\n   ​    <summary>启动类</summary>\n\n   ```java\n   import tk.mybatis.spring.annotation.MapperScan;\n   \n   @MapperScan(\"cn.clboy.service.provider.mapper\")\n   @SpringBootApplication\n   public class SpringcloudServiceProviderApplication {\n   \n       public static void main(String[] args) {\n           SpringApplication.run(SpringcloudServiceProviderApplication.class, args);\n       }\n   \n   }\n   ```\n\n   </details>\n\n8. 访问：<http://localhost:8080/user/1>，一切正常接下来写服务消费方\n\n\n\n### 服务提供方\n\n1. 创建工程，名为`springcloud-service-consumer`，只需要选择web场景即可\n\n2. 把实体类复制一份过来，把不需要的注解删除掉\n\n3. 在启动类中向容器注入RestTemplate\n\n   ```java\n   @SpringBootApplication\n   public class SpringcloudServiceConsumerApplication {\n   \n       public static void main(String[] args) {\n           SpringApplication.run(SpringcloudServiceConsumerApplication.class, args);\n       }\n   \n       @Bean\n       public RestTemplate restTemplate() {\n           return new RestTemplate();\n       }\n   }\n   ```\n\n   \n\n4. 创建Controlelr使用restTemplate调用服务\n\n   ```java\n   @RestController\n   @RequestMapping(\"user\")\n   public class UserController {\n   \n       @Autowired\n       private RestTemplate restTemplate;\n   \n       @GetMapping(\"/{id}\")\n       public TbUser getUserById(@PathVariable Long id) {\n           return restTemplate.getForObject(\"http://localhost:8080/user/\" + id, TbUser.class);\n       }\n   }\n   ```\n\n5. 修改端口号启动测试\n\n   ```yaml\n   server:\n     port: 8081\n   ```\n\n\n\n## 存在的问题？\n\n简单回顾一下，刚才我们写了什么：\n\n- springcloud-service-provider：一个提供根据id查询用户的微服务。\n- springcloud-service-consumer：一个服务调用者，通过RestTemplate远程调用springcloud-service-provider。\n\n存在什么问题？\n\n- 在consumer中，我们把url地址硬编码到了代码中，不方便后期维护\n- consumer需要记忆provider的地址，如果出现变更，可能得不到通知，地址将失效\n- consumer不清楚provider的状态，服务宕机也不知道\n- provider只有1台服务，不具备高可用性\n- 即便provider形成集群，consumer还需自己实现负载均衡\n\n其实上面说的问题，概括一下就是分布式服务必然要面临的问题：\n\n- 服务管理\n  - 如何自动注册和发现\n  - 如何实现状态监管\n  - 如何实现动态路由\n- 服务如何实现负载均衡\n- 服务如何解决容灾问题\n- 服务如何实现统一配置\n\n以上的问题，我们都将在SpringCloud中得到答案。\n\n\n\n## Eureka注册中心\n\n### 认识Eureka\n\n首先我们来解决第一问题，服务的管理。\n\n> 问题分析\n\n在刚才的案例中，springcloud-service-provider对外提供服务，需要对外暴露自己的地址。而consumer（调用者）需要记录服务提供者的地址。将来地址出现变更，还需要及时更新。这在服务较少的时候并不觉得有什么，但是在现在日益复杂的互联网环境，一个项目肯定会拆分出十几，甚至数十个微服务。此时如果还人为的管理地址，不仅开发困难，将来测试、发布上线都会非常麻烦，这与DevOps的思想是背道而驰的。\n\n> 网约车\n\n这就好比是 网约车出现以前，人们出门叫车只能叫出租车。一些私家车想做出租却没有资格，被称为黑车。而很多人想要约车，但是无奈出租车太少，不方便。私家车很多却不敢拦，而且满大街的车，谁知道哪个才是愿意载人的。一个想要，一个愿意给，就是缺少引子，缺乏管理啊。\n\n此时滴滴这样的网约车平台出现了，所有想载客的私家车全部到滴滴注册，记录你的车型（服务类型），身份信息（联系方式）。这样提供服务的私家车，在滴滴那里都能找到，一目了然。\n\n此时要叫车的人，只需要打开APP，输入你的目的地，选择车型（服务类型），滴滴自动安排一个符合需求的车到你面前，为你服务，完美！\n\n### Eureka做什么？\n\nEureka就好比是滴滴，负责管理、记录服务提供者的信息。服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。\n\n同时，服务提供方与Eureka之间通过`心跳`机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。\n\n这就实现了服务的自动注册、发现、状态监控。\n\n> 原理图\n\n ![1525597885059](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1525597885059.png)\n\n\n\n## 入门案例\n\n### 搭建EurekaServer\n\n创建一个项目名为`springcloud-eureka-server`，启动一个`EurekaServer`：\n\n#### 选择依赖\n\nEurekaServer-服务注册中心依赖，Eureka Discovery-服务提供方和服务消费方。因为，对于eureka来说：服务提供方和服务消费方都属于客户端，注意选择Springboot的版本，可以查看springcloud官网当前稳定版本兼容的springboot版本\n\n![1574680199268](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574680199268.png)\n\n![1574680309713](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574680309713.png)\n\n![1574680364490](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574680364490.png)\n\n\n\n<details>\n\n​    <summary>pom.xml</summary>\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.1.10.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n    <groupId>cn.clboy</groupId>\n    <artifactId>springcloud-eureka-server</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>springcloud-eureka-server</name>\n    <description>Demo project for Spring Boot</description>\n\n    <properties>\n        <java.version>1.8</java.version>\n        <spring-cloud.version>Greenwich.SR4</spring-cloud.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>${spring-cloud.version}</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n\n```\n\n</details>\n\n#### application.yaml配置\n\n```yaml\nserver:\n  port: 10001\nspring:\n  application:\n    # 应用名称，会在Eureka中显示\n    name: eureka-server\neureka:\n  client:\n    # 此应用为注册中心，false：不向注册中心注册自己。不配置这个启动会抛出一堆错误，不过不影响启动，就是看着闹心\n    register-with-eureka: false\n    # 注册中心职责是维护服务实例，false：不检索服务。(因为这是一个单点的EurekaServer，不需要同步其它EurekaServer节点的数据，故设为false)\n    fetch-registry: false\n    service-url:\n      # EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。\n      defaultZone: http://127.0.0.1:${server.port}/eureka\n\n```\n\n#### @EnableEurekaServer\n\n> 声明当前springboot应用是一个eureka服务中心\n\n修改引导类，在类上添加@EnableEurekaServer注解：\n\n```java\n@SpringBootApplication\n@EnableEurekaServer\npublic class SpringcloudEurekaServerApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringcloudEurekaServerApplication.class, args);\n    }\n\n}\n```\n\n启动服务，访问：http://127.0.0.1:10001\n\n\n\n### 注册服务到Eureka\n\n注册服务，就是在服务上添加Eureka的客户端依赖，客户端代码会自动把服务注册到EurekaServer中。\n\n创建项目，项目名为`springcloud-eureka-service-provider`，选择web场景和eureka客户端场景，添加mysql驱动和通用mapper依赖\n\n![1574683898661](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574683898661.png)\n\n<details>\n\n​    <summary>pom.xml</summary>\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.1.10.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n    <groupId>cn.clboy</groupId>\n    <artifactId>springcloud-eureka-service-provider</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>springcloud-eureka-service-provider</name>\n    <description>Demo project for Spring Boot</description>\n\n    <properties>\n        <java.version>1.8</java.version>\n        <spring-cloud.version>Greenwich.SR4</spring-cloud.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <scope>runtime</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>tk.mybatis</groupId>\n            <artifactId>mapper-spring-boot-starter</artifactId>\n            <version>2.1.5</version>\n        </dependency>\n    </dependencies>\n\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>${spring-cloud.version}</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n\n```\n\n\n\n</details>\n\n把之前`springcloud-service-provider`的TbUser实体类、Mapper接口、service、controller都复制到该项目中，将包名都修改正确\n\n#### 配置文件\n\n```yaml\nserver:\n  port: 8081\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/leyoumall\n    username: root\n    password: root\n    driver-class-name: com.mysql.cj.jdbc.Driver\n  application:\n    # 应用名称，注册到eureka后的服务名称\n    name: service-provider\neureka:\n  client:\n    # EurekaServer地址\n    service-url:\n      defaultZone: http://127.0.0.1:10001/eureka\n```\n\n\n\n!> 这里我们添加了spring.application.name属性来指定应用名称，将来会作为`应用的id`使用。\n\n#### @EnableDiscoveryClient\n\n在引导类上开启Eureka客户端功能\n\n通过添加`@EnableDiscoveryClient`来开启Eureka客户端功能\n\n```java\n@MapperScan(basePackages = \"cn.clboy.springcloud.eureka.service.provider.mapper\")\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class SpringcloudEurekaServiceProviderApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SpringcloudEurekaServiceProviderApplication.class, args);\n\t}\n\n}\n```\n\n\n\n重启项目，访问[Eureka监控页面：http://127.0.0.1:10001](http://127.0.0.1:10001)查看\n\n\n\n### 从Eureka获取服务\n\n创建项目。项目名为`springcloud-eureka-service-consumer`，和服务提供项目类型，选择web场景和eureka客户端场景，将之前`springcloud-service-consumer`中的实体类、controller复制过来\n\n<details>\n\n​    <summary>pom.xml</summary>\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.1.10.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n    <groupId>cn.clboy</groupId>\n    <artifactId>springcloud-eureka-service-consumer</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>springcloud-eureka-service-consumer</name>\n    <description>Demo project for Spring Boot</description>\n\n    <properties>\n        <java.version>1.8</java.version>\n        <spring-cloud.version>Greenwich.SR4</spring-cloud.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>${spring-cloud.version}</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n\n```\n\n\n\n</details>\n\n#### 配置文件\n\n```yaml\nserver:\n  port: 8083\nspring:\n  application:\n    name: service-consumer\neureka:\n  client:\n    service-url:\n      defaultZone: http://127.0.0.1:10001/eureka\n```\n\n\n\n#### 启动类\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class SpringcloudEurekaServiceConsumerApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringcloudEurekaServiceConsumerApplication.class, args);\n    }\n\n    @Bean\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n\n}\n```\n\n\n\n#### 修改Controller\n\n```java\n@RestController\n@RequestMapping(\"user\")\npublic class UserController {\n\n    @Autowired\n    private RestTemplate restTemplate;\n\n    @Autowired\n    /**\n     * eureka客户端，可以获取到eureka中服务的信息\n     */\n    private DiscoveryClient discoveryClient;\n\n    @GetMapping(\"/{id}\")\n    public TbUser getUserById(@PathVariable Long id) {\n        // 根据服务名称，获取服务实例。有可能是集群，所以是service实例集合\n        List<ServiceInstance> instances = discoveryClient.getInstances(\"service-provider\");\n        // 因为只有一个Service-provider。所以这里直接获取第一个实例\n        ServiceInstance serviceInstance = instances.get(0);\n        //从实例中获取主机和端口号拼接出接口地址\n        return restTemplate.getForObject(\"http://\" + serviceInstance.getHost() + \":\" + serviceInstance.getPort() + \"/user/\" + id, TbUser.class);\n    }\n}\n```\n\n","tags":["springcloud"],"categories":["springcloud"]},{"title":"Ribbon负载均衡","url":"/2020/05/23/springCloud/ribbon/","content":"\n\n# Ribbon负载均衡\n\n在上节的案例中，我们启动了一个`springcloud-eureka-service-provider`，然后通过DiscoveryClient来获取服务实例信息，然后获取ip和端口来访问。\n\n但是实际环境中，我们往往会开启很多个`springcloud-eureka-service-provider`的集群。此时我们获取的服务列表中就会有多个，到底该访问哪一个呢？\n\n一般这种情况下我们就需要编写负载均衡算法，在多个实例列表中进行选择。\n\n不过Eureka中已经帮我们集成了负载均衡组件：Ribbon，简单修改代码即可使用。\n\n什么是Ribbon：\n\n![1525619257397](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1525619257397.png)\n\n\n\n接下来，我们就来使用Ribbon实现负载均衡。\n\n\n\n## 启动两个服务实例\n\n首先参照`springcloud-eureka-server`启动两个`springcloud-eureka-service-provider`实例，一个8081，一个8084。\n\n![1574740696735](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574740696735.png)\n\n\n\n查看Eureka监控面板：\n\n![1574740920124](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574740920124.png)\n\n\n\n## 开启负载均衡\n\n因为Eureka中已经集成了Ribbon，所以我们无需引入新的依赖，直接修改代码。\n\n修改`springcloud-eureka-service-consumer`的引导类，在注册RestTemplate的配置方法上添加`@LoadBalanced`注解：\n\n<small>loadBalanced为负载均衡的意思</small>\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class SpringcloudEurekaServiceConsumerApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringcloudEurekaServiceConsumerApplication.class, args);\n    }\n\n    @Bean\n    @LoadBalanced\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n\n}\n```\n\n\n\n修改调用方式，不再手动获取ip和端口拼接字符串，而是直接通过服务名称调用：\n\n<details>\n\n​    <summary>以前的调用方式</summary>\n\n```java\n@RestController\n@RequestMapping(\"user\")\npublic class UserController {\n\n    @Autowired\n    private RestTemplate restTemplate;\n\n    @Autowired\n    /**\n     * eureka客户端，可以获取到eureka中服务的信息\n     */\n    private DiscoveryClient discoveryClient;\n\n    @GetMapping(\"/{id}\")\n    public TbUser getUserById(@PathVariable Long id) {\n        // 根据服务名称，获取服务实例。有可能是集群，所以是service实例集合\n        List<ServiceInstance> instances = discoveryClient.getInstances(\"service-provider\");\n        // 因为只有一个Service-provider。所以这里直接获取第一个实例\n        ServiceInstance serviceInstance = instances.get(0);\n        //从实例中获取主机和端口号拼接出接口地址\n        return restTemplate.getForObject(\"http://\" + serviceInstance.getHost() + \":\" + serviceInstance.getPort() + \"/user/\" + id, TbUser.class);\n    }\n}\n```\n\n</details>\n\n使用负载均衡的调用方式：\n\n```java\n@RestController\n@RequestMapping(\"user\")\npublic class UserController {\n\n    @Autowired\n    private RestTemplate restTemplate;\n\n\n    @GetMapping(\"/{id}\")\n    public TbUser getUserById(@PathVariable Long id) {\n        //直接通过服务名称调用\n        String baseUrl = \"http://service-provider/user/\";\n        return restTemplate.getForObject(baseUrl+id, TbUser.class);\n    }\n}\n```\n\n访问：<http://localhost:8083/user/1>，同样能够正常调用并返回结果\n\n\n\n## 源码跟踪\n\n为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。\n\n显然有地方帮我们根据service名称，获取到了服务实例的ip和端口。\n\n我们在调用接口的地方打上端点，一探究竟\n\n![1574741717858](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574741717858.png)\n\n以DEBUG的方法重新启动`springcloud-eureka-service-consumer`，然后访问<http://localhost:8083/user/1>\n\n1. 调用execute方法\n\n   ```java\n       @Nullable\n       public <T> T getForObject(String url, Class<T> responseType, Object... uriVariables) throws RestClientException {\n           RequestCallback requestCallback = this.acceptHeaderRequestCallback(responseType);\n           HttpMessageConverterExtractor<T> responseExtractor = new HttpMessageConverterExtractor(responseType, this.getMessageConverters(), this.logger);\n           //调用execute方法,f7继续跟踪\n           return this.execute(url, HttpMethod.GET, requestCallback, responseExtractor, (Object[])uriVariables);\n       }\n   ```\n\n2. 调用doExecute\n\n   ```java\n       @Nullable\n       public <T> T execute(String url, HttpMethod method, @Nullable RequestCallback requestCallback, @Nullable ResponseExtractor<T> responseExtractor, Object... uriVariables) throws RestClientException {\n           //将请求封装为URI\n           URI expanded = this.getUriTemplateHandler().expand(url, uriVariables);\n           //调用doExecute方法,f7继续跟踪\n           return this.doExecute(expanded, method, requestCallback, responseExtractor);\n       }\n   ```\n\n3. request.execute，调用`AbstractClientHttpRequest`的execute方法\n\n   ![1574742576423](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574742576423.png)\n\n4. 又调用`AbstractBufferingClientHttpRequest`的executeInternal方法\n\n   ```java\n       public final ClientHttpResponse execute() throws IOException {\n           this.assertNotExecuted();\n           //f7进入\n           ClientHttpResponse result = this.executeInternal(this.headers);\n           this.executed = true;\n           return result;\n       }\n   ```\n\n5. 调用`InterceptingClientHttpRequest`重写的executeInternal方法\n\n   ```java\n       protected ClientHttpResponse executeInternal(HttpHeaders headers) throws IOException {\n           byte[] bytes = this.bufferedOutput.toByteArray();\n           if (headers.getContentLength() < 0L) {\n               headers.setContentLength((long)bytes.length);\n           }\n           //f7进入\n           ClientHttpResponse result = this.executeInternal(headers, bytes);\n           this.bufferedOutput = new ByteArrayOutputStream(0);\n           return result;\n       }\n   ```\n\n6. 创建请求拦截器执行对象\n\n   ```java\n       protected final ClientHttpResponse executeInternal(HttpHeaders headers, byte[] bufferedOutput) throws IOException {\n           //创建请求拦截器执行对象\n           InterceptingClientHttpRequest.InterceptingRequestExecution requestExecution = new InterceptingClientHttpRequest.InterceptingRequestExecution();\n           //调用执行方法\n           return requestExecution.execute(this, bufferedOutput);\n       }\n   \n   ```\n\n7. 调用请求拦截器的执行方法\n\n   ![1574743938108](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574743938108.png)\n\n   在执行方法中获取拦截器，调用其intercept方法\n\n8. 负载均衡的执行方法，`RibbonLoadBalancerClient.execute`\n\n   ```java\n       public ClientHttpResponse intercept(final HttpRequest request, final byte[] body, final ClientHttpRequestExecution execution) throws IOException {\n           URI originalUri = request.getURI();\n           //获取服务名称\n           String serviceName = originalUri.getHost();\n           Assert.state(serviceName != null, \"Request URI does not contain a valid hostname: \" + originalUri);\n           //调用负载均衡的执行方法\n           return (ClientHttpResponse)this.loadBalancer.execute(serviceName, this.requestFactory.createRequest(request, body, execution));\n       }\n   ```\n\n9. 在其中又调用`RibbonLoadBalancerClient`重载的execute方法\n\n   ```java\n       public <T> T execute(String serviceId, LoadBalancerRequest<T> request) throws IOException {\n           return this.execute(serviceId, (LoadBalancerRequest)request, (Object)null);\n       }\n   \n       public <T> T execute(String serviceId, LoadBalancerRequest<T> request, Object hint) throws IOException {\n           //获取负载均衡器实例，其中有当前请求服务的地址列表等服务信息\n           ILoadBalancer loadBalancer = this.getLoadBalancer(serviceId);\n           //根据负载均衡算法从服务列表中获取一个服务\n           Server server = this.getServer(loadBalancer, hint);\n           if (server == null) {\n               throw new IllegalStateException(\"No instances available for \" + serviceId);\n           } else {\n               RibbonLoadBalancerClient.RibbonServer ribbonServer = new RibbonLoadBalancerClient.RibbonServer(serviceId, server, this.isSecure(server, serviceId), this.serverIntrospector(serviceId).getMetadata(server));\n               return this.execute(serviceId, (ServiceInstance)ribbonServer, (LoadBalancerRequest)request);\n           }\n       }\n   \n   ```\n\n10. 获取服务\n\n    ```java\n        protected Server getServer(ILoadBalancer loadBalancer, Object hint) {\n            //调用负载均衡实例的chooseServer方法，选择服务\n            return loadBalancer == null ? null : loadBalancer.chooseServer(hint != null ? hint : \"default\");\n        }\n    ```\n\n11. 选择服务中，又调用了父类的chooseServer方法，看下父类方法\n\n    ```java\n        public Server chooseServer(Object key) {\n            if (this.counter == null) {\n                this.counter = this.createCounter();\n            }\n    \n            this.counter.increment();\n            if (this.rule == null) {\n                return null;\n            } else {\n                try {\n                    //根据当前的负载均衡规则选择，默认是RoundRobinRule(轮循)，是IRule接口的实现\n                    return this.rule.choose(key);\n                } catch (Exception var3) {\n                    logger.warn(\"LoadBalancer [{}]:  Error choosing server for key {}\", new Object[]{this.name, key, var3});\n                    return null;\n                }\n            }\n        }\n    ```\n\n    ![1574751683467](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574751683467.png)\n\n\n\n## 负载均衡策略\n\nRibbon默认的负载均衡策略是简单的轮询，我们可以测试一下：\n\n编写测试类，在刚才的源码中我们看到拦截中是使用`RibbonLoadBalancerClient`来进行负载均衡的，其中有一个`choose`方法，找到choose方法的接口方法，是这样介绍的：\n\n```java\npublic interface ServiceInstanceChooser {\n\n\t/**\n\t * 根据服务名称从负载均衡器中选择一个服务实例返回\n\t * Chooses a ServiceInstance from the LoadBalancer for the specified service.\n\t * @param serviceId The service ID to look up the LoadBalancer.\n\t * @return A ServiceInstance that matches the serviceId.\n\t */\n\tServiceInstance choose(String serviceId);\n\n```\n\n\n\n我们注入这个类的对象，然后对其测试：\n\n创建测试方法\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringcloudEurekaServiceConsumerApplicationTests {\n\n    @Autowired\n    private RibbonLoadBalancerClient loadBalanceClient;\n\n    @Test\n    public void contextLoads() {\n    }\n\n    @Test\n    public void testLoadBalance() {\n        for (int i = 0; i < 50; i++) {\n            ServiceInstance instance = loadBalanceClient.choose(\"service-provider\");\n            System.out.println(instance.getPort());\n        }\n    }\n\n}\n\n```\n\n运行后明显可以看出，就是轮询\n\n\n\n## 修改负载均衡规则\n\nSpringBoot也帮我们提供了修改负载均衡规则的配置入口，在`springcloud-eureka-service-consumer`的application.yaml中添加如下配置：\n\n```yaml\nservice-provider:\n  ribbon:\n    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule\n```\n\n格式是：`{服务名称}.ribbon.NFLoadBalancerRuleClassName`，值就是IRule的实现类。\n\n负载均衡规则(IRule)有图中几个实现\n\n![1574754059660](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574754059660.png)\n\n\n\n\n\n再次测试，就变成随机的了\n\n\n\n## 重试机制\n\nEureka的服务治理强调了CAP原则中的AP，即可用性和可靠性。它与Zookeeper这一类强调CP（一致性，可靠性）的服务治理框架最大的区别在于：Eureka为了实现更高的服务可用性，牺牲了一定的一致性，极端情况下它宁愿接收故障实例也不愿丢掉健康实例，正如我们上面所说的自我保护机制。\n\n但是，此时如果我们调用了这些不正常的服务，调用就会失败，从而导致其它服务不能正常工作！这显然不是我们愿意看到的。\n\n我们现在关闭一个服务实例，关闭8084端口：\n\n![1574758231721](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574758231721.png)\n\n此时再次访问你会得到错误提示\n\n![1574758211036](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574758211036.png)\n\n但是此时，8081服务其实是正常的。\n\n因此Spring Cloud 整合了Spring Retry 来增强RestTemplate的重试能力，当一次服务调用失败后，不会立即抛出一次，而是再次重试另一个服务。\n\n只需要简单配置即可实现Ribbon的重试：\n\n但是此时，8081服务其实是正常的。\n\n因此Spring Cloud 整合了Spring Retry 来增强RestTemplate的重试能力，当一次服务调用失败后，不会立即抛出一次，而是再次重试另一个服务。\n\n只需要简单配置即可实现Ribbon的重试：\n\n> 添加spring-retry依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.retry</groupId>\n    <artifactId>spring-retry</artifactId>\n</dependency>\n```\n\n\n\n```yaml\nserver:\n  port: 8083\nspring:\n  application:\n    name: service-consumer\n  cloud:\n    loadbalancer:\n      retry:\n        enabled: true #开启Spring Cloud的重试功能，默认就是true\neureka:\n  client:\n    service-url:\n      defaultZone: http://127.0.0.1:10001/eureka\n```\n\n","tags":["springcloud"],"categories":["springcloud"]},{"title":"系统架构演变","url":"/2020/05/23/springCloud/start/","content":"\n\n# 系统架构演变\n\n随着互联网的发展，网站应用的规模不断扩大。需求的激增，带来的是技术上的压力。系统架构也因此也不断的演进、升级、迭代。从单一应用，到垂直拆分，到分布式服务，到SOA，以及现在火热的微服务架构，还有在Google带领下来势汹涌的Service Mesh。我们到底是该乘坐微服务的船只驶向远方，还是偏安一隅得过且过？\n\n\n\n## 集中式架构\n\n当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键。\n\n ![1525529091749](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1525529091749.png)\n\n存在的问题：\n\n- 代码耦合，开发维护困难\n- 无法针对不同模块进行针对性优化\n- 无法水平扩展\n- 单点容错率低，并发能力差\n\n\n\n## 垂直拆分\n\n当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分：\n\n ![1525529671801](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1525529671801.png)\n\n优点：\n\n- 系统拆分实现了流量分担，解决了并发问题\n- 可以针对不同模块进行优化\n- 方便水平扩展，负载均衡，容错率提高\n\n缺点：\n\n- 系统间相互独立，会有很多重复开发工作，影响开发效率\n\n## 分布式服务\n\n当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式调用是关键。\n\n ![1525530657919](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1525530657919.png)\n\n优点：\n\n- 将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率\n\n缺点：\n\n- 系统间耦合度变高，调用关系错综复杂，难以维护\n\n\n\n## 服务治理（SOA）\n\n当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高集群利用率的资源调度和治理中心(SOA)是关键\n\n![1525530804753](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1525530804753.png)\n\n以前出现了什么问题？\n\n- 服务越来越多，需要管理每个服务的地址\n- 调用关系错综复杂，难以理清依赖关系\n- 服务过多，服务状态难以管理，无法根据服务情况动态管理\n\n服务治理要做什么？\n\n- 服务注册中心，实现服务自动注册和发现，无需人为记录服务地址\n- 服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系\n- 动态监控服务状态监控报告，人为控制服务状态\n\n缺点：\n\n- 服务间会有依赖关系，一旦某个环节出错会影响较大\n- 服务关系复杂，运维、测试部署困难，不符合DevOps思想\n\n## 微服务\n\n前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实有一些差别：\n\n![1525532344817](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1525532344817.png)\n\n微服务的特点：\n\n- 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责\n- 微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。\n- 面向服务：面向服务是说每个服务都要对外暴露服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。\n- 自治：自治是说服务间互相独立，互不干扰\n  - 团队独立：每个服务都是一个独立的开发团队，人数不能过多。\n  - 技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉\n  - 前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口\n  - 数据库分离：每个服务都使用自己的数据源\n  - 部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护\n\n\n\n微服务结构图：\n\n![1526860071166](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1526860071166.png)\n\n\n\n","tags":["springcloud"],"categories":["springcloud"]},{"title":"springboot自动配置原理","url":"/2020/05/23/springboot/autoconfig/","content":"\n# 自动配置原理\n\n配置文件到底能写什么？怎么写？自动配置原理；\n\n[配置文件能配置的属性参照](https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/reference/htmlsingle/#common-application-properties)\n\n\n\nSpringBoot启动的时候加载主配置类，开启了自动配置功能\n\n```\n@SpringBootApplication\n\t@EnableAutoConfiguration\n```\n\n\n\n## @EnableAutoConfiguration 作用\n\n- 利用EnableAutoConfigurationImportSelector给容器中导入一些组件\n\n- getAutoConfigurationEntry方法中\n\n  ```\n  //获取候选的配置\n  List<String> configurations = getCandidateConfigurations(annotationMetadata,attributes);\n  ```\n\n- getCandidateConfigurations方法中，SpringFactoriesLoader.loadFactoryNames()，扫描所有jar包类路径下  `META-INF/spring.factories`，把扫描到的这些文件的内容包装成properties对象，从properties中获取到EnableAutoConfiguration.class（类名）对应的值，然后把它们添加在容器中\n\n  ![1573805094643](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573805094643.png)\n\n- 每一个这样的  `xxxAutoConfiguration`类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；\n\n- 每一个自动配置类进行自动配置功能；\n\n\n\n## 以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理\n\n\n\n```java\npackage org.springframework.boot.autoconfigure.web.servlet;\n\n......\n\n//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件\n@Configuration(\n    proxyBeanMethods = false\n)\n\n/**\n * 启动指定类的ConfigurationProperties功能；\n * 将配置文件中对应的值和HttpProperties绑定起来；\n * 并把HttpProperties加入到ioc容器中\n */\n@EnableConfigurationProperties({HttpProperties.class})\n\n/**\n * Spring底层@Conditional注解\n * 根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；\n * 判断当前应用是否是web应用，如果是，当前配置类生效\n */\n@ConditionalOnWebApplication(\n    type = Type.SERVLET\n)\n\n//判断当前项目有没有这个类\n@ConditionalOnClass({CharacterEncodingFilter.class})\n\n/**\n * 判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的\n * 即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；\n */\n@ConditionalOnProperty(\n    prefix = \"spring.http.encoding\",\n    value = {\"enabled\"},\n    matchIfMissing = true\n)\npublic class HttpEncodingAutoConfiguration {\n    \n    //它已经和SpringBoot的配置文件映射了\n    private final Encoding properties;\n\n    //只有一个有参构造器的情况下，参数的值就会从容器中拿\n    public HttpEncodingAutoConfiguration(HttpProperties properties) {\n        this.properties = properties.getEncoding();\n    }\n\n    @Bean\t //给容器中添加一个组件，这个组件的某些值需要从properties中获取\n    @ConditionalOnMissingBean\t//判断容器有没有这个组件？（容器中没有才会添加这个组件）\n    public CharacterEncodingFilter characterEncodingFilter() {\n        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();\n        filter.setEncoding(this.properties.getCharset().name());\n        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));\n        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));\n        return filter;\n    }\n\n    ......\n```\n\n1. 根据当前不同的条件判断，决定这个配置类是否生效\n2. 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；\n\n**所有在配置文件中能配置的属性都是在`xxxxProperties`类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类**\n\n```java\n@ConfigurationProperties(\n    prefix = \"spring.http\"\n)\npublic class HttpProperties {\n    private boolean logRequestDetails;\n    private final HttpProperties.Encoding encoding = new HttpProperties.Encoding();\n```\n\n\n\n\n\n## 总结\n\n- SpringBoot启动会加载大量的自动配置类\n- 我们看我们需要的功能有没有SpringBoot默认写好的自动配置类\n- 再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）\n- 给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值\n\n\n\n`xxxxAutoConfigurartion`：自动配置类；\n\n`xxxxProperties`:封装配置文件中相关属性；\n\n\n\n## @Conditional派生注解\n\n作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；\n\n| @Conditional扩展注解            | 作用（判断是否满足当前指定条件）                 |\n| ------------------------------- | ------------------------------------------------ |\n| @ConditionalOnJava              | 系统的java版本是否符合要求                       |\n| @ConditionalOnBean              | 容器中存在指定Bean；                             |\n| @ConditionalOnMissingBean       | 容器中不存在指定Bean；                           |\n| @ConditionalOnExpression        | 满足SpEL表达式指定                               |\n| @ConditionalOnClass             | 系统中有指定的类                                 |\n| @ConditionalOnMissingClass      | 系统中没有指定的类                               |\n| @ConditionalOnSingleCandidate   | 容器中只有一个指定的Bean，或者这个Bean是首选Bean |\n| @ConditionalOnProperty          | 系统中指定的属性是否有指定的值                   |\n| @ConditionalOnResource          | 类路径下是否存在指定资源文件                     |\n| @ConditionalOnWebApplication    | 当前是web环境                                    |\n| @ConditionalOnNotWebApplication | 当前不是web环境                                  |\n| @ConditionalOnJndi              | JNDI存在指定项                                   |\n\n\n\n## 查看那些自动配置类生效了\n\n自动配置类必须在一定的条件下才能生效；\n\n我们怎么知道哪些自动配置类生效了；\n\n我们可以通过配置文件启用  `debug=true`属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；\n\n- `Positive matches ` ：（自动配置类启用的）\n- `Negative matches`：（没有启动，没有匹配成功的自动配置类）\n\n","tags":["springboot"],"categories":["springboot"]},{"title":"远程调用方式","url":"/2020/05/23/springCloud/rpc/","content":"\n# 远程调用方式\n\n无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？\n\n常见的远程调用方式有以下几种：\n\n- `RPC`：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型\n\n- `Http`：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。\n\n  现在热门的Rest风格，就可以通过http协议来实现。\n\n\n\n## 认识RPC\n\nRPC，即 Remote Procedure Call（远程过程调用），是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。说得通俗一点就是：A计算机提供一个服务，B计算机可以像调用本地服务那样调用A计算机的服务。\n\n通过上面的概念，我们可以知道，实现RPC主要是做到两点： \n\n1. 实现远程调用其他计算机的服务\n\n   要实现远程调用，肯定是通过网络传输数据。A程序提供服务，B程序通过网络将请求参数传递给A，A本地执行后得到结果，再将结果返回给B程序。这里需要关注的有两点：\n\n   - 采用何种网络通讯协议？\n\n     现在比较流行的RPC框架，都会采用TCP作为底层传输协议\n\n   - 数据传输的格式怎样？\n\n     两个程序进行通讯，必须约定好数据传输格式。就好比两个人聊天，要用同一种语言，否则无法沟通。所以，我们必须定义好请求和响应的格式。另外，数据在网路中传输需要进行序列化，所以还需要约定统一的序列化的方式。\n\n2. 要像调用本地服务一样调用远程服务\n\n   如果仅仅是远程调用，还不算是RPC，因为RPC强调的是过程调用，调用的过程对用户而言是应该是透明的，用户不应该关心调用的细节，可以像调用本地服务一样调用远程服务。所以RPC一定要对调用的过程进行封装\n\n\n\nRPC调用流程图：\n\n![1525568965976](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1525568965976.png)\n\n想要了解详细的RPC实现，给大家推荐一篇文章：[自己动手实现RPC](https://legacy.gitbook.com/book/huge0612/tour-of-rpc/details)\n\n\n\n## 认识Http\n\nHttp协议：超文本传输协议，是一种应用层协议。规定了网络传输的请求格式、响应格式、资源定位和操作的方式等。但是底层采用什么网络传输协议，并没有规定，不过现在都是采用TCP协议作为底层传输协议。说到这里，大家可能觉得，Http与RPC的远程调用非常像，都是按照某种规定好的数据格式进行网络通信，有请求，有响应。没错，在这点来看，两者非常相似，但是还是有一些细微差别。\n\n- RPC并没有规定数据传输格式，这个格式可以任意指定，不同的RPC协议，数据格式不一定相同。\n- Http中还定义了资源定位的路径，RPC中并不需要\n- 最重要的一点：RPC需要满足像调用本地服务一样调用远程服务，也就是对调用过程在API层面进行封装。Http协议没有这样的要求，因此请求、响应等细节需要我们自己去实现。\n  - 优点：RPC方式更加透明，对用户更方便。Http方式更灵活，没有规定API和语言，跨语言、跨平台\n  - 缺点：RPC方式需要在API层面进行封装，限制了开发的语言环境。\n\n例如我们通过浏览器访问网站，就是通过Http协议。只不过浏览器把请求封装，发起请求以及接收响应，解析响应的事情都帮我们做了。如果是不通过浏览器，那么这些事情都需要自己去完成。\n\n![1525569352313](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1525569352313.png)\n\n\n\n## 如何选择？\n\n既然两种方式都可以实现远程调用，我们该如何选择呢？\n\n- 速度来看，RPC要比http更快，虽然底层都是TCP，但是http协议的信息往往比较臃肿，不过可以采用gzip压缩。\n- 难度来看，RPC实现较为复杂，http相对比较简单\n- 灵活性来看，http更胜一筹，因为它不关心实现细节，跨平台、跨语言。\n\n因此，两者都有不同的使用场景：\n\n- 如果对效率要求更高，并且开发过程使用统一的技术栈，那么用RPC还是不错的。\n- 如果需要更加灵活，跨语言、跨平台，显然http更合适\n\n\n\n那么我们该怎么选择呢？\n\n微服务，更加强调的是独立、自治、灵活。而RPC方式的限制较多，因此微服务框架中，一般都会采用基于Http的Rest风格服务。\n\n\n\n## Http客户端工具\n\n既然微服务选择了Http，那么我们就需要考虑自己来实现对请求和响应的处理。不过开源世界已经有很多的http客户端工具，能够帮助我们做这些事情，例如：\n\n- HttpClient\n- OKHttp\n- URLConnection\n\n接下来，我们就一起了解一款比较流行的客户端工具：`HttpClient`\n\n\n\n## HttpClient\n\n`HttpClient`是Apache公司的产品，是`Http Components`下的一个组件。\n\n### 特点\n\n- 基于标准、纯净的Java语言。实现了Http1.0和Http1.1\n- 以可扩展的面向对象的结构实现了Http全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE）\n- 支持HTTPS协议。\n- 通过Http代理建立透明的连接。\n- 自动处理Set-Cookie中的Cookie。\n\n\n\n### 使用\n\n#### 提供服务\n\n1. 创建数据库，运行sql脚本创建`tb_user`表，随便添加几条数据\n\n   ```sql\n   DROP TABLE IF EXISTS `tb_user`;\n   CREATE TABLE `tb_user` (\n     `id` bigint(20) NOT NULL AUTO_INCREMENT,\n     `username` varchar(50) NOT NULL COMMENT '用户名',\n     `password` varchar(32) NOT NULL COMMENT '密码，加密存储',\n     `phone` varchar(20) DEFAULT NULL COMMENT '注册手机号',\n     `created` datetime NOT NULL COMMENT '创建时间',\n     PRIMARY KEY (`id`),\n     UNIQUE KEY `username` (`username`) USING BTREE\n   ) ENGINE=InnoDB AUTO_INCREMENT=28 DEFAULT CHARSET=utf8 COMMENT='用户表';\n   ```\n\n2. 创建SpringBoot项目1 `httpClientService`用于提供服务\n\n   引入web场景和mysql驱动以及通用mapper场景\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n       <modelVersion>4.0.0</modelVersion>\n       <parent>\n           <groupId>org.springframework.boot</groupId>\n           <artifactId>spring-boot-starter-parent</artifactId>\n           <version>2.2.1.RELEASE</version>\n           <relativePath/> <!-- lookup parent from repository -->\n       </parent>\n       <groupId>cn.clboy</groupId>\n       <artifactId>httpclientservice</artifactId>\n       <version>0.0.1-SNAPSHOT</version>\n       <name>httpclientservice</name>\n       <description>Demo project for Spring Boot</description>\n   \n       <properties>\n           <java.version>1.8</java.version>\n       </properties>\n   \n       <dependencies>\n           <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-starter-web</artifactId>\n           </dependency>\n   \n           <dependency>\n               <groupId>mysql</groupId>\n               <artifactId>mysql-connector-java</artifactId>\n               <scope>runtime</scope>\n           </dependency>\n   \n           <dependency>\n               <groupId>tk.mybatis</groupId>\n               <artifactId>mapper-spring-boot-starter</artifactId>\n               <version>2.1.5</version>\n           </dependency>\n   \n       <build>\n           <plugins>\n               <plugin>\n                   <groupId>org.springframework.boot</groupId>\n                   <artifactId>spring-boot-maven-plugin</artifactId>\n               </plugin>\n           </plugins>\n       </build>\n   \n   </project>\n   \n   ```\n\n   配置数据库连接信息\n\n   ```yaml\n   spring:\n     datasource:\n       url: jdbc:mysql://localhost:3306/leyoumall\n       username: root\n       password: root\n       driver-class-name: com.mysql.cj.jdbc.Driver\n   ```\n\n   \n\n3. 创建`TbUser`实体类\n\n   ```java\n   package cn.clboy.httpclientservice.pojo;\n   \n   import javax.persistence.*;\n   import java.util.Date;\n   \n   @Table(name = \"tb_user\")\n   public class TbUser {\n   \n       @Id\n       @GeneratedValue(strategy = GenerationType.IDENTITY)\n       private Long id;\n       private String username;\n       private String password;\n       private String phone;\n       private Date created;\n       \n       //getter setter方法\t......\n   \n   ```\n\n4. 创建`Mapper`继承`通用mapper`，添加`@mapper`注解\n\n   ```java\n   package cn.clboy.httpclientservice.Mapper;\n   \n   import cn.clboy.httpclientservice.pojo.TbUser;\n   import tk.mybatis.mapper.common.Mapper;\n   \n   @org.apache.ibatis.annotations.Mapper\n   public interface UserMapper extends Mapper<TbUser> {\n   \n   }\n   ```\n\n5. 创建Controller\n\n   ```java\n   @RestController\n   public class UserController {\n   \n       @Autowired\n       private UserMapper userMapper;\n   \n       @GetMapping(\"/user\")\n       public List<TbUser> users() {\n           return userMapper.selectAll();\n       }\n   \n       @PostMapping(\"/user\")\n       public TbUser add(TbUser user) {\n           userMapper.insert(user);\n           return user;\n       }\n   }\n   ```\n\n6. 访问：<http://localhost:8080/user>，访问成功下一步\n\n\n\n#### 调用服务\n\n1. 创建`httpClientConsumer`项目调用`httpClientService`的服务\n\n2. 引入httpclient依赖\n\n   ```xml\n   <dependency>\n       <groupId>org.apache.httpcomponents</groupId>\n       <artifactId>httpclient</artifactId>\n       <version>4.5.10</version>\n   </dependency>\n   ```\n\n3. 测试\n\n   ```java\n   @SpringBootTest\n   class HttpclientconsumerApplicationTests {\n   \n       //1. 安装浏览器\n       public CloseableHttpClient httpClient;\n   \n       @BeforeEach\n       public void init() {\n           //2. 打开浏览器\n           httpClient = HttpClients.createDefault();\n       }\n   \n       @Test\n       public void get() throws IOException {\n           //2. 创建get请求\n           HttpGet getRequest = new HttpGet(\"http://localhost:8080/user\");\n           String response = httpClient.execute(getRequest, new BasicResponseHandler());\n           System.out.println(response);\n       }\n   \n       @Test\n       public void post() throws IOException {\n           //创建post请求\n           HttpPost postRequest = new HttpPost(\"http://localhost:8080/user\");\n           //表单数据\n           List<NameValuePair> formparams = new ArrayList<NameValuePair>();\n           formparams.add(new BasicNameValuePair(\"username\", \"zhangsan\"));\n           formparams.add(new BasicNameValuePair(\"password\", \"123456\"));\n           formparams.add(new BasicNameValuePair(\"phone\", \"13945126789\"));\n           formparams.add(new BasicNameValuePair(\"created\", \"2019/10/01\"));\n   \n           UrlEncodedFormEntity entity = new UrlEncodedFormEntity(formparams, \"utf-8\");\n           postRequest.setEntity(entity);\n   \n           String response = httpClient.execute(postRequest, new BasicResponseHandler());\n           System.out.println(response);\n           \n       }\n   \n   }\n   ```\n\n\n\n## Json转换工具(Jackson)\n\nHttpClient请求数据后是json字符串，需要我们自己把Json字符串反序列化为对象，我们可以使用Jackson工具来实现。\n\n`Jackson`是SpringMVC内置的json处理工具，其中有一个`ObjectMapper`类，可以方便的实现对json的处理：\n\n### 对象转json\n\n```java\n@SpringBootTest\nclass HttpclientserviceApplicationTests {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Test\n    void contextLoads() throws JsonProcessingException {\n        TbUser user = userMapper.selectByPrimaryKey(1);\n\n        ObjectMapper mapper=new ObjectMapper();\n        //序列化\n        String jsonStr = mapper.writeValueAsString(user);\n        System.out.println(jsonStr);\n    }\n\n}\n```\n\n\n\n### json转普通对象\n\n在服务调用项目中放一份User类，添加jackson的依赖\n\n```java\npublic class TbUser {\n    private Long id;\n    private String username;\n    private String password;\n    private String phone;\n    private Date created;\n    \n    //getter,setter......\n}\n```\n\n```xml\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n            <version>2.10.1</version>\n        </dependency>\n```\n\n```java\n    @Test\n    public void post() throws IOException {\n        \n        //......\n\n        String response = httpClient.execute(postRequest, new BasicResponseHandler());\n\n        ObjectMapper mapper = new ObjectMapper();\n        TbUser tbUser = mapper.readValue(response, TbUser.class);\n        System.out.println(tbUser);\n    }\n```\n\n\n\n### json转集合\n\njson转集合比较麻烦，因为你无法同时把集合的class和元素的class同时传递到一个参数。\n\n因此Jackson做了一个类型工厂，用来解决这个问题：\n\n```java\n    @Test\n    public void get() throws IOException {\n        //2. 创建get请求\n        HttpGet getRequest = new HttpGet(\"http://localhost:8080/user\");\n        String response = httpClient.execute(getRequest, new BasicResponseHandler());\n\n        ObjectMapper mapper = new ObjectMapper();\n        CollectionLikeType type = mapper.getTypeFactory().constructCollectionType(List.class, TbUser.class);\n        List<TbUser> users = mapper.readValue(response, type);\n        System.out.println(users);\n    }\n```\n\n\n\n### json转任意复杂类型\n\n当对象泛型关系复杂时，类型工厂也不好使了。这个时候Jackson提供了TypeReference来接收类型泛型，然后底层通过反射来获取泛型上的具体类型。实现数据转换。\n\n\n\n```java\n    @Test\n    public void testJsonToMap() throws IOException {\n        Map<String, Object> map = new HashMap<>();\n\n        ObjectMapper mapper = new ObjectMapper();\n        TypeReference<List<TbUser>> listTypeReference = new TypeReference<List<TbUser>>() {\n        };\n\n        //使用TypeReference，它是一个抽象类\n        List<TbUser> users = mapper.readValue(new URL(\"http://localhost:8080/user\"), listTypeReference);\n\n        for (TbUser user : users) {\n            map.put(user.getUsername(), user);\n        }\n\n        //序列化\n        String mapJson = mapper.writeValueAsString(map);\n        System.out.println(mapJson);\n\n        //反序列化，使用类型工厂\n        Map<String, Object> result = mapper.readValue(mapJson, mapper.getTypeFactory().constructMapType(HashMap.class, String.class, TbUser.class));\n\n\n        System.out.println(result);\n\n    }\n```\n\n\n\n## Spring的RestTemplate\n\nSpring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和反序列化，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持：\n\n- HttpClient\n- OkHttp\n- JDK原生的URLConnection（默认的）\n\n首先在项目中注册一个`RestTemplate`对象，可以在启动类位置注册：\n\n要使用RestTemplate，需要映入web场景，web场景包括Jackson，所以可以把开始引入的Jackson依赖删掉了\n\n给调用服务的项目添加web场景\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n\n给容器中添加`RestTemplate`\n\n```java\n@SpringBootApplication\npublic class HttpclientconsumerApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HttpclientconsumerApplication.class, args);\n    }\n\n    @Bean\n    public RestTemplate resttemplate() {\n        return new RestTemplate();\n    }\n}\n```\n\n测试\n\n```java\n@SpringBootTest\nclass HttpclientconsumerApplicationTests {\n\n    @Autowired\n    private RestTemplate restTemplate;\n\n    @Test\n    public void restTemplateGet() {\n        List<TbUser> users = restTemplate.getForObject(\"http://localhost:8080/user\", List.class);\n        System.out.println(\"users --> \" + users);\n    }\n\n}\n```\n\n","tags":["springcloud"],"categories":["springcloud"]},{"title":"springboot配置Servlet容器","url":"/2020/05/23/springboot/configservletcontainer/","content":"\n# 配置嵌入式Servlet容器\n\n## 如何定制和修改Servlet容器的相关配置\n\n1. 修改和server有关的配置\n\n   ```properties\n   server.port=8081\n   server.context-path=/crud\n   \n   server.tomcat.uri-encoding=UTF-8\n   \n   //通用的Servlet容器设置\n   server.xxx\n   //Tomcat的设置\n   server.tomcat.xxx\n   ```\n\n2. 编写一个~~EmbeddedServletContainerCustomizer~~，2.0以后改为`WebServerFactoryCustomizer`：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置\n\n   ```java\n   @Configuration\n   public class MyMvcConfig implements WebMvcConfigurer {\n   \t@Bean\n       public WebServerFactoryCustomizer webServerFactoryCustomizer() {\n           return new WebServerFactoryCustomizer<ConfigurableWebServerFactory>() {\n               @Override\n               public void customize(ConfigurableWebServerFactory factory) {\n                   factory.setPort(8088);\n               }\n           };\n       }\n   ......\n   ```\n\n   \n\n!> 代码方式的配置会覆盖配置文件的配置\n\n?> *小Tips：*  如果使用的是360极速浏览器就不要用8082端口了\n\n\n\n## 注册Servlet三大组件\n\n由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。\n\n### Servlet\n\n向容器中添加ServletRegistrationBean\n\n```java\n@Configuration\npublic class MyMvcConfig implements WebMvcConfigurer {\n\n    @Bean\n    public ServletRegistrationBean myServlet() {\n        ServletRegistrationBean register = new ServletRegistrationBean(new MyServlet(), \"/myServlet\");\n        register.setLoadOnStartup(1);\n        return register;\n    }\n    ......\n```\n\n<details>\n<summary>MyServlet</summary>\n\n```java\npublic class MyServlet extends HttpServlet {\n\n    @Override\n    public void init() throws ServletException {\n        System.out.println(\"servlet初始化\");\n    }\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        this.doPost(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        resp.getWriter().write(\"this is MyServlet\");\n    }\n\n}\n```\n\n</details>\n\n\n\n\n\n### Filter\n\n向容器中添加FilterRegistrationBean\n\n```java\n@Configuration\npublic class MyMvcConfig implements WebMvcConfigurer {\n\n\n    @Bean\n    public FilterRegistrationBean myFilter() {\n        FilterRegistrationBean register = new FilterRegistrationBean(new MyFilter());\n        register.setUrlPatterns(Arrays.asList(\"/myServlet\",\"/\"));\n        return register;\n    }\n    \n    ......\n```\n\n\n\n<details>\n<summary>MyFilter</summary>\n\n```java\npublic class MyFilter extends HttpFilter {\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        response.getWriter().write(\"请求被拦截......\");\n    }\n}\n```\n\n</details>\n\n\n\n### Listener\n\n向容器中注入ServletListenerRegistrationBean\n\n```java\n@Configuration\npublic class MyMvcConfig implements WebMvcConfigurer {\n\n    @Bean\n    public ServletListenerRegistrationBean myServletContextListener(){\n        return new ServletListenerRegistrationBean(new MyServletContextListener());\n    }\n    \n    ......\n\n```\n\n<details>\n<summary>MyListener</summary>\n\n```java\npublic class MyServletContextListener implements ServletContextListener {\n    @Override\n    public void contextInitialized(ServletContextEvent sce) {\n        System.out.println(\"web容器   启动......\");\n    }\n\n    @Override\n    public void contextDestroyed(ServletContextEvent sce) {\n        System.out.println(\"web容器   销毁......\");\n    }\n}\n```\n\n</details>\n\n\n\n## 替换为其他嵌入式web服务器\n\nSpringBoot默认使用的是Tomcat\n\n![1574170320042](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574170320042.png)\n\n如果要换成其他的就把Tomcat的依赖排除掉，然后引入其他嵌入式Servlet容器的以来，如`Jetty`，`Undertow`\n\n```xml\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n            <exclusions>\n                <exclusion>\n                    <artifactId>spring-boot-starter-tomcat</artifactId>\n                    <groupId>org.springframework.boot</groupId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n\n        <dependency>\n            <artifactId>spring-boot-starter-jetty</artifactId>\n            <groupId>org.springframework.boot</groupId>\n        </dependency>\n```\n\n```xml\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n            <exclusions>\n                <exclusion>\n                    <artifactId>spring-boot-starter-tomcat</artifactId>\n                    <groupId>org.springframework.boot</groupId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n\n        <dependency>\n            <artifactId>spring-boot-starter-undertow</artifactId>\n            <groupId>org.springframework.boot</groupId>\n        </dependency>\n```\n\n### 原理\n\n**查看web容器自动配置类**\n\n2.0以下是：~~*EmbeddedServletContainerAutoConfiguration*~~\n\n`ServletWebServerFactoryAutoConfiguration`：嵌入式的web服务器自动配置\n\n```java\n@Configuration(\n    proxyBeanMethods = false\n)\n@AutoConfigureOrder(-2147483648)\n@ConditionalOnClass({ServletRequest.class})\n@ConditionalOnWebApplication(\n    type = Type.SERVLET\n)\n@EnableConfigurationProperties({ServerProperties.class})\n\n//---看这里---\n@Import({ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class, EmbeddedTomcat.class, EmbeddedJetty.class, EmbeddedUndertow.class})\npublic class ServletWebServerFactoryAutoConfiguration {\n```\n\n`EmbeddedTomcat.class`：\n\n```java\n    @Configuration(\n        proxyBeanMethods = false\n    )\n\t//判断当前是否引入了Tomcat依赖；\n    @ConditionalOnClass({Servlet.class, Tomcat.class, UpgradeProtocol.class})\n\t/**\n\t  *判断当前容器没有用户自己定义ServletWebServerFactory：嵌入式的web服务器工厂；\n\t  *作用：创建嵌入式的web服务器\n\t  */\n    @ConditionalOnMissingBean(\n        value = {ServletWebServerFactory.class},\n        search = SearchStrategy.CURRENT\n    )\n    public static class EmbeddedTomcat {\n```\n\n`ServletWebServerFactory`：嵌入式的web服务器工厂\n\n```java\n@FunctionalInterface\npublic interface ServletWebServerFactory {\n    //获取嵌入式的Servlet容器\n    WebServer getWebServer(ServletContextInitializer... initializers);\n}\n```\n\n工厂实现类\n\n![1574172121748](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574172121748.png)\n\n`WebServer`：嵌入式的web服务器实现\n\n![1574172310812](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574172310812.png)\n\n以`TomcatServletWebServerFactory`为例，下面是TomcatServletWebServerFactory类\n\n```java\n    public WebServer getWebServer(ServletContextInitializer... initializers) {\n        if (this.disableMBeanRegistry) {\n            Registry.disableRegistry();\n        }\n\n        //创建一个Tomcat\n        Tomcat tomcat = new Tomcat();\n        \n        //配置Tomcat的基本环境，（tomcat的配置都是从本类获取的，tomcat.setXXX）\n        File baseDir = this.baseDirectory != null ? this.baseDirectory : this.createTempDir(\"tomcat\");\n        tomcat.setBaseDir(baseDir.getAbsolutePath());\n        Connector connector = new Connector(this.protocol);\n        connector.setThrowOnFailure(true);\n        tomcat.getService().addConnector(connector);\n        this.customizeConnector(connector);\n        tomcat.setConnector(connector);\n        tomcat.getHost().setAutoDeploy(false);\n        this.configureEngine(tomcat.getEngine());\n        Iterator var5 = this.additionalTomcatConnectors.iterator();\n\n        while(var5.hasNext()) {\n            Connector additionalConnector = (Connector)var5.next();\n            tomcat.getService().addConnector(additionalConnector);\n        }\n\n        this.prepareContext(tomcat.getHost(), initializers);\n        \n        //将配置好的Tomcat传入进去，返回一个WebServer；并且启动Tomcat服务器\n        return this.getTomcatWebServer(tomcat);\n    }\n```\n\n\n\n我们对嵌入式容器的配置修改是怎么生效的？\n\n### 配置修改原理\n\n`ServletWebServerFactoryAutoConfiguration`在向容器中添加web容器时还添加了一个组件\n\n![1574235580031](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574235580031.png)\n\n`BeanPostProcessorsRegistrar`：后置处理器注册器(也是给容器注入一些组件)\n\n```java\n    public static class BeanPostProcessorsRegistrar implements ImportBeanDefinitionRegistrar, BeanFactoryAware {\n        private ConfigurableListableBeanFactory beanFactory;\n\n        public BeanPostProcessorsRegistrar() {...}\n\n        public void setBeanFactory(BeanFactory beanFactory) throws BeansException {...}\n\n        public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n            if (this.beanFactory != null) {\n                //注册了下面两个组件\n                this.registerSyntheticBeanIfMissing(registry, \"webServerFactoryCustomizerBeanPostProcessor\", WebServerFactoryCustomizerBeanPostProcessor.class);\n                this.registerSyntheticBeanIfMissing(registry, \"errorPageRegistrarBeanPostProcessor\", ErrorPageRegistrarBeanPostProcessor.class);\n            }\n        }\n\n        private void registerSyntheticBeanIfMissing(BeanDefinitionRegistry registry, String name, Class<?> beanClass) {...}\n    }\n```\n\n`webServerFactoryCustomizerBeanPostProcessor`\n\n```java\npublic class WebServerFactoryCustomizerBeanPostProcessor implements BeanPostProcessor, BeanFactoryAware {\n    \n    ......\n        \n    //在Bean初始化之前\n\tpublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        //判断添加的Bean是不是WebServerFactory类型的\n        if (bean instanceof WebServerFactory) {\n            this.postProcessBeforeInitialization((WebServerFactory)bean);\n        }\n\n        return bean;\n    }\n\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        return bean;\n    }\n\n    private void postProcessBeforeInitialization(WebServerFactory webServerFactory) {\n        //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值；\n        ((Callbacks)LambdaSafe.callbacks(WebServerFactoryCustomizer.class, this.getCustomizers(), webServerFactory, new Object[0]).withLogger(WebServerFactoryCustomizerBeanPostProcessor.class)).invoke((customizer) -> {\n            customizer.customize(webServerFactory);\n        });\n    }\n```\n\n关于配置文件是如何设置的，参考`EmbeddedWebServerFactoryCustomizerAutoConfiguration`类，最后还是使用上面的方便\n\n\n\n总结：\n\n1. SpringBoot根据导入的依赖情况，给容器中添加相应的`XXX`ServletWebServerFactory\n\n2. 容器中某个组件要创建对象就会惊动后置处理器 `webServerFactoryCustomizerBeanPostProcessor`\n\n   只要是嵌入式的是Servlet容器工厂，后置处理器就会工作；\n\n3. 后置处理器，从容器中获取所有的`WebServerFactoryCustomizer`，调用定制器的定制方法给工厂添加配置\n\n\n\n## 嵌入式Servlet容器启动原理\n\n1. SpringBoot应用启动运行run方法\n\n   ![1574242390909](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574242390909.png)\n\n2. 153行，创建IOC容器对象，根据当前环境创建\n\n   ![1574242209298](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574242209298.png)\n\n3. 156行，刷新IOC容器\n\n4. 刷新IOC容器中272行，onRefresh()；web的ioc容器重写了onRefresh方法，查看`ServletWebServerApplicationContext`类的onRefresh方法，在方法中调用了this.createWebServer();方法创建web容器\n\n   ```java\n       protected void onRefresh() {\n           super.onRefresh();\n   \n           try {\n               this.createWebServer();\n           } catch (Throwable var2) {\n               throw new ApplicationContextException(\"Unable to start web server\", var2);\n           }\n       }\n   ```\n\n   98行获取嵌入式的web容器工厂\n\n   ![1574243084120](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574243084120.png)\n\n5. 接下来就是上面的上面的相关配置流程，在创建web容器工厂时会触发`webServerFactoryCustomizerBeanPostProcessor`\n\n6. 然后99行**使用容器工厂获取嵌入式的Servlet容器**\n\n7. 嵌入式的Servlet容器创建对象并启动Servlet容器；\n\n8. 嵌入式的Servlet容器启动后，再将ioc容器中剩下没有创建出的对象获取出来(Controller,Service等)；\n\n\n\n## 使用外置的Servlet容器\n\n1. 将项目的打包方式改为war\n\n2. 编写一个类继承`SpringBootServletInitializer`，并重写configure方法，调用参数的sources方法springboot启动类传过去然后返回\n\n   ```java\n   public class ServletInitializer extends SpringBootServletInitializer {\n       @Override\n       protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {\n           return application.sources(HelloSpringBootWebApplication.class);\n       }\n   }\n   ```\n\n3. 然后把tomcat的依赖范围改为provided\n\n   ```xml\n       <dependencies>\n           <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-starter-web</artifactId>\n           </dependency>\n           <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-starter-tomcat</artifactId>\n               <version>2.2.1.RELEASE</version>\n               <scope>provided</scope>\n           </dependency>\n           \n           ......\n           \n   \t</dependencies>\n   ```\n\n   \n\n4. 最后就可以把项目打包成war放到tomcat中了\n\n5. 在IDEA中可以这样配置\n\n   ![1574247311250](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574247311250.png)\n\n6. 在创建项目时使用Spring Initializr创建选择打包方式为war，1，2，3步骤会自动配置\n\n!> 如果启动tomcat，报了一大堆错误，不妨把Tomcat改为更高的版本试试，如果你项目中的Filter是继承了HttpFilter，请使用tomcat9版本，9以下好像没有HttpFilter\n\n\n\n### 原理\n\n?> *TODO* 2019-11-20\n\n1. Servlet3.0标准ServletContainerInitializer扫描所有jar包中META\u0002INF/services/javax.servlet.ServletContainerInitializer文件指定的类并加载\n\n2. 还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类；\n\n3. 在spring-web-xxx.jar包中的META\u0002INF/services下有javax.servlet.ServletContainerInitializer这个文件\n\n   文件中的类是：\n\n   ```\n   org.springframework.web.SpringServletContainerInitializer\n   ```\n\n   对应的类：\n\n   ```java\n   @HandlesTypes({WebApplicationInitializer.class})\n   public class SpringServletContainerInitializer implements ServletContainerInitializer {\n       public SpringServletContainerInitializer() {\n       }\n   \n       public void onStartup(@Nullable Set<Class<?>> webAppInitializerClasses, ServletContext servletContext) throws ServletException {\n           \n           ......\n   ```\n\n4. SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的`Set<Class<?>>`；为这些WebApplicationInitializer类型的类创建实例；\n\n5. 每一个WebApplicationInitializer都调用自己的onStartup方法；\n\n6. WebApplicationInitializer的实现类\n\n   ![1574256076145](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574256076145.png)\n\n7. 相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法\n\n8. SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器\n\n   ```java\n   protected WebApplicationContext createRootApplicationContext(\n         ServletContext servletContext) {\n       //1、创建SpringApplicationBuilder\n      SpringApplicationBuilder builder = createSpringApplicationBuilder();\n      StandardServletEnvironment environment = new StandardServletEnvironment();\n      environment.initPropertySources(servletContext, null);\n      builder.environment(environment);\n      builder.main(getClass());\n      ApplicationContext parent = getExistingRootWebApplicationContext(servletContext);\n      if (parent != null) {\n         this.logger.info(\"Root context already created (using as parent).\");\n         servletContext.setAttribute(\n               WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null);\n         builder.initializers(new ParentContextApplicationContextInitializer(parent));\n      }\n      builder.initializers(\n            new ServletContextApplicationContextInitializer(servletContext));\n      builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class);\n       \n       //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来\n      builder = configure(builder);\n       \n       //使用builder创建一个Spring应用\n      SpringApplication application = builder.build();\n      if (application.getSources().isEmpty() && AnnotationUtils\n            .findAnnotation(getClass(), Configuration.class) != null) {\n         application.getSources().add(getClass());\n      }\n      Assert.state(!application.getSources().isEmpty(),\n            \"No SpringApplication sources have been defined. Either override the \"\n                  + \"configure method or add an @Configuration annotation\");\n      // Ensure error pages are registered\n      if (this.registerErrorPageFilter) {\n         application.getSources().add(ErrorPageFilterConfiguration.class);\n      }\n       //启动Spring应用\n      return run(application);\n   }\n   ```\n\n9. Spring的应用就启动并且创建IOC容器\n\n   ```java\n   public ConfigurableApplicationContext run(String... args) {\n      StopWatch stopWatch = new StopWatch();\n      stopWatch.start();\n      ConfigurableApplicationContext context = null;\n      FailureAnalyzers analyzers = null;\n      configureHeadlessProperty();\n      SpringApplicationRunListeners listeners = getRunListeners(args);\n      listeners.starting();\n      try {\n         ApplicationArguments applicationArguments = new DefaultApplicationArguments(\n               args);\n         ConfigurableEnvironment environment = prepareEnvironment(listeners,\n               applicationArguments);\n         Banner printedBanner = printBanner(environment);\n         context = createApplicationContext();\n         analyzers = new FailureAnalyzers(context);\n         prepareContext(context, environment, listeners, applicationArguments,\n               printedBanner);\n          \n          //刷新IOC容器\n         refreshContext(context);\n         afterRefresh(context, applicationArguments);\n         listeners.finished(context, null);\n         stopWatch.stop();\n         if (this.logStartupInfo) {\n            new StartupInfoLogger(this.mainApplicationClass)\n                  .logStarted(getApplicationLog(), stopWatch);\n         }\n         return context;\n      }\n      catch (Throwable ex) {\n         handleRunFailure(context, listeners, analyzers, ex);\n         throw new IllegalStateException(ex);\n      }\n   }\n   ```\n\n   \n\n","tags":["springboot"],"categories":["springboot"]},{"title":"springboot默认的错误处理机制","url":"/2020/05/23/springboot/errorhandler/","content":"\n# SpringBoot默认的错误处理机制\n\n当访问一个不存在的页面，或者程序抛出异常时\n\n**默认效果：**\n\n- 浏览器返回一个默认的错误页面，  注意看浏览器发送请求的`请求头`：\n\n  ![1573993746920](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573993746920.png)\n\n- 其他客户端返回json数据，注意看`请求头`\n\n  ![1573996455049](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573996455049.png)\n\n\n\n查看`org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration`源码，\n\n这里是springboot错误处理的自动配置信息\n\n**主要给日容器中注册了以下组件：**\n\n- ErrorPageCustomizer 系统出现错误以后来到error请求进行处理；相当于（web.xml注册的错误页面规则）\n- BasicErrorController 处理/error请求\n- DefaultErrorViewResolver 默认的错误视图解析器\n- DefaultErrorAttributes 错误信息\n- defaultErrorView 默认错误视图\n\n\n\n## ErrorPageCustomizer\n\n```java\n    @Bean\n    public ErrorMvcAutoConfiguration.ErrorPageCustomizer errorPageCustomizer(DispatcherServletPath dispatcherServletPath) {\n        return new ErrorMvcAutoConfiguration.ErrorPageCustomizer(this.serverProperties, dispatcherServletPath);\n    }\n```\n\n```java\n    private static class ErrorPageCustomizer implements ErrorPageRegistrar, Ordered {\n        private final ServerProperties properties;\n        private final DispatcherServletPath dispatcherServletPath;\n\n        protected ErrorPageCustomizer(ServerProperties properties, DispatcherServletPath dispatcherServletPath) {\n            this.properties = properties;\n            this.dispatcherServletPath = dispatcherServletPath;\n        }\n\n        //注册错误页面\n        public void registerErrorPages(ErrorPageRegistry errorPageRegistry) {\n            //getPath()获取到的是\"/error\"，见下图\n            ErrorPage errorPage = new ErrorPage(this.dispatcherServletPath.getRelativePath(this.properties.getError().getPath()));\n            errorPageRegistry.addErrorPages(new ErrorPage[]{errorPage});\n        }\n\n        public int getOrder() {\n            return 0;\n        }\n    }\n```\n\n![1573994730632](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573994730632.png)\n\n\n\n当请求出现错误后就会转发到`/error`\n\n\n\n然后这个error请求就会被BasicErrorController处理；\n\n## BasicErrorController\n\n```java\n    @Bean\n    @ConditionalOnMissingBean(\n        value = {ErrorController.class},\n        search = SearchStrategy.CURRENT\n    )\n    public BasicErrorController basicErrorController(ErrorAttributes errorAttributes, ObjectProvider<ErrorViewResolver> errorViewResolvers) {\n        return new BasicErrorController(errorAttributes, this.serverProperties.getError(), (List)errorViewResolvers.orderedStream().collect(Collectors.toList()));\n    }\n```\n\n处理`/error`请求\n\n```java\n@Controller\n/**\n  * 使用配置文件中server.error.path配置\n  * 如果server.error.path没有配置使用error.path\n  * 如果error.path也没有配置就使用/error\n  */\n@RequestMapping({\"${server.error.path:${error.path:/error}}\"})\npublic class BasicErrorController extends AbstractErrorController\n```\n\n![1573996271708](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573996271708.png)\n\n这两个方法一个用于浏览器请求响应html页面，一个用于其他客户端请求响应json数据\n\n处理浏览器请求的方法 中，modelAndView存储到哪个页面的页面地址和页面内容数据\n\n看一下调用的resolveErrorView方法\n\n```java\n    protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map<String, Object> model) {\n        Iterator var5 = this.errorViewResolvers.iterator();\n\n        ModelAndView modelAndView;\n        do {\n            if (!var5.hasNext()) {\n                return null;\n            }\n\n            ErrorViewResolver resolver = (ErrorViewResolver)var5.next();\n            //从所有的ErrorViewResolver得到ModelAndView\n            modelAndView = resolver.resolveErrorView(request, status, model);\n        } while(modelAndView == null);\n\n        return modelAndView;\n    }\n```\n\nErrorViewResolver从哪里来的呢？\n\n已经在容器中注册了一个DefaultErrorViewResolver\n\n## DefaultErrorViewResolver\n\n\n```java\n    @Configuration(\n        proxyBeanMethods = false\n    )\n    static class DefaultErrorViewResolverConfiguration {\n        private final ApplicationContext applicationContext;\n        private final ResourceProperties resourceProperties;\n\n        DefaultErrorViewResolverConfiguration(ApplicationContext applicationContext, ResourceProperties resourceProperties) {\n            this.applicationContext = applicationContext;\n            this.resourceProperties = resourceProperties;\n        }\n\n        //注册默认错误视图解析器\n        @Bean\n        @ConditionalOnBean({DispatcherServlet.class})\n        @ConditionalOnMissingBean({ErrorViewResolver.class})\n        DefaultErrorViewResolver conventionErrorViewResolver() {\n            return new DefaultErrorViewResolver(this.applicationContext, this.resourceProperties);\n        }\n    }\n```\n\n然后调用ErrorViewResolver的`resolveErrorView()`方法\n\n```java\n    public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map<String, Object> model) {\n        //把状态码和model传过去获取视图\n        ModelAndView modelAndView = this.resolve(String.valueOf(status.value()), model);\n        \n        //上面没有获取到视图就使用把状态吗替换再再找，以4开头的替换为4xx，5开头替换为5xx，见下文（如果定制错误响应）\n        if (modelAndView == null && SERIES_VIEWS.containsKey(status.series())) {\n            modelAndView = this.resolve((String)SERIES_VIEWS.get(status.series()), model);\n        }\n\n        return modelAndView;\n    }\n\n    private ModelAndView resolve(String viewName, Map<String, Object> model) {\n        //viewName传过来的是状态码，例：/error/404\n        String errorViewName = \"error/\" + viewName;\n        TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName, this.applicationContext);\n        //模板引擎可以解析这个页面地址就用模板引擎解析\n        return provider != null ? new ModelAndView(errorViewName, model) : this.resolveResource(errorViewName, model);\n    }\n```\n\n如果模板引擎不可用，就调用resolveResource方法获取视图\n\n```java\n    private ModelAndView resolveResource(String viewName, Map<String, Object> model) {\n        //获取的是静态资源文件夹\n        String[] var3 = this.resourceProperties.getStaticLocations();\n        int var4 = var3.length;\n\n        for(int var5 = 0; var5 < var4; ++var5) {\n            String location = var3[var5];\n\n            try {\n                Resource resource = this.applicationContext.getResource(location);\n                //例：static/error.html\n                resource = resource.createRelative(viewName + \".html\");\n                //存在则返回视图\n                if (resource.exists()) {\n                    return new ModelAndView(new DefaultErrorViewResolver.HtmlResourceView(resource), model);\n                }\n            } catch (Exception var8) {\n            }\n        }\n\n        return null;\n    }\n```\n\n\n\n\n**所以：**\n\n## 如何定制错误响应页面\n\n- 有模板引擎的情况下；将错误页面命名为  `错误状态码.html` 放在模板引擎文件夹里面的 error文件夹下发生此状态码的错误就会来到这里找对应的页面；\n\n  比如我们在template文件夹下创建error/404.html当浏览器请求是404错误，就会使用我们创建的404.html页面响应，如果是其他状态码错误，还是使用默认的视图，但是如果404.html没有找到就会替换成4XX.html再查找一次，看`DefaultErrorViewResolver`中的静态代码块\n\n  ```java\n      static {\n          Map<Series, String> views = new EnumMap(Series.class);\n          views.put(Series.CLIENT_ERROR, \"4xx\");\n          views.put(Series.SERVER_ERROR, \"5xx\");\n          SERIES_VIEWS = Collections.unmodifiableMap(views);\n      }\n  \n  .....\n   //再看解析方法\n              //把状态码和model传过去过去视图\n          ModelAndView modelAndView = this.resolve(String.valueOf(status.value()), model);\n          \n          //上面没有获取到视图就把状态吗替换再找，以4开头的替换为4xx，5开头替换为5xx，见下文（如果定制错误响应）\n          if (modelAndView == null && SERIES_VIEWS.containsKey(status.series())) {\n              modelAndView = this.resolve((String)SERIES_VIEWS.get(status.series()), model);\n          }\n  ```\n\n  **页面可以获取哪些数据**\n\n## DefaultErrorAttributes\n\n再看一下BasicErrorController的errorHtml方法\n\n```java\n    public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) {\n        HttpStatus status = this.getStatus(request);\n        \n        //model的数据\n        Map<String, Object> model = Collections.unmodifiableMap(this.getErrorAttributes(request, this.isIncludeStackTrace(request, MediaType.TEXT_HTML)));\n        response.setStatus(status.value());\n        ModelAndView modelAndView = this.resolveErrorView(request, response, status, model);\n        return modelAndView != null ? modelAndView : new ModelAndView(\"error\", model);\n    }\n```\n\n看一下调用的this.getErrorAttributes()方法\n\n```java\n    protected Map<String, Object> getErrorAttributes(HttpServletRequest request, boolean includeStackTrace) {\n        WebRequest webRequest = new ServletWebRequest(request);\n        return this.errorAttributes.getErrorAttributes(webRequest, includeStackTrace);\n    }\n```\n\n再看 this.errorAttributes.getErrorAttributes()方法， this.errorAttributes是接口类型ErrorAttributes，实现类就一个`DefaultErrorAttributes`，看一下`DefaultErrorAttributes`的 getErrorAttributes()方法\n\n```java\n    public Map<String, Object> getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) {\n        Map<String, Object> errorAttributes = new LinkedHashMap();\n        errorAttributes.put(\"timestamp\", new Date());\n        this.addStatus(errorAttributes, webRequest);\n        this.addErrorDetails(errorAttributes, webRequest, includeStackTrace);\n        this.addPath(errorAttributes, webRequest);\n        return errorAttributes;\n    }\n```\n\n- timestamp：时间戳\n- status：状态码\n- error：错误提示\n- exception：异常对象\n- message：异常消息\n- errors：JSR303数据校验的错误都在这里\n\n2.0以后默认是不显示exception的，需要在配置文件中开启\n\n```java\nserver.error.include-exception=true\n```\n\n原因：\n\n![1574001983704](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574001983704.png)\n\n在注册时\n\n![1574002101183](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574002101183.png)\n\n- 没有模板引擎（模板引擎找不到这个错误页面），就会在静态资源文件夹下找；\n- 如果以上都没有找到错误页面，就是默认来到SpringBoot默认的错误提示页面；\n\n## defaultErrorView\n\n![1574146899180](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574146899180.png)\n\n![1574146843810](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574146843810.png)\n\n\n\n\n\n## 如何定制JSON数据\n\nspringboot做了自适应效果，浏览器访问响应错误页面。客户端访问响应错误信息的json数据\n\n1. 第一种方法，定义全局异常处理器类注入到容器中，捕获到异常返回json格式的数据\n\n   ```java\n   @ControllerAdvice\n   public class MyExceptionHandler {\n   \n       @ResponseBody\n       @ExceptionHandler(Exception.class)\n       public Map<String, Object> handleException(Exception e) {\n           Map<String, Object> map = new HashMap(2);\n           map.put(\"code\", \"100011\");\n           map.put(\"msg\", e.getMessage());\n           return map;\n       }\n   }\n   ```\n\n   访问[localhost:8080/hello?str=hi](http://localhost:8080/hello?str=hi)\n\n   ```java\n   @RestController\n   public class Hello {\n   \n       @RequestMapping(\"/hello\")\n       public String hello(String str) {\n           if (\"hi\".equals(str)) {\n               int i = 10 / 0;\n           }\n           return \"hello world\";\n       }\n   }\n   ```\n\n   这样的话，不管是浏览器访问还是客户端访问都是响应json数据，就没有了自适应效果\n\n   2. 第二种方法，捕获到异常后转发到/error\n\n      ```java\n      @ControllerAdvice\n      public class MyExceptionHandler {\n      \n          @ExceptionHandler(Exception.class)\n          public String handleException(Exception e) {\n              Map<String, Object> map = new HashMap(2);\n              map.put(\"code\", \"100011\");\n              map.put(\"msg\", e.getMessage());\n              return \"forward:/error\";\n          }\n      }\n      ```\n\n      访问[localhost:8080/hello?str=hi](http://localhost:8080/hello?str=hi)，但这样异常被我们捕获然后转发，显示的状态码就是200，所以在转发之前还要设置一下状态码\n\n      ```java\n          @ExceptionHandler(Exception.class)\n          public String handleException(Exception e, HttpServletRequest request) {\n              Map<String, Object> map = new HashMap(2);\n              map.put(\"code\", \"100011\");\n              map.put(\"msg\", e.getMessage());\n      \n              //设置状态码\n              request.setAttribute(\"javax.servlet.error.status_code\", 500);\n              return \"forward:/error\";\n          }\n      ```\n\n      但是设置的数据就没有用了，只能使用默认的 \n\n      由上面我们已经知道数据的来源是调用DefaultErrorAttributes的getErrorAttributes方法得到的，而这个DefaultErrorAttributes是在ErrorMvcAutoConfiguration配置类中注册的，并且注册之前会检查容器中是否已经拥有\n\n      ```java\n          @Bean\n          @ConditionalOnMissingBean(\n              value = {ErrorAttributes.class},\n              search = SearchStrategy.CURRENT\n          )\n          public DefaultErrorAttributes errorAttributes() {\n              return new DefaultErrorAttributes(this.serverProperties.getError().isIncludeException());\n          }\n      ```\n\n      所以我们可以只要实现ErrorAttributes接口或者继承DefaultErrorAttributes类，然后注册到容器中就行了\n\n      ```java\n      @ControllerAdvice\n      public class MyExceptionHandler {\n      \n          @ExceptionHandler(Exception.class)\n          public String handleException(Exception e, HttpServletRequest request) {\n              Map<String, Object> map = new HashMap(2);\n              map.put(\"name\", \"hello\");\n              map.put(\"password\", \"123456\");\n      \n              //设置状态码\n              request.setAttribute(\"javax.servlet.error.status_code\", 500);\n      \n              //把数据放到request域中\n              request.setAttribute(\"ext\", map);\n              return \"forward:/error\";\n          }\n      }\n      ```\n\n      ```java\n      @Configuration\n      public class MyMvcConfig implements WebMvcConfigurer {\n          \n          @Bean\n          public DefaultErrorAttributes errorAttributes() {\n              return new MyErrorAttributes();\n          }\n      \n          class MyErrorAttributes extends DefaultErrorAttributes {\n              @Override\n              public Map<String, Object> getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) {\n                  //调用父类的方法获取默认的数据\n                  Map<String, Object> map = new HashMap<>(super.getErrorAttributes(webRequest, includeStackTrace));\n                  //从request域从获取到自定义数据\n                  Map<String, Object> ext = (Map<String, Object>) webRequest.getAttribute(\"ext\", RequestAttributes.SCOPE_REQUEST);\n                  map.putAll(ext);\n                  return map;\n              }\n          }\n          \n          ......\n      ```\n\n      \n\n      ","tags":["springboot"],"categories":["springboot"]},{"title":"springboot自定义Starter","url":"/2020/05/23/springboot/customizestarter/","content":"\n# 自定义Starter\n\n- 启动器只用来做依赖导入\n\n- 专门来写一个自动配置模块；\n\n- 启动器依赖自动配置模块，项目中引入相应的starter就会引入启动器的所有传递依赖\n\n  ![1574561125363](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574561125363.png)\n\n## 启动器\n\n启动器模块是一个空 JAR 文件，仅提供辅助性依赖管理，这些依赖可能用于自动\n装配或者其他类库\n\n### 命名规约\n\n- 官方命名\n\n  `spring-boot-starter-模块名`\n\n  *eg*：`spring-boot-starter-web`、`spring-boot-starter-jdbc`、`spring-boot-starter-thymeleaf`\n\n- 自定义命名\n\n  `模块名-spring-boot-starter`\n\n  *eg*：`mybatis-spring-boot-start`\n\n## 如何编写自动配置\n\n```java\n@Configuration //指定这个类是一个配置类\n@ConditionalOnXXX //在指定条件成立的情况下自动配置类生效\n@AutoConfigureAfter //指定自动配置类的顺序\n@Bean //给容器中添加组件\n@ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置\n@EnableConfigurationProperties //让xxxProperties生效加入到容器中\npublic class XxxxAutoConfiguration {\n```\n\n!> 自动配置类要能加载,需要将启动就加载的自动配置类配置在`META-INF/spring.factories`中\n\n*eg：*\n\n```properties\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration,\\\norg.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration\n```\n\n\n\n## 案例\n\n1. 创建一个自动配置模块，和创建普通springboot项目一样，不需要引入其他starter\n\n2. 删除掉多余的文件和依赖\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n       <modelVersion>4.0.0</modelVersion>\n       <parent>\n           <groupId>org.springframework.boot</groupId>\n           <artifactId>spring-boot-starter-parent</artifactId>\n           <version>2.2.1.RELEASE</version>\n           <relativePath/>\n       </parent>\n       <groupId>cn.clboy.spring.boot</groupId>\n       <artifactId>clboy-spring-boot-autoconfigure</artifactId>\n       <version>0.0.1-SNAPSHOT</version>\n       <name>clboy-spring-boot-autoconfigure</name>\n   \n       <properties>\n           <java.version>1.8</java.version>\n       </properties>\n   \n       <dependencies>\n           <!--引入spring‐boot‐starter；所有starter的基本配置-->\n           <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-starter</artifactId>\n           </dependency>\n           <!--可以生成配置类提示文件-->\n           <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-configuration-processor</artifactId>\n               <optional>true</optional>\n           </dependency>\n       </dependencies>\n   \n   </project>\n   ```\n\n   ![1574563050873](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574563050873.png)\n\n3. 创建配置类和自动配置类\n\n   ```java\n   package cn.clboy.spring.boot.autoconfigure;\n   \n   import org.springframework.boot.context.properties.ConfigurationProperties;\n   \n   @ConfigurationProperties(prefix = \"clboy\")\n   public class ClboyProperties {\n   \n       private String prefix;\n       private String suffix;\n   \n       public ClboyProperties() {\n           this.prefix = \"\";\n           this.suffix = \"\";\n       }\n   \n       public String getPrefix() {\n           return prefix;\n       }\n   \n       public void setPrefix(String prefix) {\n           this.prefix = prefix;\n       }\n   \n       public String getSuffix() {\n           return suffix;\n       }\n   \n       public void setSuffix(String suffix) {\n           this.suffix = suffix;\n       }\n   }\n   ```\n\n   ``` java\n   package cn.clboy.spring.boot.autoconfigure;\n   \n   import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;\n   import org.springframework.boot.context.properties.EnableConfigurationProperties;\n   import org.springframework.context.annotation.Bean;\n   import org.springframework.context.annotation.Configuration;\n   \n   /**\n    * @Author cloudlandboy\n    * @Date 2019/11/24 上午10:40\n    * @Since 1.0.0\n    */\n   \n   @Configuration\n   @ConditionalOnWebApplication //web应用才生效\n   @EnableConfigurationProperties(ClboyProperties.class) //让配置类生效，(注入到容器中)\n   public class ClboyAutoConfiguration {\n       \n       private final ClboyProperties clboyProperties;\n       \n       /**\n        * 构造器注入clboyProperties\n        *\n        * @param clboyProperties\n        */\n       public ClboyAutoConfiguration(ClboyProperties clboyProperties) {\n           this.clboyProperties = clboyProperties;\n       }\n   \n       @Bean\n       public HelloService helloService() {\n           return new HelloService();\n       }\n       \n       public class HelloService {\n           \n           public String sayHello(String name) {\n               return clboyProperties.getPrefix() + name + clboyProperties.getSuffix();\n           }\n       }\n   }\n   ```\n\n   \n\n4. 在resources文件夹下创建META-INF/spring.factories\n\n   ![1574568406300](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574568406300.png)\n\n   ```properties\n   org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\n   cn.clboy.spring.boot.autoconfigure.ClboyAutoConfiguration\n   ```\n\n5. 安装到本地仓库\n\n6. 创建starter，选择maven工程即可，只是用于管理依赖，添加对AutoConfiguration模块的依赖\n\n   ![1574565106397](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574565106397.png)\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n       <modelVersion>4.0.0</modelVersion>\n   \n       <groupId>cn.clboy.spring.boot</groupId>\n       <artifactId>clboy-spring-boot-starter</artifactId>\n       <version>1.0-SNAPSHOT</version>\n   \n       <dependencies>\n           <dependency>\n               <groupId>cn.clboy.spring.boot</groupId>\n               <artifactId>clboy-spring-boot-autoconfigure</artifactId>\n               <version>0.0.1-SNAPSHOT</version>\n           </dependency>\n       </dependencies>\n   \n   </project>\n   ```\n\n7. 安装到本地仓库\n\n8. 创建项目测试，选择添加web场景，因为设置是web场景才生效\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n       <modelVersion>4.0.0</modelVersion>\n       <parent>\n           <groupId>org.springframework.boot</groupId>\n           <artifactId>spring-boot-starter-parent</artifactId>\n           <version>2.2.1.RELEASE</version>\n           <relativePath/> <!-- lookup parent from repository -->\n       </parent>\n       <groupId>cn.clboy</groupId>\n       <artifactId>starter-test</artifactId>\n       <version>0.0.1-SNAPSHOT</version>\n       <name>starter-test</name>\n       <description>Demo project for Spring Boot</description>\n   \n       <properties>\n           <java.version>1.8</java.version>\n       </properties>\n   \n       <dependencies>\n           <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-starter-web</artifactId>\n           </dependency>\n           <dependency>\n               <groupId>cn.clboy.spring.boot</groupId>\n               <artifactId>clboy-spring-boot-starter</artifactId>\n               <version>1.0-SNAPSHOT</version>\n           </dependency>\n       </dependencies>\n   \n   </project>\n   ```\n\n   \n\n9. 创建Controller\n\n   ```java\n   @RestController\n   public class HelloController {\n   \n       @Autowired\n       private HelloService helloService;\n   \n       @RequestMapping(\"/hello\")\n       public String sayHello() {\n           String hello = helloService.sayHello(\"Peppa Pig\");\n           return hello;\n       }\n   }\n   ```\n\n   \n\n10. 在配置文件中配置\n\n    ```properties\n    clboy.prefix=hello！\n    clboy.suffix=，你好啊...\n    ```\n\n11. 启动项目访问：<http://localhost:8080/hello>\n\n\n\n!> 注意查看文件夹的命名是否正确，最好是从别的包中复制过去，正确的情况下spring.factories是有小绿叶图标的\n\n![1574567314385](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574567314385.png)","tags":["springboot"],"categories":["springboot"]},{"title":"springboot web开发","url":"/2020/05/23/springboot/helloweb/","content":"\n\n# SpringBoot Web开发\n\n1. 创建SpringBoot应用，选中我们需要的模块\n\n2. SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来\n3. 自己编写业务代码\n\n\n\n## web自动配置规则\n\n1. WebMvcAutoConfiguration\n2. WebMvcProperties\n3. ViewResolver自动配置\n4. 静态资源自动映射\n5. Formatter与Converter自动配置\n6. HttpMessageConverter自动配置\n7. 静态首页\n8. favicon\n9. 错误处理\n\n\n\n## SpringBoot对静态资源的映射规则\n\n`WebMvcAutoConfiguration`类的`addResourceHandlers`方法：（添加资源映射）\n\n```java\n        public void addResourceHandlers(ResourceHandlerRegistry registry) {\n            if (!this.resourceProperties.isAddMappings()) {\n                logger.debug(\"Default resource handling disabled\");\n            } else {\n                Duration cachePeriod = this.resourceProperties.getCache().getPeriod();\n                CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();\n                if (!registry.hasMappingForPattern(\"/webjars/**\")) {\n                    this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{\"/webjars/**\"}).addResourceLocations(new String[]{\"classpath:/META-INF/resources/webjars/\"}).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl));\n                }\n\n                String staticPathPattern = this.mvcProperties.getStaticPathPattern();\n                if (!registry.hasMappingForPattern(staticPathPattern)) {\n                    this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{staticPathPattern}).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(this.resourceProperties.getStaticLocations())).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl));\n                }\n\n            }\n        }\n```\n\n所有 `/webjars/**` ，都去 `classpath:/META-INF/resources/webjars/` 找资源\n\n`webjars`：以jar包的方式引入静态资源；\n\n[webjars官网](https://www.webjars.org/)\n\n![1573815091111](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573815091111.png)\n\n\n\n例如：添加jquery的webjars\n\n```xml\n        <dependency>\n            <groupId>org.webjars</groupId>\n            <artifactId>jquery</artifactId>\n            <version>3.4.1</version>\n        </dependency>\n```\n\n![1573815506777](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573815506777.png)\n\n访问地址对应就是：http://localhost:8080/webjars/jquery/3.4.1/jquery.js\n\n\n\n## 非webjars，自己的静态资源怎么访问\n\n**资源配置类：** \n\n```java\n@ConfigurationProperties(\t//说明可以在配置文件中配置相关参数\n    prefix = \"spring.resources\",\n    ignoreUnknownFields = false\n)\npublic class ResourceProperties {\n    private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]{\"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\"};\n    private String[] staticLocations;\n    private boolean addMappings;\n    private final ResourceProperties.Chain chain;\n    private final ResourceProperties.Cache cache;\n\n    public ResourceProperties() {\n        this.staticLocations = CLASSPATH_RESOURCE_LOCATIONS;\n        this.addMappings = true;\n        this.chain = new ResourceProperties.Chain();\n        this.cache = new ResourceProperties.Cache();\n    }\n```\n\n\n\n![1573817274649](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573817274649.png)\n\n\n\n上图中添加的映射访问路径`staticPathPattern`值是`/**`，对应的资源文件夹就是上面配置类`ResourceProperties`中的`CLASSPATH_RESOURCE_LOCATIONS`数组中的文件夹：\n\n| 数组中的值                     | 在项目中的位置                         |\n| ------------------------------ | -------------------------------------- |\n| classpath:/META-INF/resources/ | src/main/resources/META-INF/resources/ |\n| classpath:/resources/          | src/main/resources/resources/          |\n| classpath:/static/             | src/main/resources/static/             |\n| classpath:/public/             | src/main/resources/public/             |\n\nlocalhost:8080/abc \t--->\t去静态资源文件夹里面找abc\n\n## 欢迎页映射\n\n![1573819949494](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573819949494.png)\n\n`location`就是静态资源路径，所以欢迎页的页面就是上面静态资源下的`index.html`，被`/**`映射，因此直接访问项目就是访问欢迎页\n\n## 网站图标映射（favicon.ico）\n\n所有的 favicon.ico  都是在静态资源文件下找；\n\n","tags":["springboot"],"categories":["springboot"]},{"title":"springboot数据源配置","url":"/2020/05/23/springboot/jdbc/","content":"\n# SpringBoot与数据库连接\n\n## 依赖\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-jdbc</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-thymeleaf</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.mybatis.spring.boot</groupId>\n        <artifactId>mybatis-spring-boot-starter</artifactId>\n        <version>2.1.1</version>\n    </dependency>\n\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <scope>runtime</scope>\n    </dependency>\n</dependencies>\n```\n\n## 配置数据库连接信息\n\n```yaml\nspring:\n  datasource:\n    username: root\n    password: root\n    url: jdbc:mysql://172.16.145.137:3306/springboot\n    driver-class-name: com.mysql.cj.jdbc.Driver\n```\n\n测试能否连接上数据库\n\n```hava\n@SpringBootTest\nclass SpringbootJdbcApplicationTests {\n\n    @Autowired\n    private DataSource dataSource;\n\n    @Test\n    void contextLoads() throws SQLException {\n        System.out.println(dataSource.getClass());\n        System.out.println(dataSource.getConnection());\n    }\n\n}\n```\n\nspringboot默认是使用`com.zaxxer.hikari.HikariDataSource`作为数据源，2.0以下是用`org.apache.tomcat.jdbc.pool.DataSource`作为数据源；\n\n数据源的相关配置都在DataSourceProperties里面；\n\n## 自动配置原理\n\n?> *TODO*\n\njdbc的相关配置都在`org.springframework.boot.autoconfigure.jdbc`包下\n\n参考`DataSourceConfiguration`，根据配置创建数据源，默认使用Hikari连接池；可以使用spring.datasource.type指定自定义的数据源类型；\n\nspringboot默认支持的连池：\n\n- org.apache.commons.dbcp2.BasicDataSource\n- com.zaxxer.hikari.HikariDataSource\n- org.apache.tomcat.jdbc.pool.DataSource\n\n\n\n自定义数据源类型：\n\n```java\n    @Configuration(\n        proxyBeanMethods = false\n    )\n    @ConditionalOnMissingBean({DataSource.class})\n    @ConditionalOnProperty(\n        name = {\"spring.datasource.type\"}\n    )\n    static class Generic {\n        Generic() {\n        }\n\n        @Bean\n        DataSource dataSource(DataSourceProperties properties) {\n             //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性\n            return properties.initializeDataSourceBuilder().build();\n        }\n    }\n```\n\n\n\n## 启动应用执行sql\n\nSpringBoot在创建连接池后还会运行预定义的SQL脚本文件，具体参考`org.springframework.boot.autoconfigure.jdbc.DataSourceInitializationConfiguration`配置类，\n\n在该类中注册了`dataSourceInitializerPostProcessor`\n\n下面是获取schema脚本文件的方法\n\n```java\nList<Resource> scripts = this.getScripts(\"spring.datasource.schema\", this.properties.getSchema(), \"schema\");\n```\n\n![1574409852703](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574409852703.png)\n\n可以看出，如果我们没有在配置文件中配置脚本的具体位置，就会在classpath下找`schema-all.sql`和`schema.sql`  <small>platform获取的是all，platform可以在配置文件中修改</small>\n\n具体查看`createSchema()方法`和`initSchema()方法`\n\ninitSchema()方法获取的是`data-all.sql`，`data.sql`\n\n我们也可以在配置文件中配置sql文件的位置\n\n```yaml\nspring:\n  datasource:\n\tschema:\n      - classpath:department.sql\n      - 指定位置\n```\n\n\n\n**测试：**\n\n在类路径下创建`schema.sql`，运行程序查看数据库是否存在该表\n\n```sql\nDROP TABLE IF EXISTS `department`;\nCREATE TABLE `department` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `departmentName` varchar(255) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;\n```\n\n程序启动后发现表并没有被创建，DEBUG查看以下，发现在运行之前会有一个判断\n\n![1574411869052](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574411869052.png)\n\n![1574412098885](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574412098885.png)\n\n上面方法也不知道在干什么，反正就是只要是`NEVER`和`EMBEDDED`就为true，而DataSourceInitializationMode枚举类中除了这两个就剩下`ALWAYS`了，可以在配置文件中配置为ALWAYS\n\n![1574412237660](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574412237660.png)\n\n```yaml\nspring:\n  datasource:\n    username: root\n    password: root\n    url: jdbc:mysql://172.16.145.137:3306/springboot\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    initialization-mode: always\n```\n\n\n\n`schema.sql`：建表语句\n\n`data.sql`：插入数据\n\n当然混合使用也可以，愿意咋来咋来\n\n!> **注意：**项目每次启动都会执行一次sql\n\n## 整合Druid数据源\n\n> 选择哪个数据库连接池\n>\n> - DBCP2 是 Appache 基金会下的项目，是最早出现的数据库连接池 DBCP 的第二个版本。\n> - C3P0 最早出现时是作为 Hibernate 框架的默认数据库连接池而进入市场。\n> - Druid 是阿里巴巴公司开源的一款数据库连接池，其特点在于有丰富的附加功能。\n> - HikariCP 相较而言比较新，它最近两年才出现，据称是速度最快的数据库连接池。最近更是被 Spring 设置为默认数据库连接池。\n>\n> 不选择 C3P0 的原因：\n>\n> - C3P0 的 Connection 是异步释放。这个特性会导致释放的在某些情况下 Connection 实际上 **still in use** ，并未真正释放掉，从而导致连接池中的 Connection 耗完，等待状况。\n> - Hibernate 现在对所有数据库连接池一视同仁，官方不再指定『默认』数据库连接池。因此 C3P0 就失去了『官方』光环。\n>\n> 不选择 DBCP2 的原因：\n>\n> - 相较于 Druid 和 HikariCP，DBCP2 没有什么特色功能/卖点。基本上属于 `能用，没毛病` 的情况，地位显得略有尴尬。\n\n1. 在 Spring Boot 项目中加入`druid-spring-boot-starter`依赖 ([点击查询最新版本](https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter))\n\n   ```xml\n   <dependency>\n       <groupId>com.alibaba</groupId>\n       <artifactId>druid-spring-boot-starter</artifactId>\n       <version>1.1.20</version>\n   </dependency>\n   ```\n\n2. 在配置文件中指定数据源类型\n\n   ```yaml\n   spring:\n     datasource:\n       username: root\n       password: root\n       url: jdbc:mysql://172.16.145.137:3306/springboot\n       driver-class-name: com.mysql.cj.jdbc.Driver\n       initialization-mode: always\n       type: com.alibaba.druid.pool.DruidDataSource\n   ```\n\n3. 测试类查看使用的数据源\n\n   ```java\n   @SpringBootTest\n   class SpringbootJdbcApplicationTests {\n   \n       @Autowired\n       private DataSource dataSource;\n   \n       @Test\n       void contextLoads() throws SQLException {\n           System.out.println(dataSource.getClass());\n           System.out.println(dataSource.getConnection());\n       }\n   \n   }\n   ```\n\n### 配置参数\n\n```yaml\nspring:\n  datasource:\n    username: root\n    password: root\n    url: jdbc:mysql://172.16.145.137:3306/springboot\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    initialization-mode: always\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      # 连接池配置\n      # 配置初始化大小、最小、最大\n      initial-size: 1\n      min-idle: 1\n      max-active: 20\n      # 配置获取连接等待超时的时间\n      max-wait: 3000\n      validation-query: SELECT 1 FROM DUAL\n      test-on-borrow: false\n      test-on-return: false\n      test-while-idle: true\n      pool-prepared-statements: true\n      time-between-eviction-runs-millis: 60000\n      min-evictable-idle-time-millis: 300000\n      filters: stat,wall,slf4j\n      # 配置web监控,默认配置也和下面相同(除用户名密码，enabled默认false外)，其他可以不配\n      web-stat-filter:\n        enabled: true\n        url-pattern: /*\n        exclusions: \"*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*\"\n      stat-view-servlet:\n        enabled: true\n        url-pattern: /druid/*\n        login-username: admin\n        login-password: root\n        allow: 127.0.0.1\n```\n\n后台页面，访问<http://localhost:8080/druid/login.html>","tags":["springboot"],"categories":["springboot"]},{"title":"springboot入门","url":"/2020/05/23/springboot/helloworld/","content":"\n\n# Spring Boot 入门\n\n## 简介\n\n[百度百科](http://t.cn/AirXJZuO)\n\n**优点**\n\n> - 快速创建独立运行的Spring项目以及与主流框架集成\n> - 使用嵌入式的Servlet容器，应用无需打成WAR包\n> - starters自动依赖与版本控制\n> - 大量的自动配置，简化开发，也可修改默认值\n> - 无需配置XML，无代码生成，开箱即用\n> - 准生产环境的运行时应用监控\n> - 与云计算的天然集成\n\n\n\n## 微服务\n\n> 2014，martin fowler\n>\n> 微服务：架构风格（服务微化）\n>\n> 一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；\n>\n> 单体应用：ALL IN ONE\n>\n> 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；\n>\n> [详细参照微服务文档](https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa)\n>\n> [集群、分布式、微服务概念和区别](https://blog.csdn.net/qq_37788067/article/details/79250623)\n\n\n\n## 环境约束\n\n–jdk1.8：Spring Boot 推荐jdk1.7及以上；\n\n–maven3.x：maven 3.3以上版本；\n\n\n\n## Maven设置\n\n给maven 的settings.xml配置文件的profiles标签添加：（设置使用的jdk版本）\n\n开发工具中的maven设置为自己配置的maven\n\n```xml\n<profile>\n  <id>jdk-1.8</id>\n  <activation>\n    <activeByDefault>true</activeByDefault>\n    <jdk>1.8</jdk>\n  </activation>\n  <properties>\n    <maven.compiler.source>1.8</maven.compiler.source>\n    <maven.compiler.target>1.8</maven.compiler.target>\n    <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>\n  </properties>\n</profile>\n```\n\n\n\n## 创建一个maven工程\n\n1. 导入spring boot相关的依赖\n\n   ```xml\n       <parent>\n           <groupId>org.springframework.boot</groupId>\n           <artifactId>spring-boot-starter-parent</artifactId>\n           <version>2.2.1.RELEASE</version>\n           <relativePath/>\n       </parent>\n   \n       <dependencies>\n           <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-starter-web</artifactId>\n           </dependency>\n       </dependencies>\n   ```\n\n2. 编写一个主程序；启动Spring Boot应用\n\n   ```java\n   package cn.clboy.springboot;\n   \n   import org.springframework.boot.SpringApplication;\n   import org.springframework.boot.autoconfigure.SpringBootApplication;\n   \n   /**\n    * @Author cloudlandboy\n    * @Date 2019/11/13 下午2:58\n    * @Since 1.0.0\n    * springBootApplication：标注一个主程序类，表示这个是一个Springboot应用\n    */\n   \n   @SpringBootApplication\n   public class HelloWorldMainApplication {\n   \n       public static void main(String[] args) {\n           //启动\n           SpringApplication.run(HelloWorldMainApplication.class, args);\n       }\n   }\n   ```\n\n   \n\n3. 编写一个Controller\n\n   ```java\n   package cn.clboy.springboot.controller;\n   \n   import org.springframework.web.bind.annotation.RequestMapping;\n   import org.springframework.web.bind.annotation.RestController;\n   \n   /**\n    * @Author cloudlandboy\n    * @Date 2019/11/13 下午3:05\n    * @Since 1.0.0\n    * RestController：是spring4里的新注解，是@ResponseBody和@Controller的缩写。\n    */\n   \n   @RestController\n   public class HelloController {\n   \n       @RequestMapping(\"/hello\")\n       public String hello(){\n           return \"hello SpringBoot,this is my first Application\";\n       }\n   }\n   ```\n\n4. 运行主程序Main方法测试\n\n5. 访问 [localhost:8080/hello](http://localhost:8080/hello)\n\n\n\n## 简化部署\n\n1. 添加maven插件\n\n   ```xml\n    <!-- 这个插件，可以将应用打包成一个可执行的jar包；-->\n       <build>\n           <plugins>\n               <plugin>\n                   <groupId>org.springframework.boot</groupId>\n                   <artifactId>spring-boot-maven-plugin</artifactId>\n               </plugin>\n           </plugins>\n       </build>\n   ```\n\n2. 使用mvn package进行打包\n\n3. 进入打包好的jar包所在目录\n\n4. 使用 `java -jar jar包名称` 运行\n\n\n\n## Hello World探究\n\n### 依赖\n\n```\n\t<!--Hello World项目的父工程是org.springframework.boot-->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.2.1.RELEASE</version>\n        <relativePath/>\n    </parent>\n\n    <!--\n        org.springframework.boot他的父项目是spring-boot-dependencies\n        他来真正管理Spring Boot应用里面的所有依赖版本；\n        Spring Boot的版本仲裁中心；\n        以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号）\n    -->\n  <parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-dependencies</artifactId>\n    <version>2.2.1.RELEASE</version>\n    <relativePath>../../spring-boot-dependencies</relativePath>\n  </parent>\n```\n\n### 启动器\n\n```xml\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n```\n\n**spring-boot-starter**-`web`：\n\n​\tspring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；\n\nSpring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器\n\n\n\n### 主程序类，主入口类\n\n```java\n@SpringBootApplication\npublic class HelloWorldMainApplication {\n\n    public static void main(String[] args) {\n        //启动\n        SpringApplication.run(HelloWorldMainApplication.class, args);\n    }\n}\n```\n\n`@SpringBootApplication`:    Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；\n\n看一下`@SpringBootApplication`这个注解类的源码\n\n```java\n@Target({ElementType.TYPE})\t//可以给一个类型进行注解，比如类、接口、枚举\n@Retention(RetentionPolicy.RUNTIME)\t//可以保留到程序运行的时候，它会被加载进入到 JVM 中\n@Documented\t//将注解中的元素包含到 Javadoc 中去。\n@Inherited\t//继承，比如A类上有该注解，B类继承A类，B类就也拥有该注解\n\n@SpringBootConfiguration\n\n@EnableAutoConfiguration\n\n/*\n*创建一个配置类，在配置类上添加 @ComponentScan 注解。\n*该注解默认会扫描该类所在的包下所有的配置类，相当于之前的 <context:component-scan>。\n*/\n@ComponentScan(\n    excludeFilters = {@Filter(\n    type = FilterType.CUSTOM,\n    classes = {TypeExcludeFilter.class}\n), @Filter(\n    type = FilterType.CUSTOM,\n    classes = {AutoConfigurationExcludeFilter.class}\n)}\n)\npublic @interface SpringBootApplication\n```\n\n- `@SpringBootConfiguration`：Spring Boot的配置类；标注在某个类上，表示这是一个Spring Boot的配置类；\n\n   ```java\n   @Target({ElementType.TYPE})\n   @Retention(RetentionPolicy.RUNTIME)\n   @Documented\n   @Configuration\n   public @interface SpringBootConfiguration\n   ```\n\n   - `@Configuration`：配置类上来标注这个注解；\n\n     配置类 -----  配置文件；配置类也是容器中的一个组件；@Component\n\n     ```java\n     @Target({ElementType.TYPE})\n     @Retention(RetentionPolicy.RUNTIME)\n     @Documented\n     @Component\n     public @interface Configuration \n     ```\n\n- `@EnableAutoConfiguration`：开启自动配置功能；\n\n   以前我们需要配置的东西，Spring Boot帮我们自动配置；@**EnableAutoConfiguration**告诉SpringBoot开启自动配置功能；这样自动配置才能生效；\n\n   ```\n   @Target({ElementType.TYPE})\n   @Retention(RetentionPolicy.RUNTIME)\n   @Documented\n   @Inherited\n   @AutoConfigurationPackage\n   @Import({AutoConfigurationImportSelector.class})\n   public @interface EnableAutoConfiguration\n   ```\n\n   - `@AutoConfigurationPackage`：自动配置包\n\n     ```java\n     @Target({ElementType.TYPE})\n     @Retention(RetentionPolicy.RUNTIME)\n     @Documented\n     @Inherited\n     @Import({Registrar.class})\n     public @interface AutoConfigurationPackage\n     ```\n\n     - `@Import`：Spring的底层注解@Import，给容器中导入一个组件\n\n       导入的组件由`org.springframework.boot.autoconfigure.AutoConfigurationPackages.Registrar`将主配置类（<mark>@SpringBootApplication标注的类</mark>）的所在包及下面所有子包里面的所有组件扫描到Spring容器；\n\n       ![DEBUG](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573637120233.png)\n\n       这里controller包是在主程序所在的包下，所以会被扫描到，我们在springboot包下创建一个test包，把主程序放在test包下，这样启动就只会去扫描test包下的内容而controller包就不会被扫描到，再访问开始的hello就是404\n\n       ![DEBUG](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573637728857.png)\n\n   - `@Import({AutoConfigurationImportSelector.class})`\n\n     `AutoConfigurationImportSelector.class`将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；\n\n     有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；\n\n     ![Configuration](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573638685562.png)\n\n\n\nSpring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；以前我们需要自己配置的东西，自动配置类都帮我们完成了；","tags":["springboot"],"categories":["springboot"]},{"title":"Zuul网关","url":"/2020/05/23/springCloud/zuul/","content":"\n# Zuul网关\n\n通过前面的学习，使用Spring Cloud实现微服务的架构基本成型，大致是这样的：\n\n![1525674644660](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1525674644660.png)\n\n我们使用Spring Cloud Netflix中的`Eureka`实现了服务注册中心以及服务注册与发现；\n\n而服务间通过`Ribbon`或`Feign`实现服务的消费以及均衡负载。\n\n为了使得服务集群更为健壮，使用`Hystrix`的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。\n\n在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。我们把焦点聚集在对外服务这块，直接暴露我们的服务地址，这样的实现是否合理，或者是否有更好的实现方式呢？\n\n\n\n先来说说这样架构需要做的一些事儿以及存在的不足：\n\n- 破坏了服务无状态特点。\n\n   为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。\n\n   <small>从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理</small>\n\n- 无法直接复用既有接口。\n\n   当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。\n\n\n\n面对类似上面的问题，我们要如何解决呢？答案是：服务网关！\n\n为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器的 服务网关。\n\n服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备`服务路由`、`均衡负载`功能之外，它还具备了`权限控制`等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。\n\n\n\n## 简介\n\n ![百度百科](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/w%3D268%3Bg%3D0/sign=7a4e5e3e133853438ccf8027ab28d743/0e2442a7d933c8959e273529d21373f082020002.jpg)\n\nZuul：维基百科\n\n电影《捉鬼敢死队》中的怪兽，Zuul，在纽约引发了巨大骚乱。\n\n事实上，在微服务架构中，Zuul就是守门的大Boss！一夫当关，万夫莫开！\n\n![1525675168152](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1525675168152.png)\n\n\n\n## Zuul加入后的架构\n\n ![1525675648881](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1525675648881.png)\n\n不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。\n\n\n\n## 快速入门\n\n### 新建工程\n\n1. 填写基本信息，项目名为`springcloud-zuul`：\n\n2. 添加Zuul依赖：\n\n   ![1574929547498](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574929547498.png)\n\n\n\n### 编写配置\n\n```yaml\nserver:\n  port: 20001 #服务端口\nspring:\n  application:\n    name: api-gateway #指定服务名\n```\n\n\n\n### 编写引导类\n\n通过`@EnableZuulProxy `注解开启Zuul的功能：\n\n```java\n@SpringBootApplication\n@EnableZuulProxy\npublic class SpringcloudZuulApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringcloudZuulApplication.class, args);\n    }\n\n}\n```\n\n\n\n### 编写路由规则\n\n我们需要用Zuul来代理service-provider服务，先看一下控制面板中的服务状态：\n\n![1574930299265](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574930299265.png)\n\n- ip为：127.0.0.1(本机)\n- 端口为：8081\n\n映射规则：\n\n```yaml\nserver:\n  port: 20001 #服务端口\nspring:\n  application:\n    name: api-gateway #指定服务名\nzuul:\n  routes:\n    service-provider: #这里是路由id，随意写（一般为服务名）\n      path: /service-provider/** # 这里是映射路径\n      url: http://127.0.0.1:8081 # 映射路径对应的实际url地址\n```\n\n我们将符合`path` 规则的一切请求，都代理到 `url`参数指定的地址\n\n本例中，我们将 `/service-provider/**`开头的请求，代理到http://127.0.0.1:8081\n\n\n\n### 启动测试\n\n![1574930644979](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1574930644979.png)\n\n访问的路径中需要加上配置规则的映射路径\n\n服务的请求地址是：<http://localhost:8081/user/1>\n\n现在我们请求网关地址：<http://localhost:20001/service-provider/user/1>\n\n\n\n## 面向服务的路由\n\n在刚才的路由规则中，我们把路径对应的服务地址写死了！如果同一服务有多个实例的话，这样做显然就不合理了。我们应该根据服务的名称，去Eureka注册中心查找 服务对应的所有实例列表，然后进行动态路由才对！\n\n对`springcloud-zuul`工程修改优化：\n\n### 添加Eureka客户端依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\n\n\n### 添加Eureka配置，获取服务信息\n\n```yaml\neureka:\n  client:\n    registry-fetch-interval-seconds: 5 # 获取服务列表的周期：5s\n    service-url:\n      defaultZone: http://127.0.0.1:10001/eureka\n```\n\n\n\n### 开启Eureka客户端发现功能\n\n```java\n@SpringBootApplication\n@EnableZuulProxy\n@EnableDiscoveryClient\npublic class SpringcloudZuulApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringcloudZuulApplication.class, args);\n    }\n}\n\n```\n\n\n\n### 修改映射配置，通过服务名称获取\n\n因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。\n\n```yaml\nserver:\n  port: 20001 #服务端口\nspring:\n  application:\n    name: api-gateway #指定服务名\nzuul:\n  routes:\n    service-provider: #这里是路由id，随意写（一般为服务名）\n      path: /service-provider/** # 这里是映射路径\n      serviceId: service-provider\n#     url: http://127.0.0.1:8081 # 映射路径对应的实际url地址\neureka:\n  client:\n    registry-fetch-interval-seconds: 5 # 获取服务列表的周期：5s\n    service-url:\n      defaultZone: http://127.0.0.1:10001/eureka\n\n```\n\n\n\n### 启动测试\n\n再次启动，这次Zuul进行代理时，会利用Ribbon进行负载均衡\n\n访问：<http://localhost:20001/service-provider/user/1>\n\n\n\n## 简化的路由配置\n\n在刚才的配置中，我们的规则是这样的：\n\n- `zuul.routes.<route>.path=/xxx/**`： 来指定映射路径。`<route>`是自定义的路由名\n- `zuul.routes.<route>.serviceId=service-provider`：来指定服务名。\n\n而大多数情况下，我们的`<route>`路由名称往往和服务名会写成一样的。因此Zuul就提供了一种简化的配置语法：`zuul.routes.<serviceId>=<path>`\n\n比方说上面我们关于service-provider的配置可以简化为一条：\n\n```yaml\nserver:\n  port: 20001 #服务端口\nspring:\n  application:\n    name: api-gateway #指定服务名\nzuul:\n  routes:\n    service-provider: /service-provider/**\neureka:\n  client:\n    registry-fetch-interval-seconds: 5 # 获取服务列表的周期：5s\n    service-url:\n      defaultZone: http://127.0.0.1:10001/eureka\n\n```\n\n省去了对服务名称的配置。\n\n重启访问测试：<http://localhost:20001/service-provider/user/1>\n\n\n\n## 默认的路由规则\n\n在使用Zuul的过程中，上面讲述的规则已经大大的简化了配置项。但是当服务较多时，配置也是比较繁琐的。因此Zuul就指定了默认的路由规则：\n\n- 默认情况下，一切服务的映射路径就是服务名本身。例如服务名为：`service-provider`，则默认的映射路径就是：`/service-provider/**`\n\n也就是说，刚才的映射规则我们完全不配置也是OK的，不信就试试看。\n\n```yaml\nserver:\n  port: 20001 #服务端口\nspring:\n  application:\n    name: api-gateway #指定服务名\neureka:\n  client:\n    registry-fetch-interval-seconds: 5 # 获取服务列表的周期：5s\n    service-url:\n      defaultZone: http://127.0.0.1:10001/eureka\n```\n\n重启访问测试：<http://localhost:20001/service-provider/user/1>，<http://localhost:20001/service-consumer/user/1>\n\n\n\n## 路由前缀\n\n配置示例：\n\n```yaml\nserver:\n  port: 20001 #服务端口\nspring:\n  application:\n    name: api-gateway #指定服务名\neureka:\n  client:\n    registry-fetch-interval-seconds: 5 # 获取服务列表的周期：5s\n    service-url:\n      defaultZone: http://127.0.0.1:10001/eureka\nzuul:\n  prefix: /api # 添加路由前缀\n```\n\n我们通过`zuul.prefix=/api`来指定了路由的前缀，这样在发起请求时，路径就要以/api开头。\n\n重启访问测试：<http://localhost:20001/api/service-provider/user/1>\n\n\n\n\n\n## 过滤器\n\nZuul作为网关的其中一个重要功能，就是实现请求的鉴权。而这个动作我们往往是通过Zuul提供的过滤器来实现的。\n\n### ZuulFilter\n\nZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法：\n\n```java\npublic abstract ZuulFilter implements IZuulFilter{\n\n    abstract public String filterType();\n\n    abstract public int filterOrder();\n    \n    boolean shouldFilter();// 来自IZuulFilter\n\n    Object run() throws ZuulException;// IZuulFilter\n}\n```\n\n- `shouldFilter`：返回一个`Boolean`值，判断该过滤器是否需要执行。返回true执行，返回false不执行。\n- `run`：过滤器的具体业务逻辑。\n- `filterType`：返回字符串，代表过滤器的类型。包含以下4种：\n  - `pre`：请求在被路由之前执行\n  - `route`：在路由请求时调用\n  - `post`：在route和errror过滤器之后调用\n  - `error`：处理请求时发生错误调用\n- `filterOrder`：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。\n\n\n\n### 过滤器执行生命周期\n\n这张是Zuul官网提供的请求生命周期图，清晰的表现了一个请求在各个过滤器的执行顺序。\n\n![1529152248172](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1529152248172.png)\n\n正常流程：\n- 请求到达首先会经过pre类型过滤器，而后到达route类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。\n\n异常流程：\n- 整个过程中，pre或者route过滤器出现异常，都会直接进入error过滤器，在error处理完毕后，会将请求交给POST过滤器，最后返回给用户。\n- 如果是error过滤器自己出现异常，最终也会进入POST过滤器，将最终结果返回给请求客户端。\n- 如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和route不同的是，请求不会再到达POST过滤器了。\n\n所有内置过滤器列表：\n\n ![](https://cdn.static.note.zzrfdsn.cn/images/springcloud/assets/1525682427811.png)\n\n\n\n### 使用场景\n\n场景非常多：\n\n- 请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了\n- 异常处理：一般会在error类型和post类型过滤器中结合来处理。\n- 服务调用时长统计：pre和post结合使用。\n\n\n\n## 自定义过滤器\n\n接下来我们来自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有token参数，则认为请求有效，放行。\n\n### 定义过滤器类\n\n!> 需要添加到spring容器中\n\n```java\npackage cn.clboy.springcloud.zuul.filter;\n\nimport com.netflix.zuul.ZuulFilter;\nimport com.netflix.zuul.context.RequestContext;\nimport com.netflix.zuul.exception.ZuulException;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.http.HttpStatus;\nimport org.springframework.cloud.netflix.zuul.ZuulFilterInitializer;\nimport org.springframework.context.annotation.FilterType;\nimport org.springframework.stereotype.Component;\n\nimport javax.servlet.http.HttpServletRequest;\n\n@Component\npublic class LoginFilter extends ZuulFilter {\n\n    /**\n     * 该过滤器是否生效\n     *\n     * @return\n     */\n    @Override\n    public boolean shouldFilter() {\n        return true;\n    }\n\n    /**\n     * 登陆校验逻辑\n     *\n     * @return\n     * @throws ZuulException\n     */\n    @Override\n    public Object run() throws ZuulException {\n        // 获取zuul提供的上下文对象\n        RequestContext context = RequestContext.getCurrentContext();\n        //获取request对象\n        HttpServletRequest request = context.getRequest();\n\n        //从请求参数中获取token\n        String token = request.getParameter(\"token\");\n\n        //判断是否存在token\n        if (StringUtils.isNotBlank(token)) {\n            // 校验通过，把登陆信息放入上下文信息，继续向后执行\n            context.set(\"token\",\"token\");\n        }else {\n            // 过滤该请求，不对其进行路由\n            context.setSendZuulResponse(false);\n            // 设置响应状态码，401\n            context.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED);\n            // 设置响应信息\n            context.setResponseBody(\"REQUEST UNAUTHORIZED\");\n        }\n        return null;\n    }\n\n    /**\n     * 过滤器类型\n     *\n     * @return\n     */\n    @Override\n    public String filterType() {\n        //前置过滤器\n        return \"pre\";\n    }\n\n    /**\n     * 过滤器的执行顺序（数值越小优先级越高）\n     *\n     * @return\n     */\n    @Override\n    public int filterOrder() {\n        return 0;\n    }\n\n}\n```\n\n### 测试\n\n没有token参数时，访问失败：<http://localhost:20001/api/service-provider/user/1>\n\n添加token参数后：<http://localhost:20001/api/service-provider/user/1?token=123456>\n\n\n\n## 负载均衡和熔断\n\nZuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置：\n\n```yaml\nhystrix:\n  command:\n    default:\n      execution:\n        isolation:\n          thread:\n            timeoutInMilliseconds: 2000 # 设置hystrix的超时时间2秒\n```\n","tags":["springcloud"],"categories":["springcloud"]},{"title":"springboot整合JPA","url":"/2020/05/23/springboot/jpa/","content":"\n# SpringBoot整合JPA\n\n**SpringData：**\n\n![SpringData](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/20180306105412.png)\n\n## 依赖\n\n```xml\n<dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-data-jpa</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <scope>runtime</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-thymeleaf</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n    </dependencies>\n```\n\n![1574481366615](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574481366615.png)\n\n\n\n## 实体类\n\n```java\npackage cn.clboy.springbootjpa.entity;\n\n\nimport javax.persistence.*;\n\n\n@Entity //使用JPA注解配置映射关系,告诉JPA这是一个实体类（和数据表映射的类）\n@Table(name = \"tbl_user\")   //@Table来指定和哪个数据表对应;如果省略默认表名类名小写；\npublic class User {\n\n    @Id //这是一个主键\n    @GeneratedValue(strategy = GenerationType.IDENTITY) //自增主键\n    private Integer id;\n\n    @Column(name = \"last_name\",length = 50) //这是和数据表对应的一个列\n    private String lastName;\n    @Column //省略默认列名就是属性名\n    private String email;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getLastName() {\n        return lastName;\n    }\n\n    public void setLastName(String lastName) {\n        this.lastName = lastName;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n}\n\n```\n\n## DAO\n\n```java\npackage cn.clboy.springbootjpa.repository;\n\nimport cn.clboy.springbootjpa.entity.User;\nimport org.springframework.data.jpa.repository.JpaRepository;\n\n/**\n * 继承JpaRepository来完成对数据库的操作\n * 泛型是（实体类，主键）\n */\npublic interface UserRepository extends JpaRepository<User, Integer> {\n\n}\n```\n\n## 配置文件\n\n```yaml\nspring:\n  datasource:\n    username: root\n    password: root\n    url: jdbc:mysql://172.16.145.137:3306/springboot\n    driver-class-name: com.mysql.cj.jdbc.Driver\n  jpa:\n    hibernate:\n      ddl-auto: update\n    show-sql: true\n```\n\n\n\n## Controller\n\n```java\n\n```\n\n\n\n添加User，访问：\n\n<http://localhost:8080/user?lastName=zhangsan&email=123456@qq.com>\n\n<http://localhost:8080/user?lastName=lisi&email=78215646@qq.com>\n\n查询用户访问：\n\n<http://localhost:8080/user/1>，然后你就会发现抛出500错误，原因是getOne方法使用的懒加载，获取到的只是代理对象，转换为json时会报错\n\n**解决方法有两种：**\n\n1. 关闭懒加载，在实体类上加`@Proxy(lazy = false)`注解\n\n   ```java\n   @Entity\n   @Table(name = \"tbl_user\")\n   @Proxy(lazy = false)\n   public class User\n   ```\n\n2. 转json的时候忽略`hibernateLazyInitializer`和`handler`属性\n\n   ```java\n   @Entity\n   @Table(name = \"tbl_user\")\n   @JsonIgnoreProperties(value = {\"hibernateLazyInitializer\", \"handler\"})\n   public class User \n   ```\n\n   \n\n\n\n","tags":["springboot"],"categories":["springboot"]},{"title":"springboot日志配置","url":"/2020/05/23/springboot/log/","content":"\n# springboot日志配置\n\n## 市面上的日志框架\n\n`JUL`、`JCL`、`Jboss-logging`、`logback`、`log4j`、`log4j2`、`slf4j`....\n\n| 日志门面  （日志的抽象层）                                   | 日志门面  （日志的抽象层）                                  |\n| ------------------------------------------------------------ | ----------------------------------------------------------- |\n| JCL（Jakarta Commons Logging <br>**SLF4j（Simple Logging Facade for Java）**<br>jboss-loggi | JUL（java.util.logging）<br>Log4j<br>Log4j2 <br>**Logback** |\n\n左边选一个门面（抽象层）、右边来选一个实现；\n\n例：SLF4j-->Logback\n\n?> SpringBoot选用 `SLF4j`和`logback`\n\n\n\n## SLF4j使用\n\n如何在系统中使用SLF4j  ：https://www.slf4j.org\n\n以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；\n\n给系统里面导入slf4j的jar和  logback的实现jar\n\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class HelloWorld {\n  public static void main(String[] args) {\n    Logger logger = LoggerFactory.getLogger(HelloWorld.class);\n    logger.info(\"Hello World\");\n  }\n}\n```\n\n![日志](http://www.slf4j.org/images/concrete-bindings.png)\n\n每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件；\n\n## 遗留问题\n\n项目中依赖的框架可能使用不同的日志：\n\n Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx\n\n当项目是使用多种日志API时，可以统一适配到SLF4J，中间使用SLF4J或者第三方提供的日志适配器适配到SLF4J，SLF4J在底层用开发者想用的一个日志框架来进行日志系统的实现，从而达到了多种日志的统一实现。\n\n![统一日志](http://www.slf4j.org/images/legacy.png)\n\n### 如何让系统中所有的日志都统一到slf4j\n\n1. 将系统中其他日志框架先排除出去；\n2. 用中间包来替换原有的日志框架（适配器的类名和包名与替换的被日志框架一致）；\n3. 我们导入slf4j其他的实现\n\n\n\n## SpringBoot日志关系\n\n```xml\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter</artifactId>\n\t\t</dependency>\n```\n\n\n\nSpringBoot使用它来做日志功能；\n\n```xml\n\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-logging</artifactId>\n\t\t</dependency>\n```\n\n底层依赖关系\n\n![](/media/cloudlandboy/%E8%B5%84%E6%96%99/%E6%95%99%E7%A8%8B/SpringBoot/%E6%BA%90%E7%A0%81%E3%80%81%E8%B5%84%E6%96%99%E3%80%81%E8%AF%BE%E4%BB%B6/%E6%96%87%E6%A1%A3/Spring%20Boot%20%E7%AC%94%E8%AE%B0/images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180131220946.png)\n\n总结：\n\n1. SpringBoot底层也是使用slf4j+logback的方式进行日志记录\n\n2. SpringBoot也把其他的日志都替换成了slf4j；\n3. 中间替换包？\n\n```java\n@SuppressWarnings(\"rawtypes\")\npublic abstract class LogFactory {\n\n    static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = \"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j\";\n\n    static LogFactory logFactory = new SLF4JLogFactory();\n```\n\n![](/media/cloudlandboy/%E8%B5%84%E6%96%99/%E6%95%99%E7%A8%8B/SpringBoot/%E6%BA%90%E7%A0%81%E3%80%81%E8%B5%84%E6%96%99%E3%80%81%E8%AF%BE%E4%BB%B6/%E6%96%87%E6%A1%A3/Spring%20Boot%20%E7%AC%94%E8%AE%B0/images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180131221411.png)\n\n\n\n!> 如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？\n\nSpring框架用的是commons-logging；\n\n```xml\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-core</artifactId>\n\t\t\t<exclusions>\n\t\t\t\t<exclusion>\n\t\t\t\t\t<groupId>commons-logging</groupId>\n\t\t\t\t\t<artifactId>commons-logging</artifactId>\n\t\t\t\t</exclusion>\n\t\t\t</exclusions>\n\t\t</dependency>\n```\n\n**SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；**\n\n## 日志使用\n\n### 默认配置\n\nSpringBoot默认帮我们配置好了日志；\n\n```java\n\t//记录器\n\tLogger logger = LoggerFactory.getLogger(getClass());\n\t@Test\n\tpublic void contextLoads() {\n\t\t//System.out.println();\n\n\t\t//日志的级别；\n\t\t//由低到高   trace<debug<info<warn<error\n\t\t//可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效\n\t\tlogger.trace(\"这是trace日志...\");\n\t\tlogger.debug(\"这是debug日志...\");\n\t\t//SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别\n\t\tlogger.info(\"这是info日志...\");\n\t\tlogger.warn(\"这是warn日志...\");\n\t\tlogger.error(\"这是error日志...\");\n\n\n\t}\n```\n\n\n\n```\n    日志输出格式：\n\t\t%d表示日期时间，\n\t\t%thread表示线程名，\n\t\t%-5level：级别从左显示5个字符宽度\n\t\t%logger{50} 表示logger名字最长50个字符，否则按照句点分割。 \n\t\t%msg：日志消息，\n\t\t%n是换行符\n    -->\n    %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n\n\n```\n\n### SpringBoot修改日志的默认配置\n\n```properties\n# 也可以指定一个包路径 logging.level.com.xxx=error\nlogging.level.root=error\n\n\n#logging.path=\n# 不指定路径在当前项目下生成springboot.log日志\n# 可以指定完整的路径；\n#logging.file=G:/springboot.log\n\n# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件\nlogging.path=/spring/log\n\n#  在控制台输出的日志的格式\nlogging.pattern.console=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n\n# 指定文件中日志输出的格式\nlogging.pattern.file=%d{yyyy-MM-dd} === [%thread] === %-5level === %logger{50} ==== %msg%n\n```\n\n| logging.file | logging.path | Example  | Description                        |\n| ------------ | ------------ | -------- | ---------------------------------- |\n| (none)       | (none)       |          | 只在控制台输出                     |\n| 指定文件名   | (none)       | my.log   | 输出日志到my.log文件               |\n| (none)       | 指定目录     | /var/log | 输出到指定目录的 spring.log 文件中 |\n\n### 指定配置\n\n给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了\n\n|     Logging System      | Customization                                                |\n| :---------------------: | ------------------------------------------------------------ |\n|         Logback         | `logback-spring.xml`, `logback-spring.groovy`, `logback.xml` or `logback.groovy` |\n|         Log4j2          | `log4j2-spring.xml` or `log4j2.xml`                          |\n| JDK (Java Util Logging) | `logging.properties`                                         |\n\nlogback.xml：直接就被日志框架识别了；\n\n**logback-spring.xml**：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能\n\n```xml\n<springProfile name=\"staging\">\n    <!-- configuration to be enabled when the \"staging\" profile is active -->\n  \t可以指定某段配置只在某个环境下生效\n</springProfile>\n\n```\n\n如：\n\n```xml\n<appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <!--\n        日志输出格式：\n\t\t\t%d表示日期时间，\n\t\t\t%thread表示线程名，\n\t\t\t%-5level：级别从左显示5个字符宽度\n\t\t\t%logger{50} 表示logger名字最长50个字符，否则按照句点分割。 \n\t\t\t%msg：日志消息，\n\t\t\t%n是换行符\n        -->\n        <layout class=\"ch.qos.logback.classic.PatternLayout\">\n            <springProfile name=\"dev\">\n                <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} ----> [%thread] ---> %-5level %logger{50} - %msg%n</pattern>\n            </springProfile>\n            <springProfile name=\"!dev\">\n                <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} ==== [%thread] ==== %-5level %logger{50} - %msg%n</pattern>\n            </springProfile>\n        </layout>\n    </appender>\n```\n\n\n\n如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误\n\n `no applicable action for [springProfile]`\n\n## 切换日志框架\n\n可以按照slf4j的日志适配图，进行相关的切换；\n\nslf4j+log4j的方式；\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-web</artifactId>\n  <exclusions>\n    <exclusion>\n      <artifactId>logback-classic</artifactId>\n      <groupId>ch.qos.logback</groupId>\n    </exclusion>\n    <exclusion>\n      <artifactId>log4j-over-slf4j</artifactId>\n      <groupId>org.slf4j</groupId>\n    </exclusion>\n  </exclusions>\n</dependency>\n\n<dependency>\n  <groupId>org.slf4j</groupId>\n  <artifactId>slf4j-log4j12</artifactId>\n</dependency>\n\n```\n\n\n\n\n\n切换为log4j2\n\n```xml\n   <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n            <exclusions>\n                <exclusion>\n                    <artifactId>spring-boot-starter-logging</artifactId>\n                    <groupId>org.springframework.boot</groupId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-log4j2</artifactId>\n</dependency>\n```","tags":["springboot"],"categories":["springboot"]},{"title":"SpringBoot整合Mybatis","url":"/2020/05/23/springboot/mybatis/","content":"\n# SpringBoot整合Mybatis\n\n## 引入依赖\n\n```xml\n<dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-thymeleaf</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis.spring.boot</groupId>\n            <artifactId>mybatis-spring-boot-starter</artifactId>\n            <version>2.1.1</version>\n        </dependency>\n\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <scope>runtime</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n            <exclusions>\n                <exclusion>\n                    <groupId>org.junit.vintage</groupId>\n                    <artifactId>junit-vintage-engine</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid-spring-boot-starter</artifactId>\n            <version>1.1.20</version>\n        </dependency>\n    </dependencies>\n```\n\n依赖关系\n\n![1574423628318](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574423628318.png)\n\n\n\n## 项目构建\n\n1. 在resources下创建`department.sql`和`employee.sql`，项目启动时创建表\n\n   ```sql\n   DROP TABLE IF EXISTS `department`;\n   CREATE TABLE `department` (\n     `id` int(11) NOT NULL AUTO_INCREMENT,\n     `departmentName` varchar(255) DEFAULT NULL,\n     PRIMARY KEY (`id`)\n   ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;\n   ```\n\n   ```sql\n   DROP TABLE IF EXISTS `employee`;\n   CREATE TABLE `employee` (\n     `id` int(11) NOT NULL AUTO_INCREMENT,\n     `lastName` varchar(255) DEFAULT NULL,\n     `email` varchar(255) DEFAULT NULL,\n     `gender` int(2) DEFAULT NULL,\n     `d_id` int(11) DEFAULT NULL,\n     PRIMARY KEY (`id`)\n   ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;\n   \n   ```\n\n2. 实体类\n\n   <details>\n\n   <summary>Department</summary>\n\n   ```java\n   public class Department implements Serializable {\n       Integer id;\n       String departmentName;\n   \n       public Integer getId() {\n           return id;\n       }\n   \n       public void setId(Integer id) {\n           this.id = id;\n       }\n   \n       public String getDepartmentName() {\n           return departmentName;\n       }\n   \n       public void setDepartmentName(String departmentName) {\n           this.departmentName = departmentName;\n       }\n   }\n   ```\n\n   </details>\n\n   <details>\n\n   <summary>Employee</summary>\n\n   ```java\n   public class Employee {\n       Integer id;\n       String lastName;\n       String email;\n       Integer gender;\n       Integer d_id;\n   \n       public Integer getId() {\n           return id;\n       }\n   \n       public void setId(Integer id) {\n           this.id = id;\n       }\n   \n       public String getLastName() {\n           return lastName;\n       }\n   \n       public void setLastName(String lastName) {\n           this.lastName = lastName;\n       }\n   \n       public String getEmail() {\n           return email;\n       }\n   \n       public void setEmail(String email) {\n           this.email = email;\n       }\n   \n       public Integer getGender() {\n           return gender;\n       }\n   \n       public void setGender(Integer gender) {\n           this.gender = gender;\n       }\n   \n       public Integer getD_id() {\n           return d_id;\n       }\n   \n       public void setD_id(Integer d_id) {\n           this.d_id = d_id;\n       }\n   }\n   ```\n\n   </details>\n\n   \n\n3. 配置文件\n\n   ```yaml\n   spring:\n     datasource:\n       username: root\n       password: root\n       url: jdbc:mysql://172.16.145.137:3306/springboot\n       driver-class-name: com.mysql.cj.jdbc.Driver\n       initialization-mode: always\n       type: com.alibaba.druid.pool.DruidDataSource\n       druid:\n         # 连接池配置\n         # 配置初始化大小、最小、最大\n         initial-size: 1\n         min-idle: 1\n         max-active: 20\n         # 配置获取连接等待超时的时间\n         max-wait: 3000\n         validation-query: SELECT 1 FROM DUAL\n         test-on-borrow: false\n         test-on-return: false\n         test-while-idle: true\n         pool-prepared-statements: true\n         time-between-eviction-runs-millis: 60000\n         min-evictable-idle-time-millis: 300000\n         filters: stat,wall,slf4j\n         # 配置web监控,默认配置也和下面相同(除用户名密码，enabled默认false外)，其他可以不配\n         web-stat-filter:\n           enabled: true\n           url-pattern: /*\n           exclusions: \"*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*\"\n         stat-view-servlet:\n           enabled: true\n           url-pattern: /druid/*\n           login-username: admin\n           login-password: root\n           allow: 127.0.0.1\n       schema:\n         - classpath:department.sql\n         - classpath:employee.sql\n   ```\n\n## Mybatis增删改查\n\n1. 创建mapper接口\n\n   ```java\n   @Mapper\n   public interface DepartmentMapper {\n   \n       @Select(\"select * from department\")\n       public List<Department> selectAll();\n   \n       @Select(\"select * from department where id=#{id}\")\n       public Department selectById(Integer id);\n   \n       @Options(useGeneratedKeys = true, keyProperty = \"id\")\n       @Insert(\"insert into department(departmentName) values(#{departmentName})\")\n       public int save(Department department);\n   \n       @Update(\"update department set departmentName=#{departmentName}\")\n       public int update(Department department);\n   \n       @Delete(\"delete from department where id =#{id}\")\n       public int delete(Integer id);\n   }\n   ```\n\n2. 创建Controller\n\n   ```java\n   @RestController\n   public class DepartmentController {\n   \n       @Autowired\n       private DepartmentMapper departmentMapper;\n   \n       @RequestMapping(\"/dep/{id}\")\n       public List<Department> getDepById(@PathVariable Integer id) {\n           return departmentMapper.selectAll();\n       }\n   \n       @RequestMapping(\"/dep\")\n       public Department getDepById(Department department) {\n           departmentMapper.save(department);\n           return department;\n       }\n   }\n   ```\n\n   \n\n3. 访问：<http://localhost:8080/dep?departmentName=PeppaPig> 添加一条数据\n\n   访问：<http://localhost:8080/dep/1>获取数据\n\n## Mybatis配置\n\n### 开启驼峰命名法\n\n我们的实体类和表中的列名一致，一点问题也没有\n\n我们把department表的departmentName列名改为department_name看看会发生什么\n\n访问：<http://localhost:8080/dep/1>获取数据\n\n```\n[{\"id\":1,\"departmentName\":null}]\n```\n\n由于列表和属性名不一致，所以就没有封装进去，我们表中的列名和实体类属性名都是遵循驼峰命名规则的，可以开启mybatis的开启驼峰命名配置\n\n```yaml\nmybatis:\n  configuration:\n    map-underscore-to-camel-case: true\n```\n\n然后重启项目，重新插入数据，再查询就发现可以封装进去了\n\n也可以通过向spring容器中注入`org.mybatis.spring.boot.autoconfigure.ConfigurationCustomizer`的方法设置mybatis参数\n\n```JAVA\n@Configuration\npublic class MybatisConfig {\n\n    @Bean\n    public ConfigurationCustomizer mybatisConfigurationCustomizer() {\n        return new ConfigurationCustomizer() {\n            @Override\n            public void customize(org.apache.ibatis.session.Configuration configuration) {\n                configuration.setMapUnderscoreToCamelCase(true);\n            }\n        };\n    }\n}\n```\n\n\n\n![1574430056512](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574430056512.png)\n\n![1574430280791](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574430280791.png)\n\n## Mapper扫描\n\n使用`@mapper注解`的类可以被扫描到容器中，但是每个Mapper都要加上这个注解就是一个繁琐的工作，能不能直接扫描某个包下的所有Mapper接口呢，当然可以，在springboot启动类上加上`@MapperScan`\n\n```java\n@MapperScan(\"cn.clboy.springbootmybatis.mapper\")\n@SpringBootApplication\npublic class SpringbootMybatisApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringbootMybatisApplication.class, args);\n    }\n\n}\n```\n\n## 使用xml配置文件\n\n1. 创建mybatis全局配置文件\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n   <configuration>\n       <typeAliases>\n           <package name=\"cn.clboy.springbootmybatis.model\"/>\n       </typeAliases>\n   </configuration>\n   ```\n\n2. 创建EmployeeMapper接口\n\n   ```java\n   public interface EmployeeMapper {\n   \n       List<Employee> selectAll();\n   \n       int save(Employee employee);\n   }\n   ```\n\n3. 创建EmployeeMapper.xml映射文件\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n   <mapper namespace=\"cn.clboy.springbootmybatis.mapper.EmployeeMapper\">\n       <select id=\"selectAll\" resultType=\"employee\">\n           SELECT * FROM employee\n       </select>\n       <insert id=\"save\" parameterType=\"employee\" useGeneratedKeys=\"true\" keyProperty=\"id\">\n          INSERT INTO employee(lastName,email,gender,d_id) VALUES (#{lastName},#{email},#{gender},#{d_id})\n       </insert>\n   </mapper>\n   ```\n\n4. 配置文件(application.yaml)中指定配置文件和映射文件的位置\n\n   ```yaml\n   mybatis:\n     config-location: classpath:mybatis/mybatis-config.xml\n     mapper-locations: classpath:mybatis/mapper/*.xml\n   ```\n\n5. 给表中插入两个数据，用于测试\n\n   ```sql\n    INSERT INTO employee(lastName,email,gender,d_id) VALUES ('张三','123456@qq.com',1,1);\n    INSERT INTO employee(lastName,email,gender,d_id) VALUES ('lisi','245612@qq.com',1,1);\n   ```\n\n6. 创建EmployeeController\n\n   ```java\n   @RestController\n   public class EmployeeController {\n   \n       @Autowired\n       private EmployeeMapper employeeMapper;\n   \n       @RequestMapping(\"/emp/list\")\n       public List<Employee> getALl() {\n           return employeeMapper.selectAll();\n       }\n   \n       @RequestMapping(\"/emp/{id}\")\n       public Employee save(Employee employee) {\n           employeeMapper.save(employee);\n           return employee;\n       }\n   }\n   ```\n\n   访问：<http://localhost:8080/emp/list>\n\n","tags":["springboot"],"categories":["springboot"]},{"title":"restful风格的增删改查","url":"/2020/05/23/springboot/restfulcrud/","content":"\n\n# restful风格的增删改查\n\n静态资源文件：https://www.lanzous.com/i7eenib\n\n1. 将静态资源(css,img,js)添加到项目中，放到springboot[默认的静态资源文件夹下](backend/springboot/helloweb?id=非webjars，自己的静态资源怎么访问)\n2. 将模板文件(html)放到[template文件夹下](backend/springboot/templateengine?id=thymeleaf%e4%bd%bf%e7%94%a8)\n\n![1573896827010](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573896827010.png)\n\n!> 如果你的静态资源明明放到了静态资源文件夹下却无法访问，请检查一下是不是在自定义的配置类上加了**@EnableWebMvc注解**\n\n## 默认访问首页\n\ntemplate文件加不是静态资源文件夹，默认是无法直接访问的，所以要添加视图映射\n\n```java\npackage cn.clboy.hellospringbootweb.config;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.ViewControllerRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n/**\n * @Author cloudlandboy\n * @Date 2019/11/16 下午3:32\n * @Since 1.0.0\n */\n\n@Configuration\npublic class MyMvcConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        registry.addViewController(\"/\").setViewName(\"login\");\n        registry.addViewController(\"/index\").setViewName(\"login\");\n        registry.addViewController(\"/index.html\").setViewName(\"login\");\n    }\n}\n```\n\n访问：<http://localhost:8080/>\n\n## i18n国际化\n\n1. 编写国际化配置文件，抽取页面需要显示的国际化消息\n\n   SpringBoot自动配置好了管理国际化资源文件的组件\n\n   ```java\n   @Configuration(\n       proxyBeanMethods = false\n   )\n   @ConditionalOnMissingBean(\n       name = {\"messageSource\"},\n       search = SearchStrategy.CURRENT\n   )\n   @AutoConfigureOrder(-2147483648)\n   @Conditional({MessageSourceAutoConfiguration.ResourceBundleCondition.class})\n   @EnableConfigurationProperties\n   public class MessageSourceAutoConfiguration {\n       private static final Resource[] NO_RESOURCES = new Resource[0];\n   \n       public MessageSourceAutoConfiguration() {\n       }\n   \n       @Bean\n       @ConfigurationProperties(\n           prefix = \"spring.messages\"\n       )\n       public MessageSourceProperties messageSourceProperties() {\n           return new MessageSourceProperties();\n       }\n   \n       @Bean\n       public MessageSource messageSource(MessageSourceProperties properties) {\n           ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();\n           if (StringUtils.hasText(properties.getBasename())) {\n               messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(properties.getBasename())));\n           }\n   \n           if (properties.getEncoding() != null) {\n               messageSource.setDefaultEncoding(properties.getEncoding().name());\n           }\n   \n           messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale());\n           Duration cacheDuration = properties.getCacheDuration();\n           if (cacheDuration != null) {\n               messageSource.setCacheMillis(cacheDuration.toMillis());\n           }\n   \n           messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat());\n           messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage());\n           return messageSource;\n       }\n   ```\n\n   创建i18n文件夹存放配置文件，文件名格式为`基础名(login)`+`语言代码(zh)`+`国家代码(CN)`\n\n   ![1573900332686](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573900332686.png)\n\n2. 在配置文件中添加国际化文件的位置和基础名\n\n   ```properties\n   spring.messages.basename=i18n.login\n   ```\n\n   如果配置文件中没有配置基础名，就在类路径下找基础名为`message`的配置文件\n\n3. 将页面文字改为获取国际化配置，格式`#{key}`\n\n   ```html\n   \t<body class=\"text-center\">\n   \t\t<form class=\"form-signin\" action=\"dashboard.html\">\n   \t\t\t<img class=\"mb-4\" src=\"asserts/img/bootstrap-solid.svg\" alt=\"\" width=\"72\" height=\"72\">\n   \t\t\t<h1 class=\"h3 mb-3 font-weight-normal\" th:text=\"#{login.tip}\">Please sign in</h1>\n   \t\t\t<label class=\"sr-only\">Username</label>\n   \t\t\t<input type=\"text\" class=\"form-control\" th:placeholder=\"#{login.username}\" placeholder=\"Username\" required=\"\" autofocus=\"\">\n   \t\t\t<label class=\"sr-only\">Password</label>\n   \t\t\t<input type=\"password\" class=\"form-control\" th:placeholder=\"#{login.password}\" placeholder=\"Password\" required=\"\">\n   \t\t\t<div class=\"checkbox mb-3\">\n   \t\t\t\t<label>\n             <input type=\"checkbox\" value=\"remember-me\"> [[#{login.remember}]]\n           </label>\n   \t\t\t</div>\n   \t\t\t<button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\" th:text=\"#{login.btn}\">Sign in</button>\n   \t\t\t<p class=\"mt-5 mb-3 text-muted\">© 2017-2018</p>\n   \t\t\t<a class=\"btn btn-sm\">中文</a>\n   \t\t\t<a class=\"btn btn-sm\">English</a>\n   \t\t</form>\n   \n   \t</body>\n   ```\n\n4. 然后就可以更改浏览器语言，页面就会使用对应的国际化配置文件\n\n      ![1573900071209](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573900071209.png)\n\n5. 原理\n\n   国际化Locale（区域信息对象）；\n\n   LocaleResolver（获取区域信息对象的组件）；\n\n   在springmvc配置类`WebMvcAutoConfiguration`中注册了该组件\n\n   ```java\n           @Bean\n   \t\t/**\n   \t\t  *前提是容器中不存在这个组件，\n   　　　　　　*所以使用自己的对象就要配置@Bean让这个条件不成立（实现LocaleResolver 即可）\n   　　　　　　*/\n           @ConditionalOnMissingBean\n   \t\t\n   \t\t/**\n             * 如果在application.properties中有配置国际化就用配置文件的\n             * 没有配置就用AcceptHeaderLocaleResolver 默认request中获取\n             */\n           @ConditionalOnProperty(\n               prefix = \"spring.mvc\",\n               name = {\"locale\"}\n           )\n           public LocaleResolver localeResolver() {\n               if (this.mvcProperties.getLocaleResolver() == org.springframework.boot.autoconfigure.web.servlet.WebMvcProperties.LocaleResolver.FIXED) {\n                   return new FixedLocaleResolver(this.mvcProperties.getLocale());\n               } else {\n                   AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();\n                   localeResolver.setDefaultLocale(this.mvcProperties.getLocale());\n                   return localeResolver;\n               }\n           }\n   ```\n\n   默认的就是根据请求头带来的区域信息获取Locale进行国际化\n\n   ```java\n       public Locale resolveLocale(HttpServletRequest request) {\n           Locale defaultLocale = this.getDefaultLocale();\n           if (defaultLocale != null && request.getHeader(\"Accept-Language\") == null) {\n               return defaultLocale;\n           } else {\n               Locale requestLocale = request.getLocale();\n               List<Locale> supportedLocales = this.getSupportedLocales();\n               if (!supportedLocales.isEmpty() && !supportedLocales.contains(requestLocale)) {\n                   Locale supportedLocale = this.findSupportedLocale(request, supportedLocales);\n                   if (supportedLocale != null) {\n                       return supportedLocale;\n                   } else {\n                       return defaultLocale != null ? defaultLocale : requestLocale;\n                   }\n               } else {\n                   return requestLocale;\n               }\n           }\n       }\n   ```\n\n\n\n\n## 点击连接切换语言\n\n\n6. 实现点击连接切换语言，而不是更改浏览器\n\n   - 修改页面，点击连接携带语言参数\n\n     ```html\n     \t\t\t<a class=\"btn btn-sm\" href=\"?l=zh_CN\">中文</a>\n     \t\t\t<a class=\"btn btn-sm\" href=\"?l=en_US\">English</a>\n     ```\n\n   - 自己实现区域信息解析器\n\n     ```java\n     public class MyLocaleResolver implements LocaleResolver {\n     \n         @Override\n         public Locale resolveLocale(HttpServletRequest httpServletRequest) {\n             //获取请求参数中的语言\n             String language = httpServletRequest.getParameter(\"l\");\n             //没带区域信息参数就用系统默认的\n             Locale locale = Locale.getDefault();\n             if (!StringUtils.isEmpty(language)) {\n                 //提交的参数是zh_CN （语言代码_国家代码）\n                 String[] s = language.split(\"_\");\n     \n                 locale = new Locale(s[0], s[1]);\n     \n             }\n     \n             return locale;\n         }\n     \n         @Override\n         public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) {\n     \n         }\n     }\n     ```\n\n   - 在配置类中将其注册到容器中\n\n     ```java\n     @Configuration\n     public class MyMvcConfig implements WebMvcConfigurer {\n     \n         @Override\n         public void addViewControllers(ViewControllerRegistry registry) {\n             registry.addViewController(\"/\").setViewName(\"login\");\n             registry.addViewController(\"/index\").setViewName(\"login\");\n             registry.addViewController(\"/index.html\").setViewName(\"login\");\n         }\n     \n         @Bean\n         public LocaleResolver localeResolver() {\n             return new MyLocaleResolver();\n         }\n     \n     }\n     ```\n\n\n\n!> 如果没有生效，请检查`@Bean`的那个方法的名称是否为`localeResolver`\n\n\n\n## 实现登录功能\n\n1. 提供登录的controller\n\n   ```java\n   @Controller\n   public class UserController {\n   \n       @PostMapping(\"/user/login\")\n       public String login(@RequestParam String username, @RequestParam String password, HttpSession session, Model model) {\n           if (!StringUtils.isEmpty(username) && \"123456\".equals(password)) {\n   \n               //登录成功，把用户信息方法哦session中，防止表单重复提交，重定向到后台页面\n               session.setAttribute(\"loginUser\", username);\n               return \"redirect:/main.html\";\n           }\n           //登录失败,返回到登录页面\n           model.addAttribute(\"msg\", \"用户名或密码错误！\");\n           return \"login\";\n       }\n   }\n   ```\n\n   \n\n2. 修改表单提交地址，输入框添加name值与参数名称对应\n\n   ```html\n   \t\t<form class=\"form-signin\" action=\"dashboard.html\" th:action=\"@{/user/login}\" method=\"post\">\n   \t\t\t<img class=\"mb-4\" src=\"asserts/img/bootstrap-solid.svg\" alt=\"\" width=\"72\" height=\"72\">\n   \t\t\t<h1 class=\"h3 mb-3 font-weight-normal\" th:text=\"#{login.tip}\">Please sign in</h1>\n   \t\t\t<label class=\"sr-only\">Username</label>\n   \t\t\t<input type=\"text\" name=\"username\" class=\"form-control\" th:placeholder=\"#{login.username}\" placeholder=\"Username\" autofocus=\"\">\n   \t\t\t<label class=\"sr-only\">Password</label>\n   \t\t\t<input type=\"password\" name=\"password\" class=\"form-control\" th:placeholder=\"#{login.password}\" placeholder=\"Password\" required=\"\">\n   \t\t\t<div class=\"checkbox mb-3\">\n   \t\t\t\t<label>\n             <input type=\"checkbox\" value=\"remember-me\"> [[#{login.remember}]]\n           </label>\n   \t\t\t</div>\n   \t\t\t<button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\" th:text=\"#{login.btn}\">Sign in</button>\n   \t\t\t<p class=\"mt-5 mb-3 text-muted\">© 2017-2018</p>\n   \t\t\t<a class=\"btn btn-sm\" href=\"?l=zh_CN\">中文</a>\n   \t\t\t<a class=\"btn btn-sm\" href=\"?l=en_US\">English</a>\n   \t\t</form>\n   ```\n\n2. 由于登录失败是转发，所以页面的静态资源请求路径会不正确，使用模板引擎语法替换\n\n   ```java\n   <link  href=\"asserts/css/bootstrap.min.css\" th:href=\"@{/asserts/css/bootstrap.min.css}\" rel=\"stylesheet\">\n   <!-- Custom styles for this template -->\n   <link href=\"asserts/css/signin.css\" th:href=\"@{/asserts/css/signin.css}\" rel=\"stylesheet\">\n   ```\n\n2. 添加登录失败页面显示\n\n   ```html\n   <h1 class=\"h3 mb-3 font-weight-normal\" th:text=\"#{login.tip}\">Please sign in</h1>\n   <!--msg存在才显示该p标签-->\n   <p th:text=\"${msg}\" th:if=\"${not #strings.isEmpty(msg)}\" style=\"color: red\"></p>\n   ```\n\n   \n\n\n\n## 修改页面立即生效\n\n```properties\n# 禁用缓存\nspring.thymeleaf.cache=false\n```\n\n在页面修改完成以后按快捷键`ctrl+f9`，重新编译；\n\n## 拦截器进行登陆检查\n\n1. 实现拦截器\n\n   ```java\n   package cn.clboy.hellospringbootweb.interceptor;\n   \n   import org.springframework.web.servlet.HandlerInterceptor;\n   import org.springframework.web.servlet.ModelAndView;\n   \n   import javax.servlet.http.HttpServletRequest;\n   import javax.servlet.http.HttpServletResponse;\n   \n   /**\n    * @Author cloudlandboy\n    * @Date 2019/11/17 上午11:44\n    * @Since 1.0.0\n    */\n   \n   public class LoginHandlerInterceptor implements HandlerInterceptor {\n       @Override\n       public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n   \n           Object loginUser = request.getSession().getAttribute(\"loginUser\");\n           if (loginUser == null) {\n               //未登录，拦截，并转发到登录页面\n               request.setAttribute(\"msg\", \"您还没有登录，请先登录！\");\n               request.getRequestDispatcher(\"/index\").forward(request, response);\n               return false;\n           }\n           return true;\n       }\n   \n       @Override\n       public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n   \n       }\n   \n       @Override\n       public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n   \n       }\n   }\n   ```\n\n2. 注册拦截器\n\n   ```java\n   package cn.clboy.hellospringbootweb.config;\n   \n   import cn.clboy.hellospringbootweb.interceptor.LoginHandlerInterceptor;\n   import org.springframework.context.annotation.Bean;\n   import org.springframework.context.annotation.Configuration;\n   import org.springframework.web.servlet.LocaleResolver;\n   import org.springframework.web.servlet.config.annotation.InterceptorRegistry;\n   import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;\n   import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n   \n   /**\n    * @Author cloudlandboy\n    * @Date 2019/11/16 下午3:32\n    * @Since 1.0.0\n    */\n   \n   @Configuration\n   public class MyMvcConfig implements WebMvcConfigurer {\n   \t//定义不拦截路径\n       private static final String[] excludePaths = {\"/\", \"/index\", \"/index.html\", \"/user/login\", \"/asserts/**\"};\n   \n       @Override\n       public void addViewControllers(ViewControllerRegistry registry) {\n           registry.addViewController(\"/\").setViewName(\"login\");\n           registry.addViewController(\"/index\").setViewName(\"login\");\n           registry.addViewController(\"/index.html\").setViewName(\"login\");\n           registry.addViewController(\"/main.html\").setViewName(\"dashboard\");\n       }\n   \n       @Bean\n       public LocaleResolver localeResolver() {\n           return new MyLocaleResolver();\n       }\n   \n       @Override\n       public void addInterceptors(InterceptorRegistry registry) {\n           //添加不拦截的路径，SpringBoot已经做好了静态资源映射，所以我们不用管\n           registry.addInterceptor(new LoginHandlerInterceptor())\n                   .excludePathPatterns(excludePaths);\n       }\n   }\n   ```\n\n   !> 在spring2.0+的版本中，只要用户自定义了拦截器，则静态资源会被拦截。但是在spring1.0+的版本中，是不会拦截静态资源的。\n\n   因此，在使用spring2.0+时，配置拦截器之后，我们要把静态资源的路径加入到不拦截的路径之中。\n\n\n\n## CRUD-员工列表\n\n使用rest风格\n\n| 实验功能                             | 请求URI | 请求方式 |\n| ------------------------------------ | ------- | -------- |\n| 查询所有员工                         | emps    | GET      |\n| 查询某个员工(来到修改页面)           | emp/1   | GET      |\n| 来到添加页面                         | emp     | GET      |\n| 添加员工                             | emp     | POST     |\n| 来到修改页面（查出员工进行信息回显） | emp/1   | GET      |\n| 修改员工                             | emp     | PUT      |\n| 删除员工                             | emp/1   | DELETE   |\n\n1. 为了页面结构清晰，在template文件夹下新建emp文件夹，将list.html移动到emp文件夹下\n\n2. 将dao层和实体层[java代码](https://www.lanzous.com/i7eenib)复制到项目中`dao`，`entities`\n\n3. 添加员工controller，实现查询员工列表的方法\n\n   ```java\n   @Controller\n   public class EmpController {\n   \n       @Autowired\n       private EmployeeDao employeeDao;\n   \n       @GetMapping(\"/emps\")\n       public String emps(Model model) {\n           Collection<Employee> empList = employeeDao.getAll();\n           model.addAttribute(\"emps\", empList);\n           return \"emp/list\";\n       }\n       \n   }\n   ```\n\n4. 修改后台页面，更改左侧侧边栏，将`customer`改为`员工列表`，并修改请求路径\n\n   ```html\n   <li class=\"nav-item\">\n   \t<a class=\"nav-link\" th:href=\"@{/emps}\">\n   \t\t<svg .....>\n   \t\t\t......\n   \t\t</svg>\n   \t\t员工列表\n   \t</a>\n   </li>\n   ```\n\n5. 同样emp/list页面的左边侧边栏是和后台页面一模一样的，每个都要修改很麻烦，接下来，抽取公共片段\n\n\n\n## thymeleaf公共页面元素抽取\n\n### 语法\n\n~{templatename::selector}：模板名::选择器\n\n~{templatename::fragmentname}:模板名::片段名\n\n```html\n/*公共代码片段*/\n<footer th:fragment=\"copy\">\n\t&copy; 2011 The Good Thymes Virtual Grocery\n</footer>\n\n/*引用代码片段*/\n<div th:insert=\"~{footer :: copy}\"></di\n    \n/*（〜{...}包围是完全可选的，所以上⾯的代码 将等价于：*/\n<div th:insert=\"footer :: copy\"></di\n```\n\n具体参考官方文档：<https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#including-template-fragments>\n\n三种引入公共片段的th属性：\n\n- `th:insert`：将公共片段整个插入到声明引入的元素中\n- `th:replace`：将声明引入的元素替换为公共片段\n- `th:include`：将被引入的片段的内容包含进这个标签中\n\n```html\n/*公共片段*/\n<footer th:fragment=\"copy\">\n&copy; 2011 The Good Thymes Virtual Grocery\n</footer>\n\n/*引入方式*/\n<div th:insert=\"footer :: copy\"></div>\n<div th:replace=\"footer :: copy\"></div>\n<div th:include=\"footer :: copy\"></div>\n\n\n/*效果*/\n<div>\n    <footer>\n    &copy; 2011 The Good Thymes Virtual Grocery\n    </footer>\n</div>\n\n<footer>\n&copy; 2011 The Good Thymes Virtual Grocery\n</footer>\n\n<div>\n&copy; 2011 The Good Thymes Virtual Grocery\n</div>\n```\n\n\n\n### 后台页面抽取\n\n1. 将后台主页中的顶部导航栏作为片段，在list页面引入\n\n   **dashboard.html：**\n\n   ```html\n   \t\t<nav th:fragment=\"topbar\" class=\"navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0\">\n   \t\t\t<a class=\"navbar-brand col-sm-3 col-md-2 mr-0\" href=\"http://getbootstrap.com/docs/4.0/examples/dashboard/#\">Company name</a>\n   \t\t\t<input class=\"form-control form-control-dark w-100\" type=\"text\" placeholder=\"Search\" aria-label=\"Search\">\n   \t\t\t<ul class=\"navbar-nav px-3\">\n   \t\t\t\t<li class=\"nav-item text-nowrap\">\n   \t\t\t\t\t<a class=\"nav-link\" href=\"http://getbootstrap.com/docs/4.0/examples/dashboard/#\">Sign out</a>\n   \t\t\t\t</li>\n   \t\t\t</ul>\n   \t\t</nav>\n   ```\n\n   **list.html：**\n\n   ```html\n   <body>\n   \n   <div th:replace=\"dashboard::topbar\"></div>\n    \n   ......\n   ```\n\n2. 使用选择器的方式 抽取左侧边栏代码\n\n   **dashboard.html：**\n\n   ```html\n   <div class=\"container-fluid\">\n   \t<div class=\"row\">\n   \t\t<nav id=\"sidebar\" class=\"col-md-2 d-none d-md-block bg-light sidebar\" ......\n   ```\n\n   **list.html：**\n\n   ```html\n   <div class=\"container-fluid\">\n       <div class=\"row\">\n   \t\t<div th:replace=\"dashboard::#sidebar\"></div>\n           ......\n   ```\n\n   \n### 引入片段传递参数\n\n实现点击当前项高亮\n\n将`dashboard.html`中的公共代码块抽出为单独的html文件，放到commos文件夹下\n\n在引入代码片段的时候可以传递参数，然后在sidebar代码片段模板中判断当前点击的链接\n\n语法：\n\n```\n~{templatename::selector(变量名=值)}\n\n/*或者在定义代码片段时，定义参数*/\n<nav th:fragment=\"topbar(A,B)\"\n/*引入时直接传递参数*/\n~{templatename::fragmentname(A值,B值)}\n```\n\n\n\n**topbar.html**\n\n```html\n<!doctype html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<body>\n<nav th:fragment=\"topbar\" class=\"navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0\">\n    <a class=\"navbar-brand col-sm-3 col-md-2 mr-0\" href=\"http://getbootstrap.com/docs/4.0/examples/dashboard/#\">Company\n        name</a>\n    <input class=\"form-control form-control-dark w-100\" type=\"text\" placeholder=\"Search\" aria-label=\"Search\">\n    <ul class=\"navbar-nav px-3\">\n        <li class=\"nav-item text-nowrap\">\n            <a class=\"nav-link\" href=\"http://getbootstrap.com/docs/4.0/examples/dashboard/#\">Sign out</a>\n        </li>\n    </ul>\n</nav>\n</body>\n</html>\n```\n\n**sidebar.html**\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<nav id=\"sidebar\" class=\"col-md-2 d-none d-md-block bg-light sidebar\">\n    <div class=\"sidebar-sticky\">\n        <ul class=\"nav flex-column\">\n            <li class=\"nav-item\">\n                <a class=\"nav-link active\" th:class=\"${currentURI}=='main.html'?'nav-link active':'nav-link'\" th:href=\"@{/main.html}\">\n  \t.....\n</body>\n</html>\n```\n\n然后在`dashboard.html`和`list.html`中引入\n\n```html\n<body>\n<div th:replace=\"commons/topbar::topbar\"></div>\n<div class=\"container-fluid\">\n    <div class=\"row\">\n        <div th:replace=\"commons/sidebar::#sidebar(currentURI='main.html')\"></div>\n\t\t......\n```\n\n```html\n<body>\n<div th:replace=\"commons/topbar::topbar\"></div>\n\n<div class=\"container-fluid\">\n    <div class=\"row\">\n        <div th:replace=\"commons/sidebar::#sidebar(currentURI='emps')\"></div>\n        ......\n```\n\n1. 显示员工数据，添加增删改按钮\n\n   ```html\n           <main role=\"main\" class=\"col-md-9 ml-sm-auto col-lg-10 pt-3 px-4\">\n               <h2>\n                   <button class=\"btn btn-sm btn-success\">添加员工</button>\n               </h2>\n               <div class=\"table-responsive\">\n                   <table class=\"table table-striped table-sm\">\n                       <thead>\n                       <tr>\n                           <th>员工号</th>\n                           <th>姓名</th>\n                           <th>邮箱</th>\n                           <th>性别</th>\n                           <th>部门</th>\n                           <th>生日</th>\n                           <th>操作</th>\n                       </tr>\n                       </thead>\n                       <tbody>\n                       <tr th:each=\"emp:${emps}\">\n                           <td th:text=\"${emp.id}\"></td>\n                           <td th:text=\"${emp.lastName}\"></td>\n                           <td th:text=\"${emp.email}\"></td>\n                           <td th:text=\"${emp.gender}==1?'男':'女'\"></td>\n                           <td th:text=\"${emp.department.departmentName}\"></td>\n                           <td th:text=\"${#dates.format(emp.birth,'yyyy-MM-dd')}\"></td>\n                           <td>\n                               <button class=\"btn btn-sm btn-primary\">修改</button>\n                               <button class=\"btn btn-sm btn-danger\">删除</button>\n                           </td>\n                       </tr>\n                       </tbody>\n                   </table>\n               </div>\n           </main>\n   ```\n\n   \n\n### 员工添加\n\n1. 创建员工添加页面`add.html`\n\n   ```html\n   ......\n   <body>\n   <div th:replace=\"commons/topbar::topbar\"></div>\n   \n   <div class=\"container-fluid\">\n       <div class=\"row\">\n           <div th:replace=\"commons/sidebar::#sidebar(currentURI='emps')\"></div>\n           <main role=\"main\" class=\"col-md-9 ml-sm-auto col-lg-10 pt-3 px-4\">\n               <form>\n                   <div class=\"form-group\">\n                       <label>LastName</label>\n                       <input name=\"lastName\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\">\n                   </div>\n                   <div class=\"form-group\">\n                       <label>Email</label>\n                       <input  name=\"email\" type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\">\n                   </div>\n                   <div class=\"form-group\">\n                       <label>Gender</label><br/>\n                       <div class=\"form-check form-check-inline\">\n                           <input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\">\n                           <label class=\"form-check-label\">男</label>\n                       </div>\n                       <div class=\"form-check form-check-inline\">\n                           <input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\">\n                           <label class=\"form-check-label\">女</label>\n                       </div>\n                   </div>\n                   <div class=\"form-group\">\n                       <label>department</label>\n                       <select name=\"department.id\" class=\"form-control\">\n                           <option th:each=\"dept:${departments}\" th:text=\"${dept.departmentName}\" th:value=\"${dept.id}\"></option>\n                       </select>\n                   </div>\n                   <div class=\"form-group\">\n                       <label>Birth</label>\n                       <input name=\"birth\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\">\n                   </div>\n                   <button type=\"submit\" class=\"btn btn-primary\">添加</button>\n               </form>\n           </main>\n       </div>\n   </div>\n   ......\n   ```\n\n2. 点击链接跳转到添加页面\n\n   ```html\n   <a href=\"/emp\" th:href=\"@{/emp}\" class=\"btn btn-sm btn-success\">添加员工</a>\n   ```\n\n3. `EmpController`添加映射方法\n\n   ```java\n       @Autowired\n       private DepartmentDao departmentDao;\n   \n       @GetMapping(\"/emp\")\n       public String toAddPage(Model model) {\n           //准备部门下拉框数据\n           Collection<Department> departments = departmentDao.getDepartments();\n           model.addAttribute(\"departments\",departments);\n           return \"emp/add\";\n       }\n   ```\n\n   \n\n4. 修改页面遍历添加下拉选项\n\n   ```html\n   <select class=\"form-control\">\n       <option th:each=\"dept:${departments}\" th:text=\"${dept.departmentName}\"></option>\n   </select>\n   ```\n\n5. 表单提交，添加员工\n\n   ```html\n   <form th:action=\"@{/emp}\" method=\"post\">\n   ```\n\n   ```java\n       @PostMapping(\"/emp\")\n       public String add(Employee employee) {\n           System.out.println(employee);\n           //模拟添加到数据库\n           employeeDao.save(employee);\n           //添加成功重定向到列表页面\n           return \"redirect:/emps\";\n       }\n   ```\n\n\n\n### 日期格式修改\n\n!> 表单提交的日期格式必须是`yyyy/MM/dd`的格式，可以在配置文件中修改格式\n\n```properties\nspring.mvc.date-format=yyyy-MM-dd\n```\n\n\n\n\n\n### 员工修改\n\n1. 点击按钮跳转到编辑页面\n\n   ```html\n    <a th:href=\"@{/emp/}+${emp.id}\" class=\"btn btn-sm btn-primary\">修改</a>\n   ```\n\n2. 添加编辑页面，表单的提交要为post方式，提供`_method`参数\n\n   ```html\n   <body>\n   <div th:replace=\"commons/topbar::topbar\"></div>\n   \n   <div class=\"container-fluid\">\n       <div class=\"row\">\n           <div th:replace=\"commons/sidebar::#sidebar(currentURI='emps')\"></div>\n           <main role=\"main\" class=\"col-md-9 ml-sm-auto col-lg-10 pt-3 px-4\">\n               <form th:action=\"@{/emp}\" method=\"post\">\n                   <!--员工id-->\n                   <input type=\"hidden\" name=\"id\" th:value=\"${emp.id}\">\n                   <!--http请求方式-->\n                   <input type=\"hidden\" name=\"_method\" value=\"put\">\n                   <div class=\"form-group\">\n                       <label>LastName</label>\n                       <input name=\"lastName\" th:value=\"${emp.lastName}\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\">\n                   </div>\n                   <div class=\"form-group\">\n                       <label>Email</label>\n                       <input  name=\"email\" th:value=\"${emp.email}\" type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\">\n                   </div>\n                   <div class=\"form-group\">\n                       <label>Gender</label><br/>\n                       <div class=\"form-check form-check-inline\">\n                           <input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\" th:checked=\"${emp.gender==1}\">\n                           <label class=\"form-check-label\">男</label>\n                       </div>\n                       <div class=\"form-check form-check-inline\">\n                           <input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\" th:checked=\"${emp.gender==0}\">\n                           <label class=\"form-check-label\">女</label>\n                       </div>\n                   </div>\n                   <div class=\"form-group\">\n                       <label>department</label>\n                       <select name=\"department.id\" class=\"form-control\">\n                           <option th:each=\"dept:${departments}\" th:value=\"${dept.id}\" th:selected=\"${dept.id}==${emp.department.id}\" th:text=\"${dept.departmentName}\"></option>\n                       </select>\n                   </div>\n                   <div class=\"form-group\">\n                       <label>Birth</label>\n                       <input name=\"birth\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\" th:value=\"${#dates.format(emp.birth,'yyyy-MM-dd')}\">\n                   </div>\n                   <button type=\"submit\" class=\"btn btn-primary\">添加</button>\n               </form>\n           </main>\n       </div>\n   </div>\n   \n   ......\n   ```\n\n3. Controller转发到编辑页面，回显员工信息\n\n   ```java\n       @GetMapping(\"/emp/{id}\")\n       public String toEditPage(@PathVariable Integer id, Model model) {\n           Employee employee = employeeDao.get(id);\n           //准备部门下拉框数据\n           Collection<Department> departments = departmentDao.getDepartments();\n           model.addAttribute(\"emp\", employee).addAttribute(\"departments\", departments);\n           return \"emp/edit\";\n       }\n   ```\n\n4. 提交表单修改员工信息\n\n   ```java\n       @PutMapping(\"/emp\")\n       public String update(Employee employee) {\n           employeeDao.save(employee);\n           return \"redirect:/emps\";\n       }\n   ```\n\n\n\n\n\n### 员工删除\n\n1. 点击删除提交发出delete请求\n\n   ```html\n       @DeleteMapping(\"/emp/{id}\")\n       public String delete(@PathVariable String id){\n           employeeDao.delete(id);\n           return \"redirect:/emps\";\n       }\n   ```\n\n   !> 如果提示不支持POST请求，在确保代码无误的情况下查看是否配置启动`HiddenHttpMethodFilter`\n\n   ```properties\n   spring.mvc.hiddenmethod.filter.enabled=true\n   ```\n\n   ![1573987255217](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573987255217.png)\n\n   这个好像是2.0版本以后修改的\n\n   ![1573988088629](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573988088629.png)\n\n   !> 如果删除不掉，请修改`EmployeeDao`，把String转为Integer类型\n\n   ```java\n       public void delete(String id) {\n           employees.remove(Integer.parseInt(id));\n       }\n   ```\n\n   \n\n\n\n\n\n","tags":["springboot"],"categories":["springboot"]},{"title":"springboot配置文件","url":"/2020/05/23/springboot/properties/","content":"\n# 配置文件\n\nSpringBoot使用一个全局的配置文件，配置文件名`application`是固定的；\n\n- application.properties\n- application.yml\n- application.yaml\n\n配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；\n\n\n\n## YAML\n\nYAML（YAML Ain't Markup Language）\n\n​\tYAML  A Markup Language：是一个标记语言\n\n​\tYAML   isn't Markup Language：不是一个标记语言；\n\n标记语言：\n\n​\t以前的配置文件；大多都使用的是  **xxxx.xml**文件；\n\n​\tYAML：**以数据为中心**，比json、xml等更适合做配置文件；\n\n### YAML语法：\n\n以`空格`的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的\n\n次等级的前面是空格，不能使用制表符(tab) \n\n冒号之后如果有值，那么冒号和值之间至少有一个空格，不能紧贴着\n\n### 字面量：普通的值（数字，字符串，布尔）\n\n`k: v`\n\n字符串默认不用加上单引号或者双引号；\n\n`\"\"`：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思\n\n?>  _eg：_ name:   \"zhangsan \\n lisi\"：输出；zhangsan 换行  lisi\n\n`''`：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据\n\n?> _eg：_ name:   ‘zhangsan \\n lisi’：输出；zhangsan \\n  lisi\n\n### 对象、Map（属性和值）：\n\n`k: v`在下一行来写对象的属性和值的关系；注意缩进\n\n1. ```yaml\n   person:\n     name: 张三\n     gender: 男\n     age: 22\n   ```\n\n2. 行内写法\n\n   ```yaml\n   person: {name: 张三,gender: 男,age: 22}\n   ```\n\n\n\n### 数组（List、Set）\n\n1. ```\n   fruits: \n     - 苹果\n     - 桃子\n     - 香蕉\n   ```\n\n2. 行内写法\n\n   ```\n   fruits: [苹果,桃子,香蕉]\n   ```\n\n\n\n## 配置文件值注入\n\n<details> \n<summary style=\"font-weight:bold;color:green\">JavaBean：</summary>\n\n```java\npublic class Pet {\n\n    private String name;\n    private Integer age;\n\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Pets{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n\n}\n```\n\n```java\n/**\n * @Author cloudlandboy\n * @Date 2019/11/13 下午8:06\n * @Since 1.0.0\n * 将配置文件中配置的每一个属性的值，映射到这个组件中\n *\n * ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；\n *      prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射\n * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；\n */\n@Component\n@ConfigurationProperties(prefix = \"person\")\npublic class Person {\n    private String name;\n    private Character gender;\n    private Integer age;\n    private boolean boss;\n    private Date birth;\n    private Map<String,Object> maps;\n    private List<Object> lists;\n    private Pet pet;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Character getGender() {\n        return gender;\n    }\n\n    public void setGender(Character gender) {\n        this.gender = gender;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public boolean isBoss() {\n        return boss;\n    }\n\n    public void setBoss(boolean boss) {\n        this.boss = boss;\n    }\n\n    public Date getBirth() {\n        return birth;\n    }\n\n    public void setBirth(Date birth) {\n        this.birth = birth;\n    }\n\n    public Map<String, Object> getMaps() {\n        return maps;\n    }\n\n    public void setMaps(Map<String, Object> maps) {\n        this.maps = maps;\n    }\n\n    public List<Object> getLists() {\n        return lists;\n    }\n\n    public void setLists(List<Object> lists) {\n        this.lists = lists;\n    }\n\n    public Pet getPet() {\n        return pet;\n    }\n\n    public void setPet(Pet pet) {\n        this.pet = pet;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person{\" +\n                \"name='\" + name + '\\'' +\n                \", gender=\" + gender +\n                \", age=\" + age +\n                \", boss=\" + boss +\n                \", birth=\" + birth +\n                \", maps=\" + maps +\n                \", lists=\" + lists +\n                \", pet=\" + pet +\n                '}';\n    }\n}\n```\n\n提示：\n\n![提示](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573648927366.png)\n\n需要导入配置文件处理器，以后编写配置就有提示了\n\n</details>\n\n```xml\n\t\t<!--导入配置文件处理器，配置文件进行绑定就会有提示-->\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-configuration-processor</artifactId>\n\t\t\t<optional>true</optional>\n\t\t</dependency>\n```\n\n**配置文件：**\n\n```yaml\nperson:\n  name: 张三\n  gender: 男\n  age: 36\n  boss: true\n  birth: 1982/10/1\n  maps: {k1: v1,k2: v2}\n  lists:\n    - apple\n    - peach\n    - banana\n  pet:\n    name: 小狗\n    age: 12\n\n```\n\n\n\n**测试**\n\n``` java\npackage cn.clboy.helloworldquickstart;\n\nimport cn.clboy.helloworldquickstart.model.Person;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\n\n@SpringBootTest\nclass HelloworldquickstartApplicationTests {\n\n    @Autowired\n    private Person person;\n\n    @Test\n    void contextLoads() {\n        System.out.println(person);\n    }\n\n}\n\n```\n\n\n\n## properties\n\n上面yaml对应的properties配置文件写法\n\n```properties\nperson.name=李四\nperson.age=34\nperson.birth=1986/09/12\nperson.boss=true\nperson.gender=女\nperson.lists=cat,dog,pig\nperson.maps.k1=v1\nperson.maps.k2=v2\nperson.pet.name=\"小黑\"\nperson.pet.age=10\n```\n\n!> 测试，发现中文会乱码，而且char类型还会抛出Failed to bind properties under 'person.gender' to java.lang.Character异常\n\n### 中文乱码解决方法：\n\n在设置中找到`File Encodings`，将配置文件字符集改为`UTF-8`，并勾选：\n- [x] `Transparent native-to-ascii conversion`\n\n![乱码解决](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573695616496.png)\n\n\n\n!> yaml和properties配置文件同时存在，properties配置文件的内容会覆盖yaml配置文件的内容\n\n\n\n## 配置文件值注入两种方式对比\n\n配置文件值注入有两种方式，一个是Spring Boot的`@ConfigurationProperties`注解，另一个是spring原先的`@value`注解\n\n|                      | @ConfigurationProperties | @Value     |\n| -------------------- | ------------------------ | ---------- |\n| 功能                 | 批量注入配置文件中的属性 | 一个个指定 |\n| 松散绑定（松散语法） | 支持                     | 不支持     |\n| SpEL                 | 不支持                   | 支持       |\n| JSR303数据校验       | 支持                     | 不支持     |\n| 复杂类型封装         | 支持                     | 不支持     |\n\n**松散绑定**：例如Person中有`lastName`属性，在配置文件中可以写成\n\n`lastName`或`lastname`或`last-name`或`last_name`等等\n\n**SpEL**：\n\n```\n##　properties配置文件\npersion.age=#{2019-1986+1}\n\n# Person类\n#--------------------使用@ConfigurationProperties注解，会抛出异常--------------------\n@Component\n@ConfigurationProperties(prefix = \"person\")\npublic class Person {\n    private Integer age;\n    \n    \n#--------------------使用@value注解 OK--------------------\n@Component\npublic class Person {\n    @Value(\"${person.age}\")\n    private Integer age;\n```\n\n\n\n**JSR303数据校验**\n\n`@ConfigurationProperties`支持校验，如果校验不通过，会抛出异常\n\n![数据校验](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573716216690.png)\n\n`@value`注解不支持数据校验\n\n![数据校验](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573716427494.png)\n\n\n\n**复杂类型封装**\n\n`@value`注解无法注入map等对象的复杂类型，但`list、数组可以`\n\n![1573716770263](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573716770263.png)\n\n\n\n## @PropertySource\n\n`@PropertySource`注解的作用是加载指定的配置文件，值可以是数组，也就是可以加载多个配置文件\n\nspringboot默认加载的配置文件名是`application`，如果配置文件名不是这个是不会被容器加载的，所以这里Person并没有被注入任何属性值\n\n![1573718577827](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573718577827.png)\n\n使用`@PropertySource({\"classpath:person.properties\"})`指定加载`person.properties`配置文件\n\n![1573718679208](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573718679208.png)\n\n\n\n!> 使用这个注解加载配置文件就需要配置类使用@component等注解而不是等待@EnableConfigurationProperties激活m，而且不支持yaml，只能是properties\n\n\n\n## @ImportResource\n\n`@ImportResource`注解用于导入Spring的配置文件，让配置文件里面的内容生效；(就是以前写的springmvc.xml、applicationContext.xml)\n\nSpring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；\n\n![1573719440710](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573719440710.png)\n\n\n\n想让Spring的配置文件生效，加载进来；@**ImportResource**标注在一个配置类上\n\n![1573720006428](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573720006428.png)\n\n!> 注意！这个注解是放在主入口函数的类上，而不是测试类上\n\n\n\n## @Configuration\n\nSpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式\n\n配置类**@Configuration**  ---equals--->\tSpring配置文件\n\n### @Bean\n\n使用**@Bean**给容器中添加组件\n\n```java\npackage cn.clboy.helloworldquickstart.config;\n\nimport cn.clboy.helloworldquickstart.model.Pet;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * @Author cloudlandboy\n * @Date 2019/11/14 下午4:33\n * @Since 1.0.0\n *\n * Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件\n */\n\n\n@Configuration\npublic class BeanConfiguration {\n\n    /**\n     *相当于在配置文件中用<bean><bean/>标签添加组件\n     */\n    @Bean\n    public Pet myPet() {\n        Pet pet = new Pet();\n        pet.setName(\"嘟嘟\");\n        pet.setAge(3);\n        return pet;\n    }\n}\n```\n\n\n\n## 配置文件占位符\n\n**随机**\n\n```\n${random.value}\n${random.int}\n${random.long}\n${random.int(10)}\n${random.int[1024,65536]}\n```\n\n\n\n![1573721695426](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573721695426.png)\n\n\n\n可以引用在配置文件中配置的其他属性的值，如果使用一个没有在配置文件中的属性，则会原样输出\n\n![1573722018302](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573722018302.png)\n\n可以使用`:`指定默认值\n\n![1573722098119](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573722098119.png)\n\n\n\n## Profile\n\nProfile是Spring对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境\n\n### 多profile文件形式\n\n文件名格式：application-{profile}.properties/yml，例如：\n\n- application-dev.properties\n- application-prod.properties\n\n![1573723830627](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573723830627.png)\n\n程序启动时会默认加载`application.properties`，启动的端口就是8080\n\n可以在主配置文件中指定激活哪个配置文件\n\n![1573724084979](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573724084979.png)\n\n\n\n### yml支持多文档块方式\n\n每个文档块使用`---`分割\n\n```yaml\nserver:\n  port: 8080\nspring:\n  profiles:\n    active: prod\n---\nserver:\n  port: 8081\nspring:\n  profiles: dev\n---\nserver:\n  port: 8082\nspring:\n  profiles: prod\n```\n\n![1573724588671](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573724588671.png)\n\n\n\n### 激活指定profile的三种方式\n\n1. 在配置文件中指定  spring.profiles.active=dev（如上）\n\n2. 项目打包后在命令行启动\n\n   ```shell\n   java -jar xxx.jar --spring.profiles.active=dev；\n   ```\n\n   ![1573724952868](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573724952868.png)\n\n3. 虚拟机参数\n\n   ```\n   -Dspring.profiles.active=dev\n   ```\n\n   ![1573725631649](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573725631649.png)\n\n\n\n\n\n## 配置文件加载位置\n\nspringboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件\n\n<pre>\n\nfile: ./config/\n\n​\tfile: ./\n\n​\t\tclasspath: /config/\n\n​\t\t\tclasspath: /\t\t-->first load ↑\n\n</pre>\n\n优先级由高到底，高优先级的配置会覆盖低优先级的配置（优先级低的先加载）；\n\nSpringBoot会从这四个位置全部加载主配置文件；**互补配置**；\n\n![1573728449451](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573728449451.png)\n\n\n\n!> 这里项目根路径下的配置文件maven编译时不会打包过去，需要修改pom\n\n```xml\n        <resources>\n            <resource>\n                <directory>.</directory>\n                <filtering>true</filtering>\n                <includes>\n                    <include>**/*.properties</include>\n                    <include>**/*.yaml</include>\n                </includes>\n            </resource>\n        </resources>\n```\n\n\n\n\n\n> 我们还可以通过`spring.config.location`来改变默认的配置文件位置\n>\n> **项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；**\n>\n> ```\n> java -jar xxx.jar --spring.config.location=/home/cloudlandboy/application.yaml\n> ```\n>\n> \n\n\n\n## 外部配置加载顺序\n\n**SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置**\n\n1. **命令行参数**  :point_up_2:\n\n   所有的配置都可以在命令行上进行指定\n\n   ```\n   java -jar xxx.jar --server.port=8087  --server.context-path=/abc\n   ```\n\n   多个配置用空格分开； --配置项=值\n\n2. 来自java:comp/env的JNDI属性 ⤴️\n\n3. Java系统属性（System.getProperties()） ⤴️\n\n4. 操作系统环境变量 ⤴️\n\n5. RandomValuePropertySource配置的random.*属性值 ⤴️\n\n<mark>**由jar包外向jar包内进行寻找；**<mark>\n\n<mark>**再来加载不带profile**</mark>\n\n6. **jar包外部的`application.properties`或`application.yml`(不带spring.profile)配置文件** ⤴️\n7. **jar包内部的`application.properties`或`application.yml`(不带spring.profile)配置文件 ⤴️\n\n<mark>**优先加载带profile**</mark>\n\n8. **jar包外部的`application-{profile}.properties`或`application.yml`(带spring.profile)配置文件 ⤴️\n9. **jar包内部的`application-{profile}.properties`或`application.yml`(带spring.profile)配置文件 ⤴️\n\n\n\n10. @Configuration注解类上的@PropertySource ⤴️\n11. 通过SpringApplication.setDefaultProperties指定的默认属性 ⤴️\n\n所有支持的配置加载来源：\n\n[参考官方文档](https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/reference/htmlsingle/#boot-features-external-config)\n\n![1573735371567](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573735371567.png)","tags":["springboot"],"categories":["springboot"]},{"title":"Spring Initializer快速创建Spring Boot项目","url":"/2020/05/23/springboot/springInitializer/","content":"\n# 使用Spring Initializer快速创建Spring Boot项目\n\nIDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目；\n\n选择我们需要的模块；向导会联网创建Spring Boot项目；\n\n!> 需要联网\n\n## IDEA\n\n1. 创建项目时选择Spring Initializr\n\n   ![idea01](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573639771931.png)\n\n   \n\n2. 完善项目信息\n\n   ![idea02](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573639923504.png)\n\n   !> 出现 **Artifact contains illegal characters** 是因为`Artifact`中使用了大写，只能是全小写，单词之间用`-`分隔\n\n3. 选择需要的starter\n\n   ![idea03](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573640773365.png)\n\n4. 创建完成后 不要的文件可以删除\n\n   ![idea04](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573641023432.png)\n\n\n\n\n\n## Eclipse\n\n1. 需要安装插件，或者使用STS版本\n\n2. 创建项目时选择Spring Starter Project\n\n   ![eclipse01](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573643167357.png)\n\n3. 完善信息\n\n   ![eclipse02](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573643396117.png)\n\n4. 选择需要的选择需要的starter\n\n   ![eclipse03](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573643505863.png)\n\n\n\n\n\n**默认生成的Spring Boot项目**\n\n- 主程序已经生成好了，我们只需要完成我们自己的逻辑\n- `resources`文件夹中目录结构\n  - `static`：保存所有的静态资源； js、css、images；\n  - `templates`：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，`默认`不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；\n  - `application.properties`：Spring Boot应用的配置文件；可以修改一些默认设置；\n\n","tags":["springboot"],"categories":["springboot"]},{"title":"SpringMVC自动配置","url":"/2020/05/23/springboot/springmvcconfig/","content":"\n# SpringMVC自动配置\n\nSpring Boot为Spring MVC提供了自动配置，可与大多数应用程序完美配合。\n\n以下是SpringBoot对SpringMVC的默认配置\n\n**`org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration`**\n\n自动配置在Spring的默认值之上添加了以下功能：\n\n- 包含`ContentNegotiatingViewResolver`和`BeanNameViewResolver`。--> 视图解析器\n- 支持服务静态资源，包括对WebJars的支持（[官方文档中有介绍](https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-mvc-static-content)）。--> 静态资源文件夹路径\n- 自动注册`Converter`，`GenericConverter`和`Formatter `beans。--> 转换器，格式化器\n- 支持`HttpMessageConverters`（[官方文档中有介绍](https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-mvc-message-converters)）。--> SpringMVC用来转换Http请求和响应的；User---Json；\n- 自动注册`MessageCodesResolver`（[官方文档中有介绍](https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-message-codes)）。--> 定义错误代码生成规则\n- 静态`index.html`支持。--> 静态首页访问\n- 定制`Favicon`支持（[官方文档中有介绍](https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-mvc-favicon)）。--> 网站图标\n- 自动使用`ConfigurableWebBindingInitializer`bean（[官方文档中有介绍](https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-mvc-web-binding-initializer)）。\n\n如果您想保留 Spring Boot MVC 的功能，并且需要添加其他 [MVC 配置](https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc)（拦截器，格式化程序和视图控制器等），可以添加自己的 `WebMvcConfigurer` 类型的 `@Configuration` 类，但**不能**带 `@EnableWebMvc` 注解。如果您想自定义 `RequestMappingHandlerMapping`、`RequestMappingHandlerAdapter` 或者 `ExceptionHandlerExceptionResolver` 实例，可以声明一个 `WebMvcRegistrationsAdapter` 实例来提供这些组件。\n\n如果您想完全掌控 Spring MVC，可以添加自定义注解了 `@EnableWebMvc` 的 @Configuration 配置类。\n\n## 视图解析器\n\n视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）\n\n- 自动配置了ViewResolver\n- ContentNegotiatingViewResolver：组合所有的视图解析器的；\n\n![1573873741438](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573873741438.png)\n\n视图解析器从哪里来的？\n\n![1573874365778](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573874365778.png)\n\n<mark>**所以我们可以自己给容器中添加一个视图解析器；自动的将其组合进来**</mark>\n\n```java\n@Component\npublic class MyViewResolver implements ViewResolver {\n\n    @Override\n    public View resolveViewName(String s, Locale locale) throws Exception {\n        return null;\n    }\n}\n```\n\n\n\n![1573875409759](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573875409759.png)\n\n\n\n## 转换器、格式化器\n\n- `Converter`：转换器；  public String hello(User user)：类型转换使用Converter（表单数据转为user）\n- `Formatter`  格式化器；  2017.12.17===Date；\n\n```java\n\t\t@Bean\n\t\t//在配置文件中配置日期格式化的规则\n\t\t@ConditionalOnProperty(prefix = \"spring.mvc\", name = \"date-format\")\n\t\tpublic Formatter<Date> dateFormatter() {\n\t\t\treturn new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件\n\t\t}\n```\n\n<mark>**自己添加的格式化器转换器，我们只需要放在容器中即可**</mark>\n\n\n\n## HttpMessageConverters\n\n- `HttpMessageConverter`：SpringMVC用来转换Http请求和响应的；User---Json；\n- `HttpMessageConverters` 是从容器中确定；获取所有的HttpMessageConverter；\n\n<mark>**自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）**</mark>\n\n\n\n## MessageCodesResolver\n\n<mark>**我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）**</mark>\n\n\n\n## 扩展SpringMVC\n\n以前的配置文件中的配置\n\n```xml\n<mvc:view-controller path=\"/hello\" view-name=\"success\"/>\n```\n\n<mark>**现在，编写一个配置类（@Configuration），是WebMvcConfigurer类型；不能标注@EnableWebMvc**</mark>\n\n```java\n@Configuration\npublic class MyMvcConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        registry.addViewController(\"/hi\").setViewName(\"success\");\n    }\n}\n```\n\n访问：[http://localhost:8080/hi](http://localhost:8080/hi)\n\n\n\n**原理：**\n\n我们知道`WebMvcAutoConfiguration`是SpringMVC的自动配置类\n\n下面这个类是`WebMvcAutoConfiguration`中的一个内部类\n\n![1573891167026](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573891167026.png)\n\n看一下`@Import({WebMvcAutoConfiguration.EnableWebMvcConfiguration.class})`中的这个类，\n\n这个类依旧是`WebMvcAutoConfiguration`中的一个内部类\n\n![1573891478014](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573891478014.png)\n\n重点看一下这个类继承的父类`DelegatingWebMvcConfiguration`\n\n```java\npublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {\n    private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();\n\n    public DelegatingWebMvcConfiguration() {\n    }\n\n    //自动注入，从容器中获取所有的WebMvcConfigurer\n    @Autowired(\n        required = false\n    )\n    public void setConfigurers(List<WebMvcConfigurer> configurers) {\n        if (!CollectionUtils.isEmpty(configurers)) {\n            this.configurers.addWebMvcConfigurers(configurers);\n        }\n\n    }\n    \n    ......\n     \n    /**\n     * 查看其中一个方法\n \t * this.configurers：也是WebMvcConfigurer接口的一个实现类\n \t * 看一下调用的configureViewResolvers方法 ↓\n \t */\n    protected void configureViewResolvers(ViewResolverRegistry registry) {\n        this.configurers.configureViewResolvers(registry);\n    }\n```\n\n```java\n    public void configureViewResolvers(ViewResolverRegistry registry) {\n        Iterator var2 = this.delegates.iterator();\n\n        while(var2.hasNext()) {\n            WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next();\n            //将所有的WebMvcConfigurer相关配置都来一起调用；  \n            delegate.configureViewResolvers(registry);\n        }\n\n    }\n```\n\n容器中所有的WebMvcConfigurer都会一起起作用；\n\n我们的配置类也会被调用；\n\n效果：SpringMVC的自动配置和我们的扩展配置都会起作用；\n\n![1573892805539](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573892805539.png)\n\n## 全面接管SpringMVC\n\nSpringBoot对SpringMVC的自动配置不需要了，所有都是由我们自己来配置；所有的SpringMVC的自动配置都失效了\n\n**我们只需要在配置类中添加`@EnableWebMvc`即可；**\n\n```java\n@Configuration\n@EnableWebMvc\npublic class MyMvcConfig implements WebMvcConfigurer\n```\n\n![1573892899452](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1573892899452.png)\n\n原理：\n\n为什么@EnableWebMvc自动配置就失效了；\n\n我们看一下EnableWebMvc注解类\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE})\n@Documented\n@Import({DelegatingWebMvcConfiguration.class})\npublic @interface EnableWebMvc {\n}\n```\n\n重点在于`@Import({DelegatingWebMvcConfiguration.class})`\n\n`DelegatingWebMvcConfiguration`是`WebMvcConfigurationSupport`的子类\n\n我们再来看一下springmvc的自动配置类`WebMvcAutoConfiguration`\n\n```java\n@Configuration(\n    proxyBeanMethods = false\n)\n@ConditionalOnWebApplication(\n    type = Type.SERVLET\n)\n@ConditionalOnClass({Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class})\n\n//重点是这个注解，只有当容器中没有这个类型组件的时候该配置类才会生效\n@ConditionalOnMissingBean({WebMvcConfigurationSupport.class})\n\n@AutoConfigureOrder(-2147483638)\n@AutoConfigureAfter({DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class})\npublic class WebMvcAutoConfiguration \n```\n\n1. @EnableWebMvc将WebMvcConfigurationSupport组件导入进来；\n2. 导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；\n\n\n\n## 如何修改SpringBoot的默认配置\n\nSpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；\n\n- 在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置\n- 在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置\n\n","tags":["springboot"],"categories":["springboot"]},{"title":"SpringBoot启动流程","url":"/2020/05/23/springboot/startprocess/","content":"\n# SpringBoot启动流程\n\n![1574497298469](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574497298469.png)\n\n## 启动原理\n\n```java\n    public static void main(String[] args) {\n        //xxx.class：主配置类，（可以传多个）\n        SpringApplication.run(xxx.class, args);\n    }\n```\n\n1. 从run方法开始，创建SpringApplication，然后再调用run方法\n\n       /**\n        * ConfigurableApplicationContext(可配置的应用程序上下文)\n        */\n       public static ConfigurableApplicationContext run(Class<?> primarySource, String... args) {\n           //调用下面的run方法\n           return run(new Class[]{primarySource}, args);\n       }\n       \n       public static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {\n           return (new SpringApplication(primarySources)).run(args);\n       }\n\n2. 创建SpringApplication\n\n   ```java\n   //primarySources：主配置类\n   new SpringApplication(primarySources)\n   ```\n\n   ```java\n       public SpringApplication(Class<?>... primarySources) {\n           //调用下面构造方法\n           this((ResourceLoader) null, primarySources);\n       }\n   \n       public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {\n           this.sources = new LinkedHashSet();\n           this.bannerMode = Mode.CONSOLE;\n           this.logStartupInfo = true;\n           this.addCommandLineProperties = true;\n           this.addConversionService = true;\n           this.headless = true;\n           this.registerShutdownHook = true;\n           this.additionalProfiles = new HashSet();\n           this.isCustomEnvironment = false;\n           this.lazyInitialization = false;\n           this.resourceLoader = resourceLoader;\n           Assert.notNull(primarySources, \"PrimarySources must not be null\");\n           //保存主配置类\n           this.primarySources = new LinkedHashSet(Arrays.asList(primarySources));\n           //获取当前应用的类型，是不是web应用，见2.1\n           this.webApplicationType = WebApplicationType.deduceFromClasspath();\n           //从类路径下找到META‐INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来，见2.2\n           this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));\n           //从类路径下找到META‐INF/spring.ApplicationListener；然后保存起来,原理同上\n           this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));\n           //从多个配置类中找到有main方法的主配置类，见下图(在调run方法的时候是可以传递多个配置类的)\n           this.mainApplicationClass = this.deduceMainApplicationClass();\n           //执行完毕，SpringApplication对象就创建出来了，返回到1处，调用SpringApplication对象的run方法，到3\n       }\n   ```\n\n   ![1574503716694](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574503716694.png)\n\n   <details>\n\n   <summary>2.1 判断是不是web 应用</summary>\n\n   ```java\n       static WebApplicationType deduceFromClasspath() {\n           if (ClassUtils.isPresent(\"org.springframework.web.reactive.DispatcherHandler\", (ClassLoader)null) && !ClassUtils.isPresent(\"org.springframework.web.servlet.DispatcherServlet\", (ClassLoader)null) && !ClassUtils.isPresent(\"org.glassfish.jersey.servlet.ServletContainer\", (ClassLoader)null)) {\n               return REACTIVE;\n           } else {\n               String[] var0 = SERVLET_INDICATOR_CLASSES;\n               int var1 = var0.length;\n   \n               for(int var2 = 0; var2 < var1; ++var2) {\n                   String className = var0[var2];\n                   if (!ClassUtils.isPresent(className, (ClassLoader)null)) {\n                       return NONE;\n                   }\n               }\n   \n               return SERVLET;\n           }\n       }\n   ```\n\n   </details>\n\n   <details>\n\n   <summary>2.2 getSpringFactoriesInstances(ApplicationContextInitializer.class)</summary>\n\n   ```java\n       private <T> Collection<T> getSpringFactoriesInstances(Class<T> type) {\n           //调用下面重载方法，type：ApplicationContextInitializer.class\n           return this.getSpringFactoriesInstances(type, new Class[0]);\n       }\n   \n       private <T> Collection<T> getSpringFactoriesInstances(Class<T> type, Class<?>[] parameterTypes, Object... args) {\n           ClassLoader classLoader = this.getClassLoader();\n           //获取key为ApplicationContextInitializer全类名的所有值，见下2.2.1\n           Set<String> names = new LinkedHashSet(SpringFactoriesLoader.loadFactoryNames(type, classLoader));\n           //根据拿到的类名集合，使用反射创建对象放到集合中返回 见 2.2.2\n           List<T> instances = this.createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);\n           AnnotationAwareOrderComparator.sort(instances);\n           return instances; //返回到2 set\n       }\n   ```\n\n   <details>\n\n   <summary>2.2.1</summary>\n\n   ![1574499682826](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574499682826.png)\n\n      上图65行中调用重载的方法：\n\n      ```java\n      //把类路径下所有META‐INF/spring.factories中的配置都存储起来，并返回，见下图\n      (List)loadSpringFactories(classLoader)\n      ```\n\n      ![1574501479198](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574501479198.png)\n\n      然后再调用`getOrDefault(factoryTypeName, Collections.emptyList())`方法，获取key为\n\n      `ApplicationContextInitializer`类名的value集合\n\n      ![1574501635588](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574501635588.png)\n\n      好了，回到2.2\n\n   </details>\n\n   <details>\n\n   <summary>2.2.2</summary>\n\n   ```java\n   private <T> List<T> createSpringFactoriesInstances(Class<T> type, Class<?>[] parameterTypes, ClassLoader classLoader, Object[] args, Set<String> names) {\n       List<T> instances = new ArrayList(names.size());\n       Iterator var7 = names.iterator();\n   \n       while(var7.hasNext()) {\n           String name = (String)var7.next();\n   \n           try {\n               Class<?> instanceClass = ClassUtils.forName(name, classLoader);\n               Assert.isAssignable(type, instanceClass);\n               Constructor<?> constructor = instanceClass.getDeclaredConstructor(parameterTypes);\n               T instance = BeanUtils.instantiateClass(constructor, args);\n               instances.add(instance);\n           } catch (Throwable var12) {\n               throw new IllegalArgumentException(\"Cannot instantiate \" + type + \" : \" + name, var12);\n           }\n       }\n   \n       return instances;\n   }\n   ```\n\n   ![1574502740682](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574502740682.png)\n\n   返回到2.2 `this.setInitializers(ApplicationContextInitializer类型对象的集合)`\n\n\n   </details>\n\n   </details>\n\n3. 调用SpringApplication对象的run方法\n\n   ![1574512218795](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574512218795.png)\n\n   ```java\n       public ConfigurableApplicationContext run(String... args) {\n           StopWatch stopWatch = new StopWatch();\n           stopWatch.start();\n           //声明IOC容器\n           ConfigurableApplicationContext context = null;\n           Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList();\n           this.configureHeadlessProperty();\n           //从类路径下META‐INF/spring.factories获取SpringApplicationRunListeners，原理同2中获取ApplicationContextInitializer和ApplicationListener\n           SpringApplicationRunListeners listeners = this.getRunListeners(args);\n           //遍历上一步获取的所有SpringApplicationRunListener，调用其starting方法\n           listeners.starting();\n   \n           Collection exceptionReporters;\n           try {\n               //封装命令行\n               ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n               //准备环境，把上面获取到的listeners传过去，见3.1\n               ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments);\n               this.configureIgnoreBeanInfo(environment);\n               //打印Banner，就是控制台那个Spring字符画\n               Banner printedBanner = this.printBanner(environment);\n               //根据当前环境利用反射创建IOC容器\n               context = this.createApplicationContext();\n           //从类路径下META‐INF/spring.factories获取SpringBootExceptionReporter，原理同2中获取ApplicationContextInitializer和ApplicationListener\n               exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[]{ConfigurableApplicationContext.class}, context);\n               //准备IOC容器，见3.3\n               this.prepareContext(context, environment, listeners, applicationArguments, printedBanner);\n               //刷新IOC容器，可查看配置嵌入式Servlet容器原理 链接在3.4\n               this.refreshContext(context);\n               //这是一个空方法\n               this.afterRefresh(context, applicationArguments);\n               stopWatch.stop();\n               if (this.logStartupInfo) {\n                   (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch);\n               }\n               //调用所有SpringApplicationRunListener的started方法\n               listeners.started(context);\n               //见3.5 ，从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调ApplicationRunner先回调，CommandLineRunner再\n               this.callRunners(context, applicationArguments);\n           } catch (Throwable var10) {\n               this.handleRunFailure(context, var10, exceptionReporters, listeners);\n               throw new IllegalStateException(var10);\n           }\n   \n           try {\n               //调用所有SpringApplicationRunListener的running方法\n               listeners.running(context);\n               return context;\n           } catch (Throwable var9) {\n               this.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)null);\n               throw new IllegalStateException(var9);\n           }\n       }\n   ```\n\n   //容器创建完成，返回步骤1处，最后返回到启动类\n\n   <details>\n\n   <summary>3.1</summary>\n\n   ```java\n       private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments) {\n           //获取或者创建环境，有则获取，无则创建\n           ConfigurableEnvironment environment = this.getOrCreateEnvironment();\n           //配置环境\n           this.configureEnvironment((ConfigurableEnvironment)environment, applicationArguments.getSourceArgs());\n           ConfigurationPropertySources.attach((Environment)environment);\n           //创建环境完成后，调用前面获取的所有SpringApplicationRunListener的environmentPrepared方法\n           listeners.environmentPrepared((ConfigurableEnvironment)environment);\n           this.bindToSpringApplication((ConfigurableEnvironment)environment);\n           if (!this.isCustomEnvironment) {\n               environment = (new EnvironmentConverter(this.getClassLoader())).convertEnvironmentIfNecessary((ConfigurableEnvironment)environment, this.deduceEnvironmentClass());\n           }\n   \n           ConfigurationPropertySources.attach((Environment)environment);\n           return (ConfigurableEnvironment)environment;\n       }\n   ```\n\n   回到3，将创建好的environment返回\n\n   </details>\n\n   <details>\n\n   <summary>3.2</summary>\n\n   ```java\n       protected ConfigurableApplicationContext createApplicationContext() {\n           Class<?> contextClass = this.applicationContextClass;\n           if (contextClass == null) {\n               try {\n                   switch(this.webApplicationType) {\n                   case SERVLET:\n                       contextClass = Class.forName(\"org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext\");\n                       break;\n                   case REACTIVE:\n                       contextClass = Class.forName(\"org.springframework.boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext\");\n                       break;\n                   default:\n                       contextClass = Class.forName(\"org.springframework.context.annotation.AnnotationConfigApplicationContext\");\n                   }\n               } catch (ClassNotFoundException var3) {\n                   throw new IllegalStateException(\"Unable create a default ApplicationContext, please specify an ApplicationContextClass\", var3);\n               }\n           }\n   \n           return (ConfigurableApplicationContext)BeanUtils.instantiateClass(contextClass);\n       }\n   ```\n\n   将创建好的IOC容器返回，到3\n\n   </details>\n\n   <details>\n\n   <summary>3.3</summary>\n\n   ```java\n       private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) {\n           //将创建好的环境放到IOC容器中\n           context.setEnvironment(environment);\n           //注册一些组件\n           this.postProcessApplicationContext(context);\n           //获取所有的ApplicationContextInitializer调用其initialize方法，这些ApplicationContextInitializer就是在2步骤中获取的，见3.3.1\n           this.applyInitializers(context);\n           //回调所有的SpringApplicationRunListener的contextPrepared方法，这些SpringApplicationRunListeners是在步骤3中获取的\n           listeners.contextPrepared(context);\n           \n           //打印日志\n           if (this.logStartupInfo) {\n               this.logStartupInfo(context.getParent() == null);\n               this.logStartupProfileInfo(context);\n           }\n   \n           ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n           beanFactory.registerSingleton(\"springApplicationArguments\", applicationArguments);\n           if (printedBanner != null) {\n               beanFactory.registerSingleton(\"springBootBanner\", printedBanner);\n           }\n   \n           if (beanFactory instanceof DefaultListableBeanFactory) {\n               ((DefaultListableBeanFactory)beanFactory).setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n           }\n   \n           if (this.lazyInitialization) {\n               context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());\n           }\n   \n           Set<Object> sources = this.getAllSources();\n           Assert.notEmpty(sources, \"Sources must not be empty\");\n           this.load(context, sources.toArray(new Object[0]));\n           //回调所有的SpringApplicationRunListener的contextLoaded方法\n           listeners.contextLoaded(context);\n       }\n   \n   ```\n\n   prepareContext方法运行完毕，返回到步骤3，执行refreshContext方法\n\n   <details>\n\n   <summary>3.3.1</summary>\n\n   ```java\n       protected void applyInitializers(ConfigurableApplicationContext context) {\n           Iterator var2 = this.getInitializers().iterator();\n   \n           while(var2.hasNext()) {\n               ApplicationContextInitializer initializer = (ApplicationContextInitializer)var2.next();\n               Class<?> requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(), ApplicationContextInitializer.class);\n               Assert.isInstanceOf(requiredType, context, \"Unable to call initializer.\");\n               initializer.initialize(context);\n           }\n   \n       }\n   ```\n   </details>\n\n   </details>\n\n   <details>\n\n   <summary>3.4</summary>\n\n   [onRefresh方法](https://cloudlandboy.github.io/myNote/#/backend/springboot/configservletcontainer?id=%e5%b5%8c%e5%85%a5%e5%bc%8fservlet%e5%ae%b9%e5%99%a8%e5%90%af%e5%8a%a8%e5%8e%9f%e7%90%86)\n\n   </details>\n\n   <details>\n\n   <summary>3.5</summary>\n\n   ```java\n       private void callRunners(ApplicationContext context, ApplicationArguments args) {\n           List<Object> runners = new ArrayList();\n           runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());\n           runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());\n           AnnotationAwareOrderComparator.sort(runners);\n           Iterator var4 = (new LinkedHashSet(runners)).iterator();\n   \n           while(var4.hasNext()) {\n               Object runner = var4.next();\n               if (runner instanceof ApplicationRunner) {\n                   this.callRunner((ApplicationRunner)runner, args);\n               }\n   \n               if (runner instanceof CommandLineRunner) {\n                   this.callRunner((CommandLineRunner)runner, args);\n               }\n           }\n   \n       }\n   ```\n\n   \n\n   </details>\n\n\n\n## 几个重要的事件回调机制\n\n**配置在META-INF/spring.factories**\n\n- ApplicationContextInitializer\n- SpringApplicationRunListener\n\n**只需要放在ioc容器中**\n\n- ApplicationRunner\n- CommandLineRunner\n\n## 测试\n\n1. 创建`ApplicationContextInitializer`和`SpringApplicationRunListener`的实现类，并在META-INF/spring.factories文件中配置\n\n   ```java\n   public class TestApplicationContextInitializer implements ApplicationContextInitializer {\n   \n       @Override\n       public void initialize(ConfigurableApplicationContext configurableApplicationContext) {\n           System.out.println(\"TestApplicationContextInitializer.initialize\");\n       }\n   }\n   ```\n\n   ```java\n   public class TestSpringApplicationRunListener implements SpringApplicationRunListener {\n       @Override\n       public void starting() {\n           System.out.println(\"TestSpringApplicationRunListener.starting\");\n       }\n   \n       @Override\n       public void environmentPrepared(ConfigurableEnvironment environment) {\n           System.out.println(\"TestSpringApplicationRunListener.environmentPrepared\");\n       }\n   \n       @Override\n       public void contextPrepared(ConfigurableApplicationContext context) {\n           System.out.println(\"TestSpringApplicationRunListener.contextPrepared\");\n       }\n   \n       @Override\n       public void contextLoaded(ConfigurableApplicationContext context) {\n           System.out.println(\"TestSpringApplicationRunListener.contextLoaded\");\n       }\n   \n       @Override\n       public void started(ConfigurableApplicationContext context) {\n           System.out.println(\"TestSpringApplicationRunListener.started\");\n       }\n   \n       @Override\n       public void running(ConfigurableApplicationContext context) {\n           System.out.println(\"TestSpringApplicationRunListener.running\");\n       }\n   \n       @Override\n       public void failed(ConfigurableApplicationContext context, Throwable exception) {\n           System.out.println(\"TestSpringApplicationRunListener.failed\");\n       }\n   }\n   ```\n\n   ```properties\n   org.springframework.context.ApplicationContextInitializer=\\\n   cn.clboy.springbootprocess.init.TestApplicationContextInitializer\n   \n   org.springframework.boot.SpringApplicationRunListener=\\\n   cn.clboy.springbootprocess.init.TestSpringApplicationRunListener\n   ```\n\n   启动报错：说是没有找到带org.springframework.boot.SpringApplication和String数组类型参数的构造器，给TestSpringApplicationRunListener添加这样的构造器\n\n   ![1574515721669](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574515721669.png)\n\n   ```java\n       public TestSpringApplicationRunListener(SpringApplication application,String[] args) {\n       }\n   ```\n\n2. 创建`ApplicationRunner`实现类和`CommandLineRunner`实现类，注入到容器中\n\n   ```java\n   @Component\n   public class TestApplicationRunner implements ApplicationRunner {\n   \n       @Override\n       public void run(ApplicationArguments args) throws Exception {\n           System.out.println(\"TestApplicationRunner.run\\t--->\"+args);\n       }\n   }\n   ```\n\n   ```java\n   @Component\n   public class TestCommandLineRunn implements CommandLineRunner {\n   \n       @Override\n       public void run(String... args) throws Exception {\n           System.out.println(\"TestCommandLineRunn.runt\\t--->\"+ Arrays.toString(args));\n       }\n   }\n   ```\n\n   ![1574517578711](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574517578711.png)\n\n   \n\n\n\n## 修改Banner\n\n默认是找类路径下的`banner.txt`，可以在配置文件中修改\n\n```properties\nspring.banner.location=xxx.txt\n```\n\n生成banner的网站：<http://patorjk.com/software/taag>\n\n![1574508283758](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/1574508283758.png)\n\n也可以使用图片(将其像素解析转换成assii编码之后打印)，默认是在类路径下找名为`banner`后缀为`\"gif\", \"jpg\", \"png\"`的图片\n\n```\nstatic final String[] IMAGE_EXTENSION = new String[]{\"gif\", \"jpg\", \"png\"};\n```\n\n也可以在配置文件中指定\n\n```properties\nspring.banner.image.location=classpath:abc.png\n```\n\n","tags":["springboot"],"categories":["springboot"]},{"title":"SpringBoot模板引擎","url":"/2020/05/23/springboot/templateengine/","content":"\n\n# 模板引擎\n\n常见的模板引擎有`JSP`、`Velocity`、`Freemarker`、`Thymeleaf`\n\nSpringBoot推荐使用Thymeleaf；\n\n## 引入thymeleaf\n\n```xml\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-thymeleaf</artifactId>\n        </dependency>\n```\n\n\n\n**如需切换thymeleaf版本：**\n\n```xml\n<properties>\n\n\t\t<thymeleaf.version>X.X.X.RELEASE</thymeleaf.version>\n\n\t\t<!-- 布局功能的支持程序  thymeleaf3主程序  layout2以上版本 -->\n\t\t<!-- thymeleaf2   layout1-->\n\t\t<thymeleaf-layout-dialect.version>2.2.2</thymeleaf-layout-dialect.version>\n\n  </properties>\n```\n\n\n\n## Thymeleaf使用\n\n```java\npackage org.springframework.boot.autoconfigure.thymeleaf;\n\n......\n\n@ConfigurationProperties(\n    prefix = \"spring.thymeleaf\"\n)\npublic class ThymeleafProperties {\n    private static final Charset DEFAULT_ENCODING;\n    public static final String DEFAULT_PREFIX = \"classpath:/templates/\";\n    public static final String DEFAULT_SUFFIX = \".html\";\n    private boolean checkTemplate = true;\n    private boolean checkTemplateLocation = true;\n    private String prefix = \"classpath:/templates/\";\n    private String suffix = \".html\";\n    private String mode = \"HTML\";\n```\n\n默认只要我们把HTML页面放在`classpath:/templates/`，thymeleaf就能自动渲染；\n\n1. 创建模板文件`t1.html`，并导入thymeleaf的名称空间\n\n   ```html\n   <html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n   ```\n\n   ```html\n   <!DOCTYPE html>\n   <html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n   <head>\n       <meta charset=\"UTF-8\">\n       <title>Title</title>\n   </head>\n   <body>\n   \n   </body>\n   </html>\n   ```\n\n2. 使用模板\n\n   ```html\n   <!DOCTYPE html>\n   <html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n   <head>\n       <meta charset=\"UTF-8\">\n       <title>[[${title}]]</title>\n   </head>\n   <body>\n   <h1 th:text=\"${title}\"></h1>\n   <div th:text=\"${info}\">这里的文本之后将会被覆盖</div>\n   </body>\n   </html>\n   ```\n\n3. 在controller中准备数据\n\n   ```java\n   @Controller\n   public class HelloT {\n   \n       @RequestMapping(\"/ht\")\n       public String ht(Model model) {\n           model.addAttribute(\"title\",\"hello Thymeleaf\")\n                .addAttribute(\"info\",\"this is first thymeleaf test\");\n           return \"t1\";\n       }\n   }\n   ```\n\n   \n\n## 语法规则\n\n`th:text` --> 改变当前元素里面的文本内容；\n\n`th：任意html属性 ` --> 来替换原生属性的值\n\n![thymeleaf](https://cdn.static.note.zzrfdsn.cn/images/springboot/assets/2018-02-04_123955.png)\n\n更多配置参考官方文档：<https://www.thymeleaf.org/documentation.html>\n\n中文参考书册：https://www.lanzous.com/i7dzr2j","tags":["springboot"],"categories":["springboot"]},{"title":"WebService入门","url":"/2020/05/23/webservice/Introduction/","content":"\n# WebService入门\n\n## 什么是WebService\n\n​\tWeb service是一个[平台](http://baike.baidu.com/view/58664.htm)独立的，低耦合的，自包含的、基于可[编程](http://baike.baidu.com/view/3281.htm)的web的应用程序，可使用开放的[XML](http://baike.baidu.com/view/63.htm)（[标准通用标记语言](http://baike.baidu.com/view/5286041.htm)下的一个子集）[标准](http://baike.baidu.com/view/8079.htm)来[描述](http://baike.baidu.com/view/491264.htm)、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的[应用程序](http://baike.baidu.com/view/330120.htm)。\n\n​\tWeb Service技术， 能使得运行在不同机器上的不同应用无须借助附加的、专门的第三方软件或硬件， 就可相互交换数据或集成。依据Web Service规范实施的应用之间， 无论它们所使用的语言、 平台或内部协议是什么， 都可以相互交换数据。Web Service是自描述、 自包含的可用网络模块， 可以执行具体的业务功能。Web Service也很容易部署， 因为它们基于一些常规的产业标准以及已有的一些技术，诸如[标准通用标记语言](http://baike.baidu.com/view/5286041.htm)下的子集[XML](http://baike.baidu.com/view/63.htm)、HTTP。Web Service减少了应用接口的花费。Web Service为整个企业甚至多个组织之间的业务流程的集成提供了一个通用机制。\n\n![webservice](https://cdn.static.note.zzrfdsn.cn/images/201911101542.png)\n\n## WebService的特点\n\n- WebService通过HTTP POST方式接受客户的请求\n- WebService与客户端之间一般使用SOAP协议传输XML数据\n- 它本身就是为了跨平台或跨语言而设计的\n\n\n\n## 调用网络上的WebService服务\n\nhttp://webxml.com.cn/\n\n\n\n## SOAP\n\nSimple Object Access Protocol：简单对象访问协议\n\n- SOAP作为一个基于XML语言的协议用于在网上传输数据。\n- SOAP = 在HTTP的基础上+XML数据。\n- SOAP是基于HTTP的。\n\nSOAP的组成如下：\n\n- Envelope – 必须的部分。以XML的根元素出现。\n- Headers – 可选的。\n- Body – 必须的。在body部分，包含要执行的服务器的方法。和发送到服务器的数据。\n\n \n\n```xml\nPOST /WebServices/IpAddressSearchWebService.asmx HTTP/1.1\nHost: ws.webxml.com.cn\nContent-Type: text/xml; charset=utf-8\nContent-Length: length\nSOAPAction: \"http://WebXml.com.cn/getCountryCityByIp\"\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">\n  <soap:Body>\n    <getCountryCityByIp xmlns=\"http://WebXml.com.cn/\">\n      <theIpAddress>string</theIpAddress>\n    </getCountryCityByIp>\n  </soap:Body>\n</soap:Envelope>\n```\n\n\n\n## WSDL \n\nWeb Services Description Language：Web服务描述语言\n\n​\t就是一个xml文档，用于描述当前服务的一些信息（服务名称、服务的发布地址、服务提供的方法、方法的参数类型、方法的返回值类型等）\n\n\n\n## 发布一个WebService服务\n\n\n\n第一步：创建一个Java项目\n\n第二步：创建一个类，加入Webservice注解\n\n第三步：提供一个方法sayHello\n\n第四步：在main方法中调用jdk提供的发布服务的方法\n\n第五步：访问服务的wsdl文档（服务的发布地址+?wsdl）\n\n```java\n@WebService\npublic class Hello {\n\tpublic String sayHello(String name,int i){\n\t\tSystem.out.println(\"服务端的sayHello方法被调用了。。。。\");\n\t\treturn \"helle\" + name;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tString address = \"http://192.168.115.87:8080/hello\";\n\t\tHello implementor = new Hello();\n\t\tEndpoint.publish(address, implementor);\n\t}\n}\n```\n\n\n\n## 客户端调用\n\n### jdk中wsimport命令使用\n\n作用：解析wsdl文件，生成客户端本地代码\n\n​\t在JDK的bin文件夹中，有一个wsimport.exe工具，可依据wsdl文件生成相应的类文件，将生存在本地这些类文件拷贝到需要使用的项目中，就可以像调用本地的类一样调用webService提供的方法。该工具可以用于非Java的服务器，如用C#编写的WebService，通过wsimport则生成Java的客户端实现。\n\n参数：\n\n`-keep`：是否生成java源文件\n\n`-d`：指定.class文件的输出目录\n\n`-s`：指定.java文件的输出目录\n\n`-p`：定义生成类的包名，不定义的话有默认包名\n\n`-verbose`：在控制台显示输出信息\n\n`-b`：指定jaxws/jaxb绑定文件或额外的schemas\n\n`-extension`：使用扩展来支持SOAP1.2\n\n例如：\n\n```\nwsimport -s /home/test/wsimport http://192.168.115.87:8080/hello?wsdl\n```\n\n\n\n1. 使用wsimport命令解析wsdl文件生成本地代码\n2. 将生成的代码复制到项目中\n3. 通过本地代码创建一个代理对象\n4. 通过代理对象实现远程调用\n\n\n\n```java\npublic class App {\n\tpublic static void main(String[] args) {\n\t\tHelloService ss = new HelloService();\n\t\t//创建客户端代理对象，用于远程调用\n\t\tHelloService proxy = ss.getHelloPort();\n\t\tString ret = proxy.sayHello(\"小明\", 10);\n\t\tSystem.out.println(ret);\n\t}\n}\n```\n\n","tags":["webservice"],"categories":["webservice"]},{"title":"apache CXF入门","url":"/2020/05/23/webservice/apachecxf/","content":"\n# apache CXF入门\n\nmaven依赖：\n\n```xml\n    <dependency>\n      <groupId>org.apache.cxf</groupId>\n      <artifactId>cxf-rt-frontend-jaxws</artifactId>\n      <version>3.0.1</version>\n    </dependency>\n    <dependency>\n      <groupId>org.apache.cxf</groupId>\n      <artifactId>cxf-rt-transports-http</artifactId>\n      <version>3.0.1</version>\n    </dependency>\n```\n\n\n\n## 整合Spring开发\n\n第一步：创建动态web项目\n\n第二步：导入CXF相关jar包\n\n第三步：在web.xml中配置CXF框架提供的一个Servlet\n\n```xml\n\t<servlet>\n\t\t<servlet-name>CXFServlet</servlet-name>\n\t\t<servlet-class>org.apache.cxf.transport.servlet.CXFServlet</servlet-class>\n\t</servlet>\n\t<servlet-mapping>\n\t\t<servlet-name>CXFServlet</servlet-name>\n\t\t<url-pattern>/service/*</url-pattern>\n\t</servlet-mapping>\n```\n\n案例：\n\n[WebService入门](https://gitee.com/syl_zzrfdsn/HelloWebService)","tags":["webservice"],"categories":["webservice"]},{"title":"NIO","url":"/2020/05/23/java/IO/nio/","content":"\n# NIO\n\n## 简介\n\nJava NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。\n\nNIO与原来的IO有同样的作用和目的，但是使用的方式完全不同。\n\nNIO支持`面向缓冲区`的、`基于通道的IO操作`。NIO将以更加高效的方式进行文件的读写操作。\n\n\n\n## NIO与IO的主要区别\n\n| IO                      | NIO                         |\n| ----------------------- | --------------------------- |\n| 面向流(Stream Oriented) | 面向缓冲区(Buffer Oriented) |\n| 阻塞IO(Blocking IO)     | 非阻塞IO(Non Blocking IO)   |\n| (无)                    | 选择器(Selectors)           |\n\n> 传统IO面向流，程序读取文件需要建立一个输入流\n\n![20191228175457](https://cdn.static.note.zzrfdsn.cn/images/io/20191228175457.gif)\n\n> 同样传统IO要想将程序中的内容输出到文件还要建立一个输出流\n\n![1577527290649](https://cdn.static.note.zzrfdsn.cn/images/io/1577527290649.png)\n\n> NIO面向缓存区，其中的通道也可以理解为传统IO中流，但是又有些差异\n\n如果把传统IO中流理解为生活中的水流(单向流动)，那么可以把NIO中的通道理解为生活中的火车轨道，只是一条通往两个地方的连接(A->B)，铁路是静止的，是无法完成运输的，要想从A到B就要坐上从A到B的火车(缓存区)，然后沿着这条轨道(通道)才能到达B，到达B之后乘客从火车上下来，同样火车又可以载着想从B到A的人沿着这条轨道再回到A\n\n![20191228181005](https://cdn.static.note.zzrfdsn.cn/images/io/20191228181005.gif)\n\n> 所以NIO中的缓存区是双向的\n\n![1577528211499](https://cdn.static.note.zzrfdsn.cn/images/io/1577528211499.png)\n\n\n\n?> **简而言之，通道负责传输， 缓存区负责存储**\n\n\n\n## 缓冲区(Buffer)\n\n`缓冲区（Buffer）`：一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类。\n\nJava NIO 中的 Buffer 主要用于与 NIO 通道进行交互，数据是从通道`读`入缓冲区，从缓冲区`写`入通道中的\n\n\n\nBuffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(boolean 除外) ，有以下 Buffer 常用子类：\n\n- **ByteBuffer**\n- **CharBuffer**\n- **ShortBuffer**\n- **IntBuffer**\n- **LongBuffer**\n- **FloatBuffer**\n- **DoubleBuff**\n\n上述 Buffer 类 他们都采用相似的方法进行管理数据，只是各自管理的数据类型不同而已。都是通过`allocate`静态方法获取一个 Buffer对象：\n\n```java\n//创建一个容量为 capacity 的 XxxBuffer 对象\nXxxBuffer.allocate(int capacity)\n```\n\n\n\n### 缓冲区的基本属性\n\n- `容量 (capacity)` ：表示 Buffer 最大数据容量，缓冲区容量不能为负，并且创建后不能更改。\n\n  (因为底层是数组，数组一但被创建就不能被改变)\n\n- `限制 (limit)`：界限，表示缓冲区中可以操作数据的大小。（limit 后数据不能进行读写）\n\n- `位置 (position)`：位置，表示缓冲区中正在操作数据的位置。\n\n- `标记 (mark)与重置 (reset)`：标记，表示记录当前 position 的位置。可以通过 reset() 恢复到 mark 的位置\n\n!> 标记、位置、限制、容量遵守以下不变式： `0 <= mark <= position <= limit <= capacity`\n\n```java\npublic class BufferTest {\n    \n    @Test\n    public void test01() throws Exception {\n        //通过 allocate() 获取缓冲区\n        ByteBuffer byteBuffer = ByteBuffer.allocate(10);\n        this.print(byteBuffer);\n    }\n\n    public void print(Buffer buffer) {\n        //表示 Buffer 最大数据容量\n        System.out.println(\"capacity：\" + buffer.capacity());\n\n        //界限，表示缓冲区中可以操作数据的大小\n        System.out.println(\"limit：\" + buffer.limit());\n\n        //位置，表示缓冲区中正在操作数据的位置\n        System.out.println(\"position：\" + buffer.position());\n    }\n\n}\n```\n\n输出结果：\n\n```\ncapacity：10\nlimit：10\nposition：0\n```\n\n\n\n### Buffer的常用方法 \n\n| 方 法                  | 描 述                                                     |\n| ---------------------- | --------------------------------------------------------- |\n| Buffer clear()         | 清空缓冲区并返回对缓冲区的引用                            |\n| Buffer flip()          | 将缓冲区的界限设置为当前位置，并将当前位置重置为 0        |\n| int capacity()         | 返回 Buffer 的 capacity 大小                              |\n| boolean hasRemaining() | 判断缓冲区中是否还有元素                                  |\n| int limit()            | 返回 Buffer 的界限(limit) 的位置                          |\n| Buffer limit(int n)    | 将设置缓冲区界限为 n, 并返回一个具有新 limit 的缓冲区对象 |\n| Buffer mark()          | 对缓冲区设置标记                                          |\n| int position()         | 返回缓冲区的当前位置 position                             |\n| Buffer position(int n) | 将设置缓冲区的当前位置为 n , 并返回修改后的 Buffer 对象   |\n| int remaining()        | 返回 position 和 limit 之间的元素个数                     |\n| Buffer reset()         | 将位置 position 转到以前设置的 mark 所在的位置            |\n| Buffer rewind()        | 将位置设为为 0， 取消设置的 mark                          |\n\n![1577534826954](https://cdn.static.note.zzrfdsn.cn/images/io/1577534826954.png)\n\n\n\n### 缓冲区的数据操作\n\n> Buffer 所有子类提供了两个用于数据操作的方法：**get()** 与 **put()** 方法\n\n- **获取 Buffer 中的数据**\n  - `get()` ：读取单个字节\n  - `get(byte[] dst)`：批量读取多个字节到 dst 中\n  - `get(int index)`：读取指定索引位置的字节(不会移动 position)\n\n- **放入数据到 Buffer 中**\n  - `put(byte b)`：将给定单个字节写入缓冲区的当前位置\n  - `put(byte[] src)`：将 src 中的字节写入缓冲区的当前位置\n  - `put(int index, byte b)`：将指定字节写入缓冲区的索引位置(不会移动 position)\n\n\n\n### put()\n\n```java\n@Test\npublic void test02() throws Exception {\n    ByteBuffer byteBuffer = ByteBuffer.allocate(10);\n    byteBuffer.put(\"abc\".getBytes());\n    this.print(byteBuffer);\n    byteBuffer.put(\"中\".getBytes());\n    this.print(byteBuffer);\n}\n```\n\n输出结果：\n\n```\ncapacity：10\nlimit：10\nposition：3\n\ncapacity：10\nlimit：10\nposition：6\n```\n\n\n\n### flip()\n\n```java\n@Test\npublic void test03() throws Exception {\n    ByteBuffer byteBuffer = ByteBuffer.allocate(10);\n    byteBuffer.put(\"abcde\".getBytes());\n    this.print(byteBuffer);\n    //切换读取数据模式,将缓冲区的界限(limit)设置为当前位置(position)，并将当前位置重置为 0\n    byteBuffer.flip();\n    this.print(byteBuffer);\n}\n```\n\n输出结果：\n\n```\ncapacity：10\nlimit：10\nposition：5\n\ncapacity：10\nlimit：5\nposition：0\n```\n\n\n\n### get()\n\n```java\n@Test\npublic void test04() throws Exception {\n    ByteBuffer byteBuffer = ByteBuffer.allocate(10);\n    byteBuffer.put(\"abcde\".getBytes());\n    this.print(byteBuffer);\n    //切换读取数据模式,将缓冲区的界限(limit)设置为当前位置(position)，并将当前位置重置为 0\n    byteBuffer.flip();\n    this.print(byteBuffer);\n    //利用 get() 读取缓冲区中的数据\n    byte[] b = new byte[byteBuffer.limit()];\n    byteBuffer.get(b);\n    System.out.println(new String(b));\n\n}\n```\n\n输出结果：\n\n```\ncapacity：10\nlimit：10\nposition：5\n\ncapacity：10\nlimit：5\nposition：0\n\nabcde\n\ncapacity：10\nlimit：5\nposition：5\n```\n\n\n\n### rewind()可重复读\n\n```java\n@Test\npublic void test05() throws Exception {\n    ByteBuffer byteBuffer = ByteBuffer.allocate(10);\n    byteBuffer.put(\"abcde\".getBytes());\n    //切换读取数据模式,将缓冲区的界限(limit)设置为当前位置(position)，并将当前位置重置为 0\n    byteBuffer.flip();\n    //利用 get() 读取缓冲区中的数据\n    byte[] b = new byte[byteBuffer.limit()];\n    byteBuffer.get(b);\n    System.out.println(new String(b));\n    this.print(byteBuffer);\n    byteBuffer.rewind();\n    this.print(byteBuffer);\n}\n```\n\n```\nabcde\n\ncapacity：10\nlimit：5\nposition：5\n\ncapacity：10\nlimit：5\nposition：0\n```\n\n\n\n### clear()  \n\n> 清空缓冲区. 但是缓冲区中的数据依然存在，但是处于“被遗忘”状态\n\n```java\n@Test\npublic void test06() throws Exception {\n    ByteBuffer byteBuffer = ByteBuffer.allocate(10);\n    byteBuffer.put(\"abcde\".getBytes());\n    //切换读取数据模式,将缓冲区的界限(limit)设置为当前位置(position)，并将当前位置重置为 0\n    byteBuffer.flip();\n    //利用 get() 读取缓冲区中的数据\n    byte[] b = new byte[byteBuffer.limit()];\n    byteBuffer.get(b);\n    System.out.println(new String(b));\n    this.print(byteBuffer);\n    \n    byteBuffer.rewind();\n    this.print(byteBuffer);\n    \n    byteBuffer.clear();\n    this.print(byteBuffer);\n    \n    System.out.println((char) byteBuffer.get());\n    System.out.println((char)byteBuffer.get());\n    System.out.println((char)byteBuffer.get());\n    System.out.println((char)byteBuffer.get());\n    System.out.println((char)byteBuffer.get());\n    System.out.println(byteBuffer.get());\n}\n```\n\n```\nabcde\n\ncapacity：10\nlimit：5\nposition：5\n\ncapacity：10\nlimit：5\nposition：0\n\ncapacity：10\nlimit：10\nposition：0\n\na\nb\nc\nd\ne\n0\n```\n\n\n\n### mark()和reset()\n\n> mark() : 标记，reset() : 恢复到 mark 的位置\n\n```\n@Test\npublic void test07() throws Exception {\n    ByteBuffer byteBuffer = ByteBuffer.allocate(10);\n    byteBuffer.put(\"abcde\".getBytes());\n    byteBuffer.flip();\n\n    byte[] bytes = new byte[byteBuffer.limit()];\n    byteBuffer.get(bytes, 0, 2);\n    System.out.println(byteBuffer.position());\n    //标记当前position位置\n    byteBuffer.mark();\n    System.out.println(new String(bytes));\n\n    //再读取两个\n    byteBuffer.get(bytes, byteBuffer.position(), 2);\n    System.out.println(byteBuffer.position());\n    System.out.println(new String(bytes));\n\n    //reset() : 恢复到 mark 的位置\n    byteBuffer.reset();\n    System.out.println(byteBuffer.position());\n    System.out.println((char) byteBuffer.get());\n}\n```\n\n```\n2\nab\n\n4\nabcd\n\n2\nc\n```\n\n\n\n### hasRemaining()和remaining()\n\n> hasRemaining()：判断缓冲区中是否还有剩余数据\n>\n> remaining()：获取缓冲区中可以操作的数量\n\n```java\n@Test\npublic void test08() throws Exception {\n    ByteBuffer byteBuffer = ByteBuffer.allocate(10);\n    byteBuffer.put(\"abcde\".getBytes());\n\n    System.out.println(byteBuffer.hasRemaining());\n    System.out.println(byteBuffer.remaining());\n\n\n    byteBuffer.put(\"12345\".getBytes());\n    System.out.println(byteBuffer.hasRemaining());\n    System.out.println(byteBuffer.remaining());\n}\n```\n\n```\ntrue\n5\n\nfalse\n0\n```\n\n\n\n## 直接与非直接缓冲区\n\n> 非直接缓冲区：通过 allocate() 方法分配缓冲区，将缓冲区建立在 JVM 的内存中\n>\n> 直接缓冲区：通过 allocateDirect() 方法分配直接缓冲区，将缓冲区建立在物理内存中。可以提高效率\n\n![1577535963932](https://cdn.static.note.zzrfdsn.cn/images/io/1577535963932.png)\n\n![1577536017071](https://cdn.static.note.zzrfdsn.cn/images/io/1577536017071.png)\n\n- 字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在\n  此缓冲区上执行本机 I/O 操作。也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），\n  虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。\n- 直接字节缓冲区可以通过调用此类的 `allocateDirect()` 工厂方法来创建。此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的\n  本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好\n  处时分配它们。\n- 直接字节缓冲区还可以通过 `FileChannel` 的 `map()` 方法 将文件区域直接映射到内存中来创建。该方法返回`MappedByteBuffer` 。Java 平台的实现有助于通过 JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。\n- 字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 `isDirect()` 方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理。\n\n\n\n```java\n@Test\npublic void test01() throws Exception {\n    //非直接缓存区\n    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n    System.out.println(byteBuffer.isDirect());\n    //直接缓存区\n    ByteBuffer directByteBuffer = ByteBuffer.allocateDirect(1024);\n    System.out.println(directByteBuffer.isDirect());\n}\n```\n\n```\nfalse\ntrue\n```\n\n\n\n## 通道(Channel)\n\n> 通道（Channel）：由 java.nio.channels 包定义的。Channel 表示 IO 源与目标打开的连接。\n> Channel 类似于传统的“流”。只不过 Channel 本身不能直接访问数据，Channel 只能与Buffer 进行交互。\n>\n> 简而言之就是用于源节点与目标节点的连接。在 Java NIO 中负责缓冲区中数据的传输。Channel 本身不存储数据，因此需要配合缓冲区进行传输。\n\n\n\n> 先来**了解**一下计算机的IO原理\n\n![1577538320259](https://cdn.static.note.zzrfdsn.cn/images/io/1577538320259.png)\n\n在Java应用程序要对磁盘中的数据进行读写的时候都要通过read或者write方法调用操作系统提供的IO接口进行读写操作\n\n在早期的时候所有的IO接口都是由CPU中央处理器独立负责的，这样也就是说当程序发出大量的读写请求时CPU的占用率就会变得非常高以至于CPU没有空闲的时间去调度其他的工作\n\n\n\n后来操作系统在内存和接口之间加了DMA(Direct Memory Access，直接内存存取)，这个时候如果应用程序再向操作系统发送读写请求，DMA会向CPU申请权限，CPU给(jǐ)予权限后所有的IO操作都将由DMA管理，在DMA控制器的控制下，在传送过程中就不需要中央处理器的参与，这个时候读写操作就不会占用CPU资源，但是大量的IO请求就有可能会造成总线冲突\n\n![1577538836863](https://cdn.static.note.zzrfdsn.cn/images/io/1577538836863.png)\n\n![9150e4e5gy1fy3oj4ctywj204z04kt8r](http://ww1.sinaimg.cn/large/9150e4e5gy1fy3oj4ctywj204z04kt8r.jpg)\n\n反正到最后就变成了通道，这个东东具有执行I/O指令的能力，并通过执行通道(I/O)程序来控制I/O操作，不需要CPU的介入，所以就提高了CPU的利用率\n\n![1577540113316](https://cdn.static.note.zzrfdsn.cn/images/io/1577540113316.png)\n\n\n\n![9150e4e5jw1fcdcmp73ptj204o05kq30](http://ww2.sinaimg.cn/large/9150e4e5jw1fcdcmp73ptj204o05kq30.jpg)\n\n\n\n### 主要实现类\n\n> Java 为 Channel 接口提供的最主要实现类如下：\n\n`java.nio.channels.Channel` 接口：\n\n- `FileChannel`：用于读取、写入、映射和操作文件的通道。\n- `DatagramChannel`：通过 UDP 读写网络中的数据通道。\n- `SocketChannel`：通过 TCP 读写网络中的数据。\n- `ServerSocketChannel`：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个SocketChannel。\n\n\n\n### 获取通道\n\n> 获取通道的一种方式是对支持通道的对象调用getChannel() 方法。支持通道的类如下：\n\n- FileInputStream\n- FileOutputStream\n- RandomAccessFile\n- DatagramSocket\n- Socket\n- ServerSocket\n- 在 JDK 1.7 中的 NIO.2 针对各个通道提供了静态方法 open()\n - 在 JDK 1.7 中的 NIO.2 的 Files 工具类的 newByteChannel()\n\n\n\n### 通道的数据传输\n\n> 利用通道完成文件的复制（非直接缓冲区）\n\n```java\n@Test\npublic void test01() throws Exception {\n    long start = System.currentTimeMillis();\n\n    FileInputStream in = new FileInputStream(\"resources/1.jpg\");\n    FileOutputStream out = new FileOutputStream(\"resources/1_copy.jpg\");\n    //创建缓存区\n    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n\n    FileChannel inChannel = in.getChannel();\n    FileChannel outChannel = out.getChannel();\n\n    //从 Channel 读取数据到 Buffer\n    while (inChannel.read(byteBuffer) != -1) {\n        //切换读取数据的模式\n        byteBuffer.flip();\n\n        //将 Buffer 中数据写入 Channel\n        outChannel.write(byteBuffer);\n\n        //清空缓冲区\n        byteBuffer.clear();\n    }\n    //关闭资源\n    if (outChannel != null) outChannel.close();\n    if (inChannel != null) inChannel.close();\n    if (out != null) out.close();\n    if (in != null) in.close();\n\n    long end = System.currentTimeMillis();\n    System.out.println(\"非直接缓冲区耗费时间：\" + (end - start));\n}\n```\n\n\n\n> 使用直接缓冲区完成文件的复制(内存映射文件)\n\n```java\n@Test\npublic void test02() throws Exception {\n    long start = System.currentTimeMillis();\n\n    //创建一个用于读的通道\n    FileChannel inChannel = FileChannel.open(Paths.get(\"resources\", \"1.jpg\"), StandardOpenOption.READ);\n\n    //创建一个用于写的通道,因为下面获取的内存映射是读写模式所以这里也要开启读的模式，如果文件不存在还需要能够创建\n    FileChannel outChannel = FileChannel.open(Paths.get(\"resources\", \"1_copy_2.jpg\"), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE);\n\n    //内存映射文件\n    MappedByteBuffer inMapBuffer = inChannel.map(FileChannel.MapMode.READ_ONLY, 0, inChannel.size());\n    MappedByteBuffer outMapBuffer = outChannel.map(FileChannel.MapMode.READ_WRITE, 0, inChannel.size());\n\n    //直接对缓存区进行读写操作,不需要通过通道操作\n    byte[] bytes = new byte[inMapBuffer.limit()];\n    inMapBuffer.get(bytes);\n    outMapBuffer.put(bytes);\n\n    outChannel.close();\n    inChannel.close();\n\n    long end = System.currentTimeMillis();\n    System.out.println(\"直接缓冲区耗费时间：\" + (end - start));\n}\n```\n\n\n\n### transferTo()和transferFrom()\n\n> 将数据从源通道传输到其他 Channel 中\n\n```java\n@Test\npublic void test03() throws Exception {\n    FileChannel inChannel = FileChannel.open(Paths.get(\"resources\", \"1.jpg\"), StandardOpenOption.READ);\n    FileChannel outChannel = FileChannel.open(Paths.get(\"resources\", \"1_copy_3.jpg\"), StandardOpenOption.WRITE, StandardOpenOption.CREATE);\n\n    inChannel.transferTo(0, inChannel.size(), outChannel);\n    //outChannel.transferFrom(inChannel, 0, inChannel.size());\n\n    outChannel.close();\n    inChannel.close();\n}\n```\n\n\n\n### 分散(Scatter)和聚集(Gather)\n\n> 分散读取（Scattering Reads）是指从 Channel 中读取的数据“分散”到多个 Buffer 中。\n\n![1577612307893](https://cdn.static.note.zzrfdsn.cn/images/io/1577612307893.png)\n\n> 聚集写入（Gathering Writes）是指将多个 Buffer 中的数据“聚集”到 Channel。\n\n![1577612355504](https://cdn.static.note.zzrfdsn.cn/images/io/1577612355504.png)\n\n\n\n```java\n@Test\npublic void test04() throws Exception {\n    RandomAccessFile file = new RandomAccessFile(\"resources/a1.txt\", \"rw\");\n    //获取通道\n    FileChannel inChannel = file.getChannel();\n\n    //分配指定大小的缓存区\n    ByteBuffer buffer1 = ByteBuffer.allocate(26);\n    ByteBuffer buffer2 = ByteBuffer.allocate(102);\n\n    //分散读取\n    ByteBuffer[] buffers = {buffer1, buffer2};\n    inChannel.read(buffers);\n\n    //切换读取数据模式\n    for (ByteBuffer buffer : buffers) {\n        buffer.flip();\n        //查看每个buffer读取的数据\n        System.out.println(new String(buffer.array(), 0, buffer.limit()));\n    }\n\n    //聚集写入\n    RandomAccessFile out = new RandomAccessFile(\"resources/a1_copy.txt\", \"rw\");\n    FileChannel outChannel = out.getChannel();\n    outChannel.write(buffers);\n\n    outChannel.close();\n    inChannel.close();\n    out.close();\n    file.close();\n}\n```\n\n\n\n### FileChannel的常用方法\n\n| 方法                          | 描述                                         |\n| ----------------------------- | -------------------------------------------- |\n| int read(ByteBuffer dst)      | 从 Channel 中读取数据到 ByteBuffer           |\n| long read(ByteBuffer[] dsts)  | 将 Channel 中的数据“分散”到 ByteBuffer[]     |\n| int write(ByteBuffer src)     | 将 ByteBuffer 中的数据写入到 Channel         |\n| long write(ByteBuffer[] srcs) | 将 ByteBuffer[] 中的数据“聚集”到 Channel     |\n| long position()               | 返回此通道的文件位置                         |\n| FileChannel position(long p)  | 设置此通道的文件位置                         |\n| long size()                   | 返回此通道的文件的当前大小                   |\n| FileChannel truncate(long s)  | 将此通道的文件截取为给定大小                 |\n| void force(boolean metaData)  | 强制将所有对此通道的文件更新写入到存储设备中 |\n\n\n\n## 字符集：Charset\n\n> 编码：字符串 -> 字节数组\n>\n> 解码：字节数组  -> 字符串\n\n\n\n```java\n@Test\npublic void test05() throws Exception {\n    //001.txt的编码为GBK\n    FileChannel channel = FileChannel.open(Paths.get(\"resources\", \"001.txt\"), StandardOpenOption.READ);\n    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n    channel.read(byteBuffer);\n    byteBuffer.flip();\n    //输出乱码,默认是使用UTF-8解码\n    System.out.println(new String(byteBuffer.array(), 0, byteBuffer.limit()));\n\n    Charset gbk = Charset.forName(\"GBK\");\n    //使用GBK编码格式进行解码\n    CharBuffer decode = gbk.decode(byteBuffer);\n    System.out.println(String.valueOf(decode.array()));\n\n    //使用GBK编码\n    ByteBuffer byteBuffer02 = gbk.encode(\"我爱你，亲爱的姑娘。。。\");\n    //乱码\n    System.out.println(new String(byteBuffer02.array(), 0, byteBuffer02.limit()));\n    //使用GBK解码\n    System.out.println(new String(byteBuffer02.array(), 0, byteBuffer02.limit(), gbk));\n}\n```\n\n输出结果：\n\n![1577620983665](https://cdn.static.note.zzrfdsn.cn/images/io/1577620983665.png)\n\n\n\n## 阻塞与非阻塞\n\n> 传统的 IO 流都是阻塞式的。也就是说，当一个线程调用 read() 或 write() 时，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务。因此，在完成网络通信进行 IO 操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量客户端时，性能急剧下降。\n\n>  Java NIO 是非阻塞模式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。因此，NIO 可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端。\n\n\n\n- 传统阻塞IO方式：客户端向服务器端发送请求，服务器端便开始进行监听客户端的数据是否传过来。这时候客户端在准备自己的数据，而服务器端就需要干等着。即使服务器端是多线程的，但有时一味增加线程数，只会让阻塞的线程越来越多。\n- NIO的非阻塞方式：将用于传输的通道全部注册到选择器上。\n- 选择器的作用是监控这些通道的IO状况（读，写，连接，接收数据的情况等状况）。\n- 选择器与通道之间的联系：\n  - 通道注册到选择器上\n  - 选择器监控通道\n  - 当某一通道，某一个事件就绪之后，选择器才会将这个通道分配到服务器端的一个或多个线程上，再继续运行。例如客户端需要发送数据给服务器端，只当客户端所有的数据都准备完毕后，选择器才会将这个注册的通道分配到服务器端的一个或多个线程上。而在客户端准备数据的这段时间，服务器端的线程可以执行别的任务。\n\n\n\n![1577622352000](https://cdn.static.note.zzrfdsn.cn/images/io/1577622352000.jpg)\n\n### SocketChannel\n\n> Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。\n\n**操作步骤：**\n\n- 打开 SocketChannel\n- 读写数据\n- 关闭 SocketChannel\n\n> Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道，就像标准IO中的ServerSocket一样。\n\n### 阻塞式NIO\n\n```java\npublic class BlockingNIOTest {\n\n    /**\n     * 客户端\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testClient() throws Exception {\n        //获取网络通道\n        SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(\"127.0.0.1\", 7001));\n\n        //获取读取本地文件的通道\n        FileChannel localFileChannel = FileChannel.open(Paths.get(\"resources\", \"1.jpg\"), StandardOpenOption.READ);\n\n        //分配指定大小的缓冲区\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n\n        //读取本地文件，并发送到服务端\n        while (localFileChannel.read(byteBuffer) != -1) {\n            byteBuffer.flip();\n            socketChannel.write(byteBuffer);\n            byteBuffer.clear();\n        }\n\n        //关闭通道\n        localFileChannel.close();\n        socketChannel.close();\n    }\n\n\n    /**\n     * 服务端\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testServer() throws Exception {\n        //获取服务端网络通道\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        //绑定端口号\n        serverSocketChannel.bind(new InetSocketAddress(7001));\n\n        //获取本地文件存储通道\n        FileChannel localFileChannel = FileChannel.open(\n                Paths.get(\"resources/server/1.jpg\"),\n                StandardOpenOption.WRITE, StandardOpenOption.CREATE);\n\n        //获取客户端连接的通道\n        SocketChannel clientSocketChannel = serverSocketChannel.accept();\n\n        //分配指定大小的缓冲区\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n\n        //接收客户端的数据，并保存到本地\n        while (clientSocketChannel.read(buffer) != -1) {\n            buffer.flip();\n            localFileChannel.write(buffer);\n            buffer.clear();\n        }\n\n        //关闭通道\n        clientSocketChannel.close();\n        localFileChannel.close();\n        serverSocketChannel.close();\n    }\n}\n```\n```java\npublic class BlockingNIOTest02 {\n\n    /**\n     * 客户端\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testClient() throws Exception {\n        //获取网络通道\n        SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(\"127.0.0.1\", 7001));\n\n        //获取读取本地文件的通道\n        FileChannel localFileChannel = FileChannel.open(Paths.get(\"resources\", \"1.jpg\"), StandardOpenOption.READ);\n\n        //分配指定大小的缓冲区\n        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n\n        //读取本地文件，并发送到服务端\n        while (localFileChannel.read(byteBuffer) != -1) {\n            byteBuffer.flip();\n            socketChannel.write(byteBuffer);\n            byteBuffer.clear();\n        }\n\n        socketChannel.shutdownOutput();\n        //接收服务端的反馈\n        int len = 0;\n        while ((len = socketChannel.read(byteBuffer)) != -1) {\n            byteBuffer.flip();\n            System.out.println(new String(byteBuffer.array(), 0, len));\n            byteBuffer.clear();\n        }\n\n        //关闭通道\n        localFileChannel.close();\n        socketChannel.close();\n    }\n\n    /**\n     * 服务端\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testServer() throws Exception {\n        //获取服务端网络通道\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        //绑定端口号\n        serverSocketChannel.bind(new InetSocketAddress(7001));\n\n        //获取本地文件存储通道\n        FileChannel localFileChannel = FileChannel.open(\n                Paths.get(\"resources/server/1.jpg\"),\n                StandardOpenOption.WRITE, StandardOpenOption.CREATE);\n\n        //获取客户端连接的通道\n        SocketChannel clientSocketChannel = serverSocketChannel.accept();\n\n        //分配指定大小的缓冲区\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n\n        //接收客户端的数据，并保存到本地\n        while (clientSocketChannel.read(buffer) != -1) {\n            buffer.flip();\n            localFileChannel.write(buffer);\n            buffer.clear();\n        }\n\n        //发送反馈消息给客户端\n        buffer.put(\"服务端成功接收\".getBytes());\n        buffer.flip();\n        clientSocketChannel.write(buffer);\n\n        //关闭通道\n        clientSocketChannel.close();\n        localFileChannel.close();\n        serverSocketChannel.close();\n    }\n}\n```\n\n\n\n### 选择器(Selector)\n\n> 选择器（Selector） 是 SelectableChannle 对象的多路复用器，Selector 可以同时监控多SelectableChannel 的 IO 状况，也就是说，利用 Selector 可使一个单独的线程管理多个 Channel。Selector 是非阻塞 IO 的核心。\n\n**SelectableChannle 的结构如下：**\n\n![1577694612406](https://cdn.static.note.zzrfdsn.cn/images/io/1577694612406.png)\n\n\n\n### 选择器(Selector)的应用\n\n> 创建 Selector ：通过调用 Selector.open() 方法创建一个 Selector。\n\n```java\n Selector selector = Selector.open();\n```\n\n\n\n> 向选择器注册通道：SelectableChannel.register(Selector sel, int op\n\n```java\n@Test\npublic void testSelector() throws Exception {\n    //获取socket网络通道\n    SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(\"127.0.0.1\", 80));\n\n    //创建 Selector ：通过调用 Selector.open() 方法创建一个 Selector。\n    Selector selector = Selector.open();\n\n    //将SocketChannel切换到非阻塞模式\n    socketChannel.configureBlocking(false);\n\n    //向选择器注册通道：\n    SelectionKey selectionKey = socketChannel.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ);\n}\n```\n\n\n\n\n\n### SelectionKey\n\n- 当调用 register(Selector sel, int ops) 将通道注册选择器时，选择器对通道的监听事件，需要通过第二个参数 ops 指定。\n\n- 可以监听的事件类型（可使用 SelectionKey 的四个常量表示）：\n\n  - 读 : SelectionKey.OP_READ （1）\n\n  - 写 : SelectionKey.OP_WRITE （4）\n\n  - 连接 : SelectionKey.OP_CONNECT （8）\n\n  - 接收 : SelectionKey.OP_ACCEPT （16）\n\n  - 若注册时不止监听一个事件，则可以使用“位或”操作符连接。\n\n    ```java\n    //向选择器注册通道：\n    socketChannel.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ);\n    ```\n\n    \n\n> SelectionKey：表示 SelectableChannel 和 Selector 之间的注册关系。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作。\n\n| 方 法                       | 描 述                            |\n| --------------------------- | -------------------------------- |\n| int interestOps()           | 获取感兴趣事件集合               |\n| int readyOps()              | 获取通道已经准备就绪的操作的集合 |\n| SelectableChannel channel() | 获取注册通道                     |\n| Selector selector()         | 返回选择器                       |\n| boolean isReadable()        | 检测 Channal 中读事件是否就绪    |\n| boolean isWritable()        | 检测 Channal 中写事件是否就绪    |\n| boolean isConnectable()     | 检测 Channel 中连接是否就绪      |\n| boolean isAcceptable()      | 检测 Channel 中接收是否就绪      |\n\n\n\n### Selector的常用方法\n\n| 方 法                      | 描 述                                                        |\n| -------------------------- | ------------------------------------------------------------ |\n| Set\\<SelectionKey\\> keys() | 所有的 SelectionKey 集合。代表注册在该Selector上的Channel    |\n| selectedKeys()             | 被选择的 SelectionKey 集合。返回此Selector的已选择键集       |\n| int select()               | 监控所有注册的Channel，当它们中间有需要处理的 IO 操作时，该方法返回，并将对应得的 SelectionKey 加入被选择的集合中，该方法返回这些 Channel 的数量。 |\n| int select(long timeout)   | 可以设置超时时长的 select() 操作                             |\n| int selectNow()            | 执行一个立即返回的 select() 操作，该方法不会阻塞线程         |\n| Selector wakeup()          | 使一个还未返回的 select() 方法立即返回                       |\n| void close()               | 关闭该选择器                                                 |\n\n\n\n### 非阻塞式NIO\n\n```java\npublic class NonBlockingNIOTest {\n    /**\n     * 客户端\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testClient() throws Exception {\n        //获取通道\n        SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(\"127.0.0.1\", 7001));\n\n        //切换到非阻塞模式\n        socketChannel.configureBlocking(false);\n\n        //分配指定大小的缓冲区\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n\n        //创建标准输入流\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"键入您的昵称：\");\n        String name = scanner.nextLine();\n        System.out.println(\"OK，开始聊天吧！\");\n        while (scanner.hasNext()) {\n            String info = scanner.nextLine();\n            if (\"quit\".equals(info)) {\n                break;\n            }\n            String msg = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\").format(LocalDateTime.now()) + \"：\\n\" + name + \"：\" + info;\n            buffer.put(msg.getBytes());\n            buffer.flip();\n            socketChannel.write(buffer);\n            buffer.clear();\n        }\n\n        //关闭通道\n        socketChannel.close();\n    }\n\n    /**\n     * 服务端\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testServer() throws Exception {\n        //获取通道\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        serverSocketChannel.bind(new InetSocketAddress(7001));\n\n        //切换到非阻塞模式\n        serverSocketChannel.configureBlocking(false);\n\n        //获取选择器\n        Selector selector = Selector.open();\n\n        //将通道注册到选择器，并且指定“监听接收事件”\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        //轮询式的获取选择器上已经“准备就绪”的事件\n        while (selector.select() > 0) {\n            //获取当前选择器中所有注册的“选择键(已就绪的监听事件)”\n            Set<SelectionKey> selectionKeys = selector.selectedKeys();\n            Iterator<SelectionKey> it = selectionKeys.iterator();\n            while (it.hasNext()) {\n                //获取准备“就绪”的事件\n                SelectionKey sk = it.next();\n\n                // 判断具体是什么事件准备就绪\n                if (sk.isAcceptable()) {\n                    //若“接收就绪”，获取客户端连接\n                    SocketChannel socketChannel = serverSocketChannel.accept();\n\n                    //切换到非阻模式\n                    socketChannel.configureBlocking(false);\n\n                    //将该通道注册到选择器上\n                    socketChannel.register(selector, SelectionKey.OP_READ);\n                } else if (sk.isReadable()) {\n                    //获取当前选择器上“读就绪”状态的通道\n                    SocketChannel socketChannel = (SocketChannel) sk.channel();\n\n                    //分配缓冲区\n                    ByteBuffer buffer = ByteBuffer.allocate(1024);\n                    //读取数据,客户端没有关闭，不能判断是否-1,返回的可能是0\n                    while (socketChannel.read(buffer) > 0) {\n                        buffer.flip();\n                        System.out.println(new String(buffer.array(), 0, buffer.limit()));\n                        buffer.clear();\n                    }\n\n                }\n\n                //用完之后取消选择键 SelectionKey，不然下一次循环这个已经就绪的SelectionKey还存在\n                it.remove();\n            } //end while\n        }\n\n    }\n}\n```\n\n\n\n> IDEA控制台单元测试无法输入\n>\n> 点击Help>Edit Custom VM Options，天津哎如下一行，然后重启IDEA\n\n```properties\n-Deditable.java.test.console=true\n```\n\n\n\n## DatagramChannel \n\n> Java NIO中的DatagramChannel是一个能收发UDP包的通道。\n\n**操作步骤：**\n\n- 打开 DatagramChannel\n- 接收/发送\n\n```java\npublic class NonBlockingNIO_UDPTest {\n\n    /**\n     * 发送端\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testSend() throws Exception {\n        //获取网络通道\n        DatagramChannel datagramChannel = DatagramChannel.open();\n\n        //设置为非阻塞模式\n        datagramChannel.configureBlocking(false);\n\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"键入你的昵称：\");\n        String name = scanner.nextLine();\n        System.out.println(\"OK,开始聊天吧!\");\n        while (scanner.hasNext()) {\n            String info = scanner.next();\n            if (\"quit\".equalsIgnoreCase(info)) {\n                break;\n            }\n            String msg = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\").format(LocalDateTime.now()) + \"：\\n\" + name + \"：\" + info;\n            buffer.put(msg.getBytes());\n            buffer.flip();\n            datagramChannel.send(buffer, new InetSocketAddress(\"127.0.0.1\", 7001));\n            buffer.clear();\n        }\n\n        datagramChannel.close();\n    }\n\n    /**\n     * 接收端\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testReceive() throws Exception {\n        DatagramChannel datagramChannel = DatagramChannel.open();\n        datagramChannel.bind(new InetSocketAddress(7001));\n\n        //设置为非阻塞模式\n        datagramChannel.configureBlocking(false);\n\n        //创建选择器\n        Selector selector = Selector.open();\n\n        //注册到选择器\n        datagramChannel.register(selector, SelectionKey.OP_READ);\n        while (selector.select() > 0) {\n            Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n            while (it.hasNext()) {\n                SelectionKey sk = it.next();\n                if (sk.isReadable()) {\n                    ByteBuffer buffer = ByteBuffer.allocate(1024);\n                    datagramChannel.receive(buffer);\n                    buffer.flip();\n                    System.out.println(new String(buffer.array(), 0, buffer.limit()));\n                    buffer.clear();\n                }\n            }\n            it.remove();\n        }\n    }\n}\n```\n\n\n\n## 管道(pipe)\n\n> Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。\n\n![1577706711253](https://cdn.static.note.zzrfdsn.cn/images/io/1577706711253.png)\n\n\n\n```java\npublic static void main(String[] args) throws Exception {\n    Pipe pipe = Pipe.open();\n\n    ThreadFactory threadFactory = Executors.defaultThreadFactory();\n    ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 2, 0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>(), threadFactory);\n    //线程A 将数据写到sink通道\n    threadPool.execute(() -> {\n        Pipe.SinkChannel sinkChannel = pipe.sink();\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n        try {\n            int i = 0;\n            while (i < 10) {\n                Thread.sleep(1000);\n                buffer.put(formatter.format(LocalDateTime.now()).getBytes());\n                buffer.flip();\n                sinkChannel.write(buffer);\n                buffer.clear();\n                i++;\n            }\n            sinkChannel.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    });\n\n    //线程B 从source通道读取数据\n    threadPool.execute(() ->\n\n    {\n        Pipe.SourceChannel sourceChannel = pipe.source();\n        ByteBuffer buffer = ByteBuffer.allocate(1024);\n        try {\n            while (sourceChannel.read(buffer) > 0) {\n                buffer.flip();\n                System.out.println(new String(buffer.array(), 0, buffer.limit()));\n                buffer.clear();\n            }\n            sourceChannel.close();\n            threadPool.shutdown();\n        } catch (Exception e) {\n        }\n    });\n}\n```","tags":["java"],"categories":["java"]},{"title":"NIO2","url":"/2020/05/23/java/IO/nio2/","content":"\n# NIO.2\n\n> 随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。因为 NIO 提供的一些功能，NIO已经成为文件处理中越来越重要的部分。\n\n\n\n## Path 与 Paths\n\n> java.nio.file.Path 接口代表一个平台无关的平台路径，描述了目录结构中文件的位置。\n\n> Paths 提供的 get() 方法用来获取 Path 对象：\n\n`Path get(String first, String … more)` : 用于将多个字符串串连成路径\n\n\n\n> Path 常用方法\n\n- `boolean endsWith(String path)` : 判断是否以 path 路径结束\n- `boolean startsWith(String path)` : 判断是否以 path 路径开始\n- `boolean isAbsolute()` : 判断是否是绝对路径\n- `Path getFileName()` : 返回与调用 Path 对象关联的文件名\n- `Path getName(int idx)` : 返回的指定索引位置 idx 的路径名称\n- `int getNameCount()` : 返回Path 根目录后面元素的数量\n- `Path getParent()` ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径\n- `Path getRoot()` ：返回调用 Path 对象的根路径\n- `Path resolve(Path p)` :将相对路径解析为绝对路径\n- `Path toAbsolutePath()` : 作为绝对路径返回调用 Path 对象\n- `String toString()` ： 返回调用 Path 对象的字符串表示\n\n\n\n## Files\n\n> java.nio.file.Files 用于操作文件或目录的工具类。\n\n\n\n> Files常用方法\n\n- `Path copy(Path src, Path dest, CopyOption … how)` : 文件的复制\n- `Path createDirectory(Path path, FileAttribute<?> … attr)` : 创建一个目录\n- `Path createFile(Path path, FileAttribute<?> … arr)` : 创建一个文件\n- `void delete(Path path)` : 删除一个文件\n- `Path move(Path src, Path dest, CopyOption…how)` : 将 src 移动到 dest 位置\n- `long size(Path path)` : 返回 path 指定文件的\n- `boolean exists(Path path, LinkOption … opts)` : 判断文件是否存在\n- `boolean isDirectory(Path path, LinkOption … opts)` : 判断是否是目录\n- `boolean isExecutable(Path path)` : 判断是否是可执行文件\n- `boolean isHidden(Path path)` : 判断是否是隐藏文件\n- `boolean isReadable(Path path)` : 判断文件是否可\n- `boolean isWritable(Path path)` : 判断文件是否可写\n- `boolean notExists(Path path, LinkOption … opts)` : 判断文件是否不存在\n- `public static <A extends BasicFileAttributes> A readAttributes(Path path,Class<A> type,LinkOption...` `options)` : 获取与 path 指定的文件相关联的属\n- `SeekableByteChannel newByteChannel(Path path, OpenOption…how)` : 获取与指定文件的连接，\n  how 指定打开方式。\n- `DirectoryStream newDirectoryStream(Path path)` : 打开 path 指定的目录\n- `InputStream newInputStream(Path path, OpenOption…how)`:获取 InputStream 对象\n- `OutputStream newOutputStream(Path path, OpenOption…how)` : 获取 OutputStream 对象\n\n\n\n## 自动资源管理\n\n> Java 7 增加了一个新特性，该特性提供了另外一种管理资源的方式，这种方式能自动关闭文\n> 件。这个特性有时被称为自动资源管理(Automatic Resource Management, ARM)\n> 该特性以 try 语句的扩展版为基础。自动资源管理主要用于，当不再需要文件（或其他资源）时，可以防止无意中忘记释放它们。\n\n\n\n**自动资源管理基于 try 语句的扩展形式：**\n\n```java\ntry (需要关闭的资源声明) {\n    //可能发生异常的\n} catch (Exception e) {\n    //异常的处理\n} finally {\n\t//一定执行的语句\n}\n```\n\n当 try 代码块结束时，自动释放资源。因此不需要显示的调用 close() 方法。该形式也称为“带资源的 try 语句”。\n\n**注意：**\n\n1. try 语句中声明的资源被隐式声明为 final ，资源的作用局限于带资源的 try 语句\n2. 可以在一条 try 语句中管理多个资源，每个资源以“;” 隔开即可。\n3. 需要关闭的资源，必须实现了 AutoCloseable 接口或其自接口 Closeable","tags":["java"],"categories":["java"]},{"title":"LinkedList原理","url":"/2020/05/23/java/collection/linkedList/","content":"\n#   LinkedList原理\n\n[TOC]\n\nLinkedList底层用双向链表实现的存储。特点：查询效率低，增删效率高，线程不安全。\n\n​      双向链表也叫双链表，是链表的一种，它的每个数据节点中都有两个指针，分别指向前一个节点和后一个节点。 所以，从双向链表中的任意一个节点开始，都可以很方便地找到所有节点。\n\n![ LinkedList的存储结构图.png](https://cdn.static.note.zzrfdsn.cn/images/1495616843888130.png)\n\n​      每个节点都应该有3部分内容：\n\n​      我们查看LinkedList的源码，可以看到里面包含了双向链表的相关代码：\n\n![LinkedList的底层源码.png](https://cdn.static.note.zzrfdsn.cn/images/20191030205358.png)  \n![ LinkedList的底层源码.png](https://cdn.static.note.zzrfdsn.cn/images/20191030205526.png)\n\n## 自己实现linkedlist\n\n``` java\npackage cn.clboy.linkedlist;\n\nimport java.util.*;\n\n/**\n * @Author cloudlandboy\n * @Since 1.0.0\n */\n\npublic class MyLinkedList<E> {\n\n\n    /**\n     * 当前列表中节点数量\n     */\n    private int size = 0;\n\n    /**\n     * 第一个节点\n     */\n    private MyLinkedList.Node<E> first;\n\n    /**\n     * 最后一个节点\n     */\n    private MyLinkedList.Node<E> last;\n\n    public int size() {\n        return this.size;\n    }\n\n    public boolean isEmpty() {\n        return this.size == 0;\n    }\n\n    /**\n     * 添加节点\n     *\n     * @param element\n     * @return\n     */\n    public boolean add(E element) {\n        Node<E> temp = last;\n        //创建一个新节点\n        Node<E> newNode = new Node<E>(last, element, null);\n        //新添加的就是最后一个节点\n        last = newNode;\n        //判断添加前最后的节点是否存在值，不存在说明是第一次添加,那么第一个节点也是新添加的这个节点\n        if (temp == null) {\n            first = newNode;\n        } else {\n            //不是null，那么就不是第一次添加，把next链接到新添加的节点\n            temp.next = newNode;\n        }\n\n        //当前列表中节点数量+1\n        size++;\n        return true;\n    }\n\n    /**\n     * 获取节点，内部使用\n     *\n     * @param index\n     * @return\n     */\n    private Node<E> node(int index) {\n        //判断下标是否合法\n        if (index < 0 || index > size - 1) {\n            throw new IndexOutOfBoundsException(\"下标不合法\");\n        }\n\n        //提高效率，如果下标大于size的一半则倒序循环,因为取得是next所以循环到index前一个\n        Node<E> node;\n        if (index < size / 2) {\n            node = first;\n            for (int i = 0; i < index; i++) {\n                node = node.next;\n            }\n        } else {\n            node = last;\n            for (int i = size - 1; i > index; i--) {\n                node = node.prev;\n            }\n        }\n\n        return node;\n    }\n\n    /**\n     * 获取指定索引的值\n     *\n     * @param index\n     * @return\n     */\n    public E get(int index) {\n        Node<E> node = node(index);\n        return node.item;\n    }\n\n    /**\n     * 设置指定索引处的值\n     *\n     * @param index\n     * @param element\n     * @return\n     */\n    public E set(int index, E element) {\n        Node<E> node = node(index);\n        //先获取旧值\n        E oldValue = node.item;\n        //设置新值\n        node.item = element;\n        //将旧值返回\n        return oldValue;\n    }\n\n    /**\n     * 删除匹配节点\n     *\n     * @param element\n     * @return\n     */\n    public boolean remove(E element) {\n        Node<E> temp = first;\n        //循环比较值是否相等\n        while (temp != null) {\n            //处理null值情况\n            if (element == null && temp.item == null) {\n                unlink(temp);\n                return true;\n            } else if (element != null && element.equals(temp.item)) {\n                //非null进行equals比较\n                unlink(temp);\n                return true;\n            }\n            temp = temp.next;\n        }\n        return false;\n    }\n\n    /**\n     * 删除节点内部使用\n     *\n     * @param node\n     */\n    private E unlink(Node<E> node) {\n        Node<E> prev = node.prev;\n        Node<E> next = node.next;\n\n        //是第一个节点\n        if (prev == null) {\n            //将下一个节点变为第一个节点\n            next.prev = null;\n            first = next;\n        } else {\n            //直接将当前节点的上一个节点与当前节点的下一个节点链接，清空当前节点引用\n            prev.next = next;\n            node.prev = null;\n        }\n        //是最后一个节点\n        if (next == null) {\n            //将上一个节点变为最后一个节点\n            prev.next = null;\n            last = prev;\n        } else {\n            //直接将当前节点的下一个节点与当前节点的上一个节点链接，清空当前节点引用\n            next.prev = prev;\n            node.next = null;\n        }\n\n        E value = node.item;\n        node.item = null;\n        //数量减一\n        size--;\n        return value;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder console = new StringBuilder(\"[\");\n        Node<E> temp = first;\n        while (temp != null) {\n            console.append(temp.item).append(\",\");\n            temp = temp.next;\n        }\n        console.setCharAt(console.length() - 1, ']');\n\n        return console.toString();\n    }\n\n    private static class Node<E> {\n        E item;\n        MyLinkedList.Node<E> next;\n        MyLinkedList.Node<E> prev;\n\n        Node(MyLinkedList.Node<E> prev, E element, MyLinkedList.Node<E> next) {\n            this.item = element;\n            this.next = next;\n            this.prev = prev;\n        }\n    }\n\n}\n```\n\n","tags":["java"],"categories":["java"]},{"title":"HashMap和HashTable","url":"/2020/05/23/java/collection/map/","content":"\n# HashMap和HashTable\n\n[TOC]\n\n​      HashMap底层实现采用了哈希表，这是一种非常重要的数据结构。\n\n​      数据结构中由数组和链表来实现对数据的存储，他们各有特点。\n\n​      (1) 数组：占用空间连续。 寻址容易，查询速度快。但是，增加和删除效率非常低。\n\n​      (2) 链表：占用空间不连续。 寻址困难，查询速度慢。但是，增加和删除效率非常高。\n\n​      那么，我们能不能结合数组和链表的优点(即查询快，增删效率也高)呢? 答案就是“哈希表”。 哈希表的本质就是“数组+链表”。\n\n##   Hashmap基本结构讲解\n\n​      哈希表的基本结构就是“数组+链表”。我们打开HashMap源码，发现有如下两个核心内容：\n\n![图9-12 HashMap底层源码(1).png](https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495618960152437.png)\n\n​      其中的Entry[] table（在jdk1.8中是Node<K,V>[] table） 就是HashMap的核心数组结构，我们也称之为“位桶数组”。我们再继续看Entry是什么，源码如下：\n\n![图9-13 HashMap底层源码(2).png](https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495619012687826.png)\n\n​      一个Entry对象存储了：\n\n​      1. key：键对象 value：值对象\n\n​      2. next:下一个节点\n\n​      3. hash: 键对象的hash值\n\n​      显然每一个Entry对象就是一个单向链表结构，我们使用图形表示一个Entry对象的典型示意：\n\n![图9-14 Entry对象存储结构图.png](https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495619082593896.png)\n\n图9-14 Entry对象存储结构图\n\n​      然后，我们画出Entry[]数组的结构(这也是HashMap的结构)：\n\n![图9-15 Entry数组存储结构图.png](https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495619119905721.png)\n\n##  存储数据过程put(key,value)\n\n​      明白了HashMap的基本结构后，我们继续深入学习HashMap如何存储数据。此处的核心是如何产生hash值，该值用来对应数组的存储位置。\n\n![图9-16 HashMap存储数据过程示意图.png](https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495619181777762.png)\n\n图9-16 HashMap存储数据过程示意图\n\n​      我们的目的是将”key-value两个对象”成对存放到HashMap的Entry[]数组中。参见以下步骤：\n\n​      (1) 获得key对象的hashcode\n\n​           首先调用key对象的hashcode()方法，获得hashcode。\n\n​      (2) 根据hashcode计算出hash值(要求在[0, 数组长度-1]区间)\n\n​           hashcode是一个整数，我们需要将它转化成[0, 数组长度-1]的范围。我们要求转化后的hash值尽量均匀地分布在[0,数组长度-1]这个区间，减少“hash冲突”\n\n​           i. 一种极端简单和低下的算法是：\n\n​           hash值 = hashcode/hashcode;\n\n​           也就是说，hash值总是1。意味着，键值对对象都会存储到数组索引1位置，这样就形成一个非常长的链表。相当于每存储一个对象都会发生“hash冲突”，HashMap也退化成了一个“链表”。\n\n​           ii. 一种简单和常用的算法是(相除取余算法)：\n\n​           hash值 = hashcode%数组长度\n\n​           这种算法可以让hash值均匀的分布在[0,数组长度-1]的区间。 早期的HashTable就是采用这种算法。但是，这种算法由于使用了“除法”，效率低下。JDK后来改进了算法。首先约定数组长度必须为2的整数幂，这样采用位运算即可实现取余的效果：hash值 = hashcode&(数组长度-1)。\n\n​           iii. 如下为我们自己测试简单的hash算法：\n\n## 测试hash算法\n\n​      运行程序，我们就能发现直接取余(h%length)和位运算(h&(length-1))结果是一致的。事实上，为了获得更好的散列效果，JDK对hashcode进行了两次散列处理(核心目标就是为了分布更散更均匀)，源码如下：\n\n![图9-17 hash算法源码.png](https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495619395858263.png)\n\n图9-17 hash算法源码\n\n​      (3) 生成Entry对象\n\n​          如上所述，一个Entry对象包含4部分：key对象、value对象、hash值、指向下一个Entry对象的引用。我们现在算出了hash值。下一个Entry对象的引用为null。\n\n​      (4) 将Entry对象放到table数组中\n\n​          如果本Entry对象对应的数组索引位置还没有放Entry对象，则直接将Entry对象存储进数组;如果对应索引位置已经有Entry对象，则将已有Entry对象的next指向本Entry对象，形成链表。\n\n## 总结如上过程：\n\n​      当添加一个元素(key-value)时，首先计算key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，就形成了链表，同一个链表上的Hash值是相同的，所以说数组存放的是链表。 JDK8中，当链表长度大于8时，链表就转换为红黑树，这样又大大提高了查找的效率。\n\n##  取数据过程get(key)\n\n​      我们需要通过key对象获得“键值对”对象，进而返回value对象。明白了存储数据过程，取数据就比较简单了，参见以下步骤：\n\n​      (1) 获得key的hashcode，通过hash()散列算法得到hash值，进而定位到数组的位置。\n\n​      (2) 在链表上挨个比较key对象。 调用equals()方法，将key对象和链表上所有节点的key对象进行比较，直到碰到返回true的节点对象为止。\n\n​      (3) 返回equals()为true的节点对象的value对象。\n\n​      明白了存取数据的过程，我们再来看一下hashcode()和equals方法的关系：\n\n​      Java中规定，两个内容相同(equals()为true)的对象必须具有相等的hashCode。因为如果equals()为true而两个对象的hashcode不同;那在整个存储过程中就发生了悖论。\n\n## 扩容问题\n\n​      HashMap的位桶数组，初始大小为16。实际使用时，显然大小是可变的。如果位桶数组中的元素达到(0.75*数组 length)， 就重新调整数组大小变为原来2倍大小。\n\n​      扩容很耗时。扩容的本质是定义新的更大的数组，并将旧数组内容挨个拷贝到新数组中。\n\n## JDK8将链表在大于8情况下变为红黑二叉树\n\n​      JDK8中，HashMap在存储一个元素时，当对应链表长度大于8时，链表就转换为红黑树，这样又大大提高了查找的效率。\n\n## 实现简单的HashMap\n\n```java\npackage cn.clboy.map;\n\n/**\n * @Author cloudlandboy\n * @Since 1.0.0\n */\n\npublic class MyHashMap<K, V> {\n\n    /**\n     * 默认初始大小\n     */\n    static final int DEFAULT_INITIAL_CAPACITY = 16;\n    /**\n     * 存放的键值对的个数\n     */\n    private int size;\n\n    public int getSize() {\n        return size;\n    }\n\n    /**\n     * 链表数组\n     *\n     * @param <K>\n     * @param <V>\n     */\n    private Node<K, V>[] table;\n\n\n    /**\n     * 创建对象时初始化数组,容量为默认的16\n     */\n    public MyHashMap() {\n        table = new Node[DEFAULT_INITIAL_CAPACITY];\n    }\n\n\n    /**\n     * 计算hash\n     *\n     * @return\n     */\n    public static int hash(int hashcode, int num) {\n        //对象hashcode与数组长度取余，就是0到数组长度-1\n        int hash = hashcode % num;\n        //hashcode可能为负值\n        return hash > 0 ? hash : -hash;\n    }\n\n    /**\n     * 链表中的节点对象\n     *\n     * @param <K>\n     * @param <V>\n     */\n    static class Node<K, V> {\n        final int hash;\n        final K key;\n        V value;\n        MyHashMap.Node<K, V> next;\n\n        Node(int hash, K key, V value, MyHashMap.Node<K, V> next) {\n            this.hash = hash;\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n    }\n\n    /**\n     * 添加元素\n     */\n    public void put(K key, V value) {\n        //首先对key进行hash计算，得出应该放在数组的哪个索引位置\n        int index = hash(key.hashCode(), table.length);\n        //判断该索引位置是否已经存在元素\n        Node<K, V> temp = table[index];\n        //不存在元素，直接放进去\n        if (temp == null) {\n            table[index] = new Node<K, V>(index, key, value, null);\n        } else {\n            //迭代链表\n            Node<K, V> last = temp;\n            while (temp != null) {\n                //判断key是否已经存在，存在则覆盖value值\n                if (temp.key.equals(key)) {\n                    temp.value = value;\n                    return;//添加方法结束,size不改变\n                }\n                //不存在则继续顺着链表寻找\n                last = temp;\n                temp = temp.next;\n            }\n            //整个循环结束，没有匹配到相同的key，则直接放到链表末尾\n            last.next = new Node<K, V>(index, key, value, null);\n        }\n        size++;\n    }\n\n    /**\n     * 获取元素\n     *\n     * @param key\n     */\n    public V get(K key) {\n        //先对key取hash\n        int index = hash(key.hashCode(), table.length);\n        //获取与hash对应下标处的元素\n        Node<K, V> temp = table[index];\n        //迭代进行key比较\n        while (temp != null) {\n            if (temp.key.equals(key)) {\n                return temp.value;\n            }\n            temp = temp.next;\n        }\n        //循环完毕，没有查到返回null\n        return null;\n    }\n\n\n    @Override\n    public String toString() {\n        StringBuilder str = new StringBuilder(\"{\");\n        for (Node<K, V> node : table) {\n            while (node != null) {\n                str.append(node.key + \":\" + node.value + \",\");\n                node = node.next;\n            }\n        }\n        str.setCharAt(str.length() - 1, '}');\n        return str.toString();\n    }\n}\n```\n\n``` java\npackage cn.clboy;\n\nimport cn.clboy.map.MyHashMap;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        MyHashMap<String, String> map = new MyHashMap<>();\n\n        for (int i = 0; i < 50; i++) {\n            map.put(i + \"\", \"hello_map\" + i);\n        }\n\n        map.put(\"1\", \"hello_map_up_001\");\n        System.out.println(map.getSize());\n\n        System.out.println(\"--------------------------------------\");\n        //获取元素\n        String val1 = map.get(\"33\");\n        System.out.println(val1);\n        //重新设置值\n        map.put(\"33\", \"update_33\");\n        //再获取\n        String val2 = map.get(\"33\");\n        System.out.println(val2);\n\n        //toString\n        map = new MyHashMap<>();\n        map.put(\"name\", \"张三\");\n        map.put(\"age\", \"33\");\n        map.put(\"gender\", \"男\");\n        map.put(\"address\", \"北京市朝阳区\");\n        System.out.println(map);\n\n    }\n}\n\n```\n\n","tags":["java"],"categories":["java"]},{"title":"线程实现方式","url":"/2020/05/23/java/thread/002/","content":"\n\n# 实现线程的几种方式\n\n[TOC]\n\n## 继承Thread类\n创建线程的步骤：\n1. 定义一个类继承Thread。\n2. 重写run方法。\n3. 创建子类对象，就是创建线程对象。\n4. 调用start方法，开启线程并让线程执行，同时还会告诉jvm去调用run方法。\n\n``` java\npackage cn.clboy;\n\npublic class Main {\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        //第一种方式，继承Thread类\n        callFirst();\n        \n        for (int i = 0; i < 280; i++) {\n            System.out.println(\"偷瞄老师\");\n        }\n        \n    }\n    \n    public static void callFirst() {\n        //继承Thread类,直接调用继承过来的start方法,开启一个线程\n        First first = new First();\n        first.start();\n    }\n\n}\n\n/**\n * 第一种方法，继承Thread类，重写run方法\n */\nclass First extends Thread {\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 280; i++) {\n            System.out.println(\"------偷偷吃零食-------\");\n        }\n    }\n}\n```\n\n思考：线程对象调用 run方法和调用start方法区别？\n\n线程对象调用run方法不开启线程。仅是对象调用方法。线程对象调用start开启线程，并让jvm调用run方法在开启的线程中执行。\n\n## 实现Runnable接口\n\n创建线程的另一种方法是声明实现 Runnable 接口的类。该类然后实现 run 方法。然后创建Runnable的子类对象，传入到某个线程的构造方法中，开启线程。\n\n为何要实现Runnable接口，Runable是啥玩意呢？\n\n查看Runnable接口说明文档：Runnable接口用来指定每个线程要执行的任务。包含了一个 run 的无参数抽象方法，需要由接口实现类重写该方法。\n\n创建线程的步骤。\n\n1. 定义类实现Runnable接口。\n2. 覆盖接口中的run方法。。\n3. 创建Thread类的对象\n4. 将Runnable接口的子类对象作为参数传递给Thread类的构造函数。\n5. 调用Thread类的start方法开启线程。\n\n```java\npackage cn.clboy;\n\npublic class Main {\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        //第二种方式，实现Runnable接口\n        callSecond();\n        \n        for (int i = 0; i < 280; i++) {\n            System.out.println(\"偷瞄老师\");\n        }\n        \n    }\n    \n    public static void callSecond() {\n        //实现Runnable接口,需要把Runnable接口的实例传给Thread对象调用start方法,开启一个线程\n        new Thread(new Second()).start();\n    }\n\n}\n\n/**\n * 第二种方法实现Runnable接口(应优先考虑使用这种方法，避免单继承的局限性)\n */\nclass Second implements Runnable {\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 280; i++) {\n            System.out.println(\"------偷偷玩手机-------\");\n        }\n    }\n}\n```\n\n## 实现Callable接口\n\n``` java\npackage cn.clboy;\n\nimport java.util.concurrent.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        //第三种方式,实现Callable接口\n        callThird();\n    }\n    \n    public static void callThird() throws ExecutionException, InterruptedException {\n        //1. 创建Callable实例对象\n        Third third = new Third();\n        //2. 创建执行服务\n        ExecutorService service = Executors.newFixedThreadPool(1);\n        //3. 提交执行\n        Future<String> future = service.submit(third);\n\n        for (int i = 0; i < 280; i++) {\n            System.out.println(\"偷瞄老师\");\n        }\n\n        //4. 获取执行结果,执行这一句时主线程就会等待结果返回后才会往下执行\n        String result = future.get();\n        System.out.println(result);\n        //5. 关闭服务\n        service.shutdownNow();\n\n    }\n\n}\n\n/**\n * 第三种方法，实现Callable接口，重写call方法\n * call方法可以有返回值，返回值可以使用泛型指定\n * call方法可以抛出异常\n */\nclass Third implements Callable<String> {\n\n    @Override\n    public String call() throws Exception {\n        for (int i = 0; i < 280; i++) {\n            System.out.println(\"------偷偷玩手机-------\");\n        }\n        return \"******************************线程执行完毕************************************\";\n    }\n}\n\n```\n\n## 继承Thread类原理\n\n我们为什么要继承Thread类，并调用其的start方法才能开启线程呢？\n\n继承Thread类：因为Thread类用来描述线程，具备线程应该有功能。那为什么不直接创建Thread类的对象呢？如下代码：\n\n``` java\nThread t1 = new Thread();\n\nt1.start();\n//这样做没有错，但是该start调用的是Thread类中的run方法，而这个run方法没有做什么事情，更重要的是这个run方法中并没有定义我们需要让线程执行的代码。\n\n```\n\n创建线程的目的是什么？\n\n是为了建立程序单独的执行路径，让多部分代码实现同时执行。也就是说线程创建并执行需要给定线程要执行的任务。\n\n对于之前所讲的主线程，它的任务定义在main函数中。自定义线程需要执行的任务都定义在run方法中。\n\nThread类run方法中的任务并不是我们所需要的，只有重写这个run方法。既然Thread类已经定义了线程任务的编写位置（run方法），那么只要在编写位置（run方法）中定义任务代码即可。所以进行了重写run方法动作。\n\n\n\n## 实现Runnable的原理\n\n为什么需要定一个类去实现Runnable接口呢？继承Thread类和实现Runnable接口有啥区别呢？\n\n实现Runnable接口，避免了继承Thread类的单继承局限性。覆盖Runnable接口中的run方法，将线程任务代码定义到run方法中。\n\n创建Thread类的对象，只有创建Thread类的对象才可以创建线程。线程任务已被封装到Runnable接口的run方法中，而这个run方法所属于Runnable接口的子类对象，所以将这个子类对象作为参数传递给Thread的构造函数，这样，线程对象创建时就可以明确要运行的线程的任务。\n\n## 实现Runnable的好处\n\n第二种方式实现Runnable接口避免了单继承的局限性，所以较为常用。实现Runnable接口的方式，更加的符合面向对象，线程分为两部分，一部分线程对象，一部分线程任务。继承Thread类，线程对象和线程任务耦合在一起。一旦创建Thread类的子类对象，既是线程对象，有又有线程任务。实现runnable接口，将线程任务单独分离出来封装成对象，类型就是Runnable接口类型。Runnable接口对线程对象和线程任务进行解耦。\n\n\n\n## 多线程的内存图解\n\n多线程执行时，到底在内存中是如何运行的呢？\n\n多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。\n\n![img](https://cdn.static.note.zzrfdsn.cn/images/201911020959JVeLM.jpg) \n\n当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。\n\n## 获取线程名称\n\n开启的线程都会有自己的独立运行栈内存，那么这些运行的线程的名字是什么呢？该如何获取呢？既然是线程的名字，按照面向对象的特点，是哪个对象的属性和谁的功能，那么我们就去找那个对象就可以了。查阅Thread类的API文档发现有个方法是获取当前正在运行的线程对象。还有个方法是获取当前线程对象的名称。\n- **Thread.currentThread()** 获取当前线程对象\n- **Thread.currentThread().getName() **获取当前线程对象的名称\n\n主线程的名称：main；自定义的线程：Thread-0，线程多个时，数字顺延。如Thread-1......\n\n可以在创建线程的时候指定名称\n\n| `Thread(Runnable target, String name)`分配一个新的 `Thread`对象。 |\n| ------------------------------------------------------------ |\n| `Thread(String name)`分配一个新的 `Thread`对象。             |\n\n## 线程池\n\n### 线程池概念\n\n线程池，其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。\n\n![线程池](https://cdn.static.note.zzrfdsn.cn/images/201911021006.png)\n\n### 为什么要使用线程池？\n\n在java中，如果每个请求到达就创建一个新线程，开销是相当大的。在实际使用中，创建和销毁线程花费的时间和消耗的系统资源都相当大，甚至可能要比在处理实际的用户请求的时间和资源要多的多。除了创建和销毁线程的开销之外，活动的线程也需要消耗系统资源。如果在一个jvm里创建太多的线程，可能会使系统由于过度消耗内存或“切换过度”而导致系统资源不足。为了防止资源不足，需要采取一些办法来限制任何给定时刻处理的请求数目，尽可能减少创建和销毁线程的次数，特别是一些资源耗费比较大的线程的创建和销毁，尽量利用已有对象来进行服务。\n\n线程池主要用来解决线程生命周期开销问题和资源不足问题。通过对多个任务重复使用线程，线程创建的开销就被分摊到了多个任务上了，而且由于在请求到达时线程已经存在，所以消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使用应用程序响应更快。另外，通过适当的调整线程中的线程数目可以防止出现资源不足的情况。\n\n### 使用线程池方式 --Runnable接口\n\n通常，线程池都是通过线程池工厂创建，再调用线程池中的方法获取线程，再通过线程去执行任务方法。\n\n- <span style=\"color:green\">Executors：线程池创建工厂类</span>\n\n  ```java\n  //返回线程池对象\n  public static ExecutorService newFixedThreadPool(int nThreads)\n  ```\n\n- <span style=\"color:green\">ExecutorService：线程池类</span>\n\n  ```java\n  //获取线程池中的某一个线程对象，并执行\n  Future<T> submit(Runnable task)\n  ```\n\n- <span style=\"color:green\">Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用</span>\n\n- <span style=\"color:green\">使用线程池中线程对象的步骤：</span>\n\n  - 创建线程池对象\n  - 创建Runnable接口子类对象\n  - 提交Runnable接口子类对象\n  - 关闭线程池\n\n  ``` java\n  package cn.clboy.pool;\n  \n  import java.util.concurrent.ExecutorService;\n  import java.util.concurrent.Executors;\n  \n  /**\n   * @Author cloudlandboy\n   * @Since 1.0.0\n   */\n  \n  public class Test {\n  \n      public static void main(String[] args) throws InterruptedException {\n          //调用工厂类的静态方法，创建线程池对象,返回线程池对象，多态,返回的是接口类型，实例是ThreadPoolExecutor\n          ExecutorService service = Executors.newFixedThreadPool(2);\n  \n          //创建Runnable对象,使用匿名内部类\n          Runnable task = () -> System.out.println(Thread.currentThread().getName() + \"-->running\");\n  \n          //调用接口实现类中的submit方法提交线程任务,参数是Runnable类型\n          service.submit(task);\n          service.submit(task);\n          service.submit(task);\n  \n          //销毁线程池\n          Thread.sleep(1000);\n          service.shutdown();\n          System.out.println(service.isShutdown());\n  \n      }\n  }\n  ```\n  \n\n### 使用线程池方式 --Callable接口([👆](#实现callable接口))","tags":["java"],"categories":["java"]},{"title":"线程的生命周期","url":"/2020/05/23/java/thread/003/","content":"\n\n# 线程的生命周期\n\n[TOC]\n\n##  线程状态\n\n一个线程对象在它的生命周期内，需要经历5个状态。\n\n- **新生状态(New)**\n\n​      用new关键字建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态。\n\n- **就绪状态(Runnable)**\n\n​      处于就绪状态的线程已经具备了运行条件，但是还没有被分配到CPU，处于“线程就绪队列”，等待系统为其分配CPU。就绪状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会进入执行状态。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。有4中原因会导致线程进入就绪状态：\n\n​      1. 新建线程：调用start()方法，进入就绪状态;\n\n​      2. 阻塞线程：阻塞解除，进入就绪状态;\n\n​      3. 运行线程：调用yield()方法，直接进入就绪状态;\n\n​      4. 运行线程：JVM将CPU资源从本线程切换到其他线程。\n\n- **运行状态(Running)**\n\n​      在运行状态的线程执行自己run方法中的代码，直到调用其他方法而终止或等待某资源而阻塞或完成任务而死亡。如果在给定的时间片内没有执行结束，就会被系统给换下来回到就绪状态。也可能由于某些“导致阻塞的事件”而进入阻塞状态。\n\n- **阻塞状态(Blocked)**\n\n​      阻塞指的是暂停一个线程的执行以等待某个条件发生(如某资源就绪)。有4种原因会导致阻塞：\n\n​      1. 执行sleep(int millsecond)方法，使当前线程休眠，进入阻塞状态。当指定的时间到了后，线程进入就绪状态。\n\n​      2. 执行wait()方法，使当前线程进入阻塞状态。当使用nofity()方法唤醒这个线程后，它进入就绪状态。\n\n​      3. 线程运行时，某个操作进入阻塞状态，比如执行IO流操作(read()/write()方法本身就是阻塞的方法)。只有当引起该操作阻塞的原因消失后，线程进入就绪状态。\n\n​      4. join()线程联合: 当某个线程等待另一个线程执行结束后，才能继续执行时，使用join()方法。\n\n- **死亡状态(Terminated)**\n\n​      死亡状态是线程生命周期中的最后一个阶段。线程死亡的原因有两个。一个是正常运行的线程完成了它run()方法内的全部工作; 另一个是线程被强制终止，如通过执行stop()或destroy()方法来终止一个线程(注：stop()/destroy()方法已经被JDK废弃，不推荐使用)。\n\n​      当一个线程进入死亡状态以后，就不能再回到其它状态了\n\n![线程生命周期](https://cdn.static.note.zzrfdsn.cn/images/1495787690411518.png \"线程的生命周期\")\n\n\n\n### 暂停线程\n\n​      暂停线程执行常用的方法有sleep()和yield()方法，这两个方法的区别是：\n\n​      1. sleep()方法：可以让正在运行的线程进入阻塞状态，直到休眠时间满了，进入就绪状态。\n\n​      2. yield()方法：可以让正在运行的线程直接进入就绪状态，让出CPU的使用权。\n\n\n\n###  Yield方法\n\n``` java\npackage cn.clboy.status;\n\n/**\n * @Author cloudlandboy\n * @Since 1.0.0\n * @Describe 让出线程，让CPU重新调度，但有可能CPU还会调度到自己\n */\n\npublic class YieldThread implements Runnable {\n\n    @Override\n    public void run() {\n        String name = Thread.currentThread().getName();\n        System.out.println(name + \"--> 被调度\");\n        //让出，请CPU重新选择\n        Thread.yield();\n        System.out.println(name + \"  。。。。。。。。。。。。。。。。。\");\n        System.out.println(name + \"--> 执行完毕\");\n\n    }\n}\n\nclass YieldThreadTest {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        System.out.println(\"main start\");\n\n        new Thread(new YieldThread(), \"慈善家-123\").start();\n        new Thread(new YieldThread(), \"慈善家-987\").start();\n\n        System.out.println(\"main stop\");\n    }\n}\n```\n\n\n\n### Join方法\n\n​\t线程A在运行期间，可以调用线程B的join()方法，让线程B和线程A联合。这样，线程A就必须等待线程B执行完毕后，才能继续执行。如下面示例中，“爸爸线程”要抽烟，于是联合了“儿子线程”去买烟，必须等待“儿子线程”买烟完毕，“爸爸线程”才能继续抽烟。\n\n``` java\npackage cn.clboy.status;\n\n/**\n * @Author cloudlandboy\n * @Since 1.0.0\n * @Describe 插队，等待我执行完毕\n */\n\npublic class JoinThread {\n    public static void main(String[] args) {\n        new Thread(new Father()).start();\n    }\n}\n\nclass Father implements Runnable {\n\n    @Override\n    public void run() {\n        System.out.println(\"爸爸想要抽烟....让儿子去买烟\");\n        Thread sonThread = new Thread(new Son());\n        sonThread.start();\n        try {\n            //等待son买烟回来\n            sonThread.join();\n        } catch (InterruptedException e) {\n            System.out.println(\"半天还没回来，这小子走丢了\");\n        }\n        System.out.println(\"接过儿子买回的烟，并把儿子打了一顿\");\n\n    }\n}\n\nclass Son implements Runnable {\n\n    @Override\n    public void run() {\n        System.out.println(\"接过爸爸的钱\");\n        System.out.println(\"走到商店发现旁边新开了家游戏厅！于是乎走了进去完了10分钟\");\n        for (int i = 1; i < 11; i++) {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            System.out.println(i + \"分钟过去了\");\n        }\n\n        System.out.println(\"想起是来给爸爸买烟的，感觉跑到商店买烟\");\n        System.out.println(\".............\");\n        System.out.println(\"回到家把烟交个爸爸\");\n    }\n}\n```\n\n\n\n### 自定义Stop方法\n\n​\t终止线程我们一般不使用JDK提供的stop()/destroy()方法(它们本身也被JDK废弃了)。通常的做法是提供一个boolean型的终止变量，当这个变量置为false，则终止线程的运行。\n\n``` java\npackage cn.clboy.status;\n\n/**\n * @Author cloudlandboy\n * @Since 1.0.0\n * @Describe 停止线程\n */\n\npublic class StopThread implements Runnable {\n\n    /**\n     * 定义标识位\n     */\n    private boolean running = true;\n\n    @Override\n    public void run() {\n        int i = 0;\n        while (running) {\n            try {\n                Thread.sleep(200);\n                System.out.println(i++);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        System.out.println(\"************任务结束**************\");\n    }\n\n    /**\n     * 提供停止线程的方法\n     */\n\n    public void terminate() {\n        this.running = false;\n    }\n}\n\nclass StopThreadTest {\n    public static void main(String[] args) throws InterruptedException {\n\n        //开始执行线程\n        StopThread stopThread = new StopThread();\n        new Thread(stopThread).start();\n\n        //5s后停止线程\n        Thread.sleep(5000);\n        stopThread.terminate();\n    }\n}\n```\n\n\n\n\n\n## 获取线程的状态\n\n线程状态。一个线程可以有以下规定：\n\n1. ==NEW==：线程尚未开始(new出来后的状态)。\n2. ==RUNNABLE==：运行中(调用start后被cpu调度到)。\n3. ==BLOCKED==：线程阻塞等待监控锁(等待其他线程释放锁)\n4. ==WAITING==：处于这种状态的线程被无限期地等待另一个线程来执行特定的动作。（其他线程调用join）\n5. ==TIMED_WAITING==：处于这种状态的线程正在等待另一个线程上执行一个动作指定的等待时间。（sleep）\n6. ==TERMINATED==：处于这种状态的线程退出。(线程执行完毕)\n\n一个线程可以在一个给定的时间点上只有一个状态。这些状态是不反映任何操作系统线程状态的虚拟机状态。\n\n从1.5版本开始\n\n``` java\npackage cn.clboy.status;\n\n/\n * @Author cloudlandboy\n * @Since 1.0.0\n * @Describe 查看线程当前状态\n * 线程状态。一个线程可以有以下规定：\n * NEW：线程尚未开始(new出来后的状态)。\n * <p>\n * RUNNABLE：运行中(调用start后被cpu调度到)。\n * <p>\n * BLOCKED\n * 线程阻塞等待监控锁在这个国家。\n * WAITING(A线程中调用B线程的join后，A线程就是WAITING状态)\n * 处于这种状态的线程被无限期地等待另一个线程来执行特定的动作。\n * TIMED_WAITING（sleep）\n * 处于这种状态的线程正在等待另一个线程上执行一个动作指定的等待时间。\n * <p>\n * TERMINATED 处于这种状态的线程退出。(线程执行完毕)\n */\n\npublic class ShowThreadState {\n    static Thread mainThread;\n\n    public static void main(String[] args) throws InterruptedException {\n        mainThread = Thread.currentThread();\n\n        Thread thread = new Thread(new ThreadState());\n        System.out.println(thread.getState());\n        thread.start();\n\n        int i = 1;\n        while (true) {\n            i++;\n            Thread.State state = thread.getState();\n            System.out.println(state);\n            if (state.name().equals(\"TERMINATED\")) {\n                break;\n            }\n            //每过200毫秒检查一次线程状态\n            Thread.sleep(200);\n            if (i == 5) {\n                System.out.println(\"thread使用join\");\n                thread.join();\n            }\n        }\n    }\n}\n\nclass ThreadState implements Runnable {\n\n    @Override\n    public void run() {\n        System.out.println(\"start-->\");\n        //睡2秒\n        try {\n            Thread.sleep(2000);\n            //睡两秒后\n            System.out.println(\"sleep结束\");\n            for (int i = 0; i < 10; i++) {\n                System.out.println(\"main线程状态：\" + ShowThreadState.mainThread.getState());\n                Thread.sleep(100);\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"<--end\");\n    }\n}\n```\n\n## 线程的优先级\n\n``` java\npackage cn.clboy.priority;\n\n/**\n * @Author cloudlandboy\n * @Since 1.0.0\n * @Describe 线程的优先级\n * MAX_PRIORITY 10 （最大值，大于此值会报错）\n * MIN_PRIORITY 1\n * NORM_PRIORITY 5\n * 只是概率，不是绝对\n */\npublic class ThreadPriority {\n\n    public static void main(String[] args) {\n        System.out.println(\"main：\" + Thread.currentThread().getPriority());\n\n        PriorityTest priorityTest = new PriorityTest();\n\n        Thread p_min1 = new Thread(priorityTest, \"p_min1\");\n        Thread p_min2 = new Thread(priorityTest, \"p_min2\");\n        Thread p3 = new Thread(priorityTest, \"p3\");\n        Thread p_min4 = new Thread(priorityTest, \"p_min4\");\n        Thread p_max5 = new Thread(priorityTest, \"p_max5\");\n        Thread p_max6 = new Thread(priorityTest, \"p_max6\");\n\n        //设置优先级\n        p_min1.setPriority(Thread.MIN_PRIORITY);\n        p_min2.setPriority(Thread.MIN_PRIORITY);\n        p3.setPriority(Thread.NORM_PRIORITY);\n        p_min4.setPriority(Thread.MIN_PRIORITY);\n        p_max5.setPriority(Thread.MAX_PRIORITY);\n        p_max6.setPriority(Thread.MAX_PRIORITY);\n\n        //开启线程\n        p_min1.start();\n        p_min2.start();\n        p3.start();\n        p_min4.start();\n        p_max5.start();\n        p_max6.start();\n    }\n}\n\nclass PriorityTest implements Runnable {\n\n    @Override\n    public void run() {\n        String name = Thread.currentThread().getName();\n        System.out.println(name + \"--> running\");\n    }\n\n}\n```\n\n\n\n## 守护线程\n\n``` java\npackage cn.clboy.category;\n\n/**\n * @Author cloudlandboy\n * @Since 1.0.0\n * @Describe 守护进程\n * 守护进程就是默默地在后台服务，就好比上帝在背后默默保护我们，人类存在他就存在，人类消失他就消失\n * jvm虚拟机在所有用户线程都停止后才停止，但不会等守护线程，及时守护线程没有运行完毕，也会停止\n */\n\npublic class DaemonThread {\n    public static void main(String[] args) {\n        Thread god = new Thread(new God());\n        Thread human = new Thread(new Human());\n\n        //将god设置为守护线程\n        god.setDaemon(true);\n\n        god.start();\n        human.start();\n    }\n}\n\nclass God implements Runnable {\n\n    @Override\n    public void run() {\n        //死循环\n        while (true) {\n            System.out.println(\"保佑着人类.....\");\n            try {\n                Thread.sleep(200);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\nclass Human implements Runnable {\n\n    @Override\n    public void run() {\n        for (int i = 1; i <= 10; i++) {\n            System.out.println(\"人们已经存在\" + i + \"亿个世纪\");\n            try {\n                Thread.sleep(200);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n","tags":["java"],"categories":["java"]},{"title":"线程基本概念","url":"/2020/05/23/java/thread/001/","content":"\n# 线程基本概念\n[TOC]\n\n多线程是Java语言的重要特性，大量应用于网络编程、服务器端程序的开发，最常见的UI界面底层原理、操作系统底层原理都大量使用了多线程。\n\n学习多线程之前，我们先要了解几个关于多线程有关的概念。\n\n进程：进程指正在运行的程序。确切的来说，当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。\n\n![进程图](https://cdn.static.note.zzrfdsn.cn/images/201911020914.png)\n\n线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。\n\n简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程\n\n![img](https://cdn.static.note.zzrfdsn.cn/images/201911020919kfX9xO.jpg) \n\n \n\n什么是多线程呢？即就是一个程序中有多个线程在同时执行。\n\n通过下图来区别单线程程序与多线程程序的不同：\n\n- 单线程程序：即，若有多个任务只能依次执行。当上一个任务执行结束后，下一个任务开始执行。如，去网吧上网，网吧只能让一个人上网，当这个人下机后，下一个人才能上网。\n- 多线程程序：即，若有多个任务可以同时执行。如，去网吧上网，网吧能够让多个人同时上网。\n\n![img](https://cdn.static.note.zzrfdsn.cn/images/2019110209196LA5yt.jpg) \n\n## 程序运行原理\n\n1. 分时调度\n\n所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。\n\n2. 抢占式调度\n\n优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。\n\n![img](https://cdn.static.note.zzrfdsn.cn/images/201911020919MqL3z8.jpg) \n\n## 抢占式调度详解\n\n大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。\n\n![img](https://cdn.static.note.zzrfdsn.cn/images/201911020919uSPUkV.jpg) \n\n实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。\n\n其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。\n\n##  主线程\n\n回想我们以前学习中写过的代码，当我们在dos命令行中输入java空格类名回车后，启动JVM，并且加载对应的class文件。虚拟机并会从main方法开始执行我们的程序代码，一直把main方法的代码执行结束。如果在执行过程遇到循环时间比较长的代码，那么在循环之后的其他代码是不会被马上执行的。如下代码演示：\n\n```java\n    class Demo {\n\n        String name;\n\n        Demo(String name) {\n\n            this.name = name;\n\n        }\n\n        void show() {\n\n            for (int i = 1; i <= 10000; i++) {\n\n                System.out.println(\"name=\" + name + \",i=\" + i);\n\n            }\n\n        }\n\n    }\n\n\n    class ThreadDemo {\n\n        public static void main(String[] args) {\n\n            Demo d = new Demo(\"小强\");\n\n            Demo d2 = new Demo(\"旺财\");\n\n            d.show();\n\n            d2.show();\n\n            System.out.println(\"Hello World!\");\n\n        }\n\n    }\n```\n\n\n\n \n\n若在上述代码中show方法中的循环执行次数很多，这时在d.show();下面的代码是不会马上执行的，并且在dos窗口会看到不停的输出name=小强,i=值，这样的语句。为什么会这样呢？\n\n原因是：jvm启动后，必然有一个执行路径(线程)从main方法开始的，一直执行到main方法结束，这个线程在java中称之为主线程。当程序的主线程执行时，如果遇到了循环而导致程序在指定位置停留时间过长，则无法马上执行下面的程序，需要等待循环结束后能够执行。\n\n那么，能否实现一个主线程负责执行其中一个循环，再由另一个线程负责其他代码的执行，最终实现多部分代码同时执行的效果？\n\n能够实现同时执行，通过Java中的多线程技术来解决该问题。\n\n## 多线程经典案例\n\n### 购买火车票\n\n``` java\npackage cn.clboy;\n\n/**\n * @Author cloudlandboy\n * @Since 1.0.0\n */\n\npublic class BuyTicket implements Runnable {\n\n    /**\n     * 存放票数\n     */\n    private int number = 100;\n\n    @Override\n    public void run() {\n        //获取当前线程的名称\n        String name = Thread.currentThread().getName();\n        while (true) {\n            //没有票了，停止\n            if (number < 1) {\n                return;\n            }\n            //模拟网络延迟，可能会发生线程安全问题\n            //（比如还剩一张票时，张三的网络还在等待，李四点击购买后1-1=0，没票了，然后张三的线程往下执行，0-1）\n            try {\n                Thread.sleep(200);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            System.out.println(name + \"-->\" + (number--));\n        }\n    }\n\n}\n\nclass App12306 {\n\n    public static void main(String[] args) {\n        BuyTicket buyTicket = new BuyTicket();\n        //多个线程操作同一个对象(一份资源，多个代理)\n        new Thread(buyTicket, \"张三\").start();\n        new Thread(buyTicket, \"李四\").start();\n        new Thread(buyTicket, \"王二\").start();\n    }\n}\n```\n\n\n\n### 龟兔赛跑\n\n``` java\npackage cn.clboy;\n\n/**\n * @Author cloudlandboy\n * @Since 1.0.0\n * @Describe 模拟龟兔赛跑，用的是同一个跑道类\n */\n\npublic class Runway implements Runnable {\n\n    private String winner;\n\n    @Override\n    public void run() {\n        //获取选手(线程)名称\n        String name = Thread.currentThread().getName();\n        for (int i = 0; i < 100; i++) {\n\n            try {\n                //小白兔比较懒，爱睡觉\n                if (name.equals(\"小白兔\")) {\n                    Thread.sleep(120);\n                } else {\n                    //老乌龟只是跑的有点慢\n                    Thread.sleep(60);\n                }\n\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (winner == null) {\n                System.out.println(name + \" --> \" + i);\n            } else {\n                //胜利者已经产生\n                System.out.println(\"胜利者：--> \" + winner);\n                return;\n            }\n        }\n        //100步跑完\n        winner = name;\n    }\n}\n\nclass Action {\n    public static void main(String[] args) {\n        //创建跑道\n        Runway runway = new Runway();\n        //兔子\n        new Thread(runway, \"小白兔\").start();\n        //乌龟\n        new Thread(runway, \"老乌龟\").start();\n    }\n}\n```\n\n\n\n### 多线程下载\n\n``` java\npackage cn.clboy;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\n/**\n * @Author cloudlandboy\n * @Since 1.0.0\n */\n\npublic class Tdown extends Thread {\n\n    private String url;\n    private String savePath;\n\n    public Tdown(String url, String savePath) {\n        this.url = url;\n        this.savePath = savePath;\n    }\n\n    private void download() {\n        try {\n            System.out.println(\"开始下载：\" + url);\n            FileUtils.copyURLToFile(new URL(url), new File(savePath));\n        } catch (IOException e) {\n            System.err.println(\"下载 \" + url + \" 失败！\");\n        }\n    }\n\n    @Override\n    public void run() {\n        this.download();\n    }\n}\n```\n\n``` java\npackage cn.clboy;\n\n/**\n * @Author cloudlandboy\n * @Since 1.0.0\n */\n\npublic class DownloadTest {\n\n    /**\n     * 多运行几次，就会发现下载顺序与启动顺序是不一致的\n     *\n     * @param args\n     */\n    public static void main(String[] args) {\n        new Tdown(\"http://ww1.sinaimg.cn/bmiddle/9150e4e5gy1g8h2e495yxj206o06oq2z.jpg\", \"download/001.jpg\").start();\n        new Tdown(\"http://ww4.sinaimg.cn/bmiddle/9150e4e5gy1g8h2cw463wj20cs0dcjro.jpg\", \"download/002.jpg\").start();\n        new Tdown(\"http://ww3.sinaimg.cn/bmiddle/9150e4e5gy1g8h2ckcsfnj20j60jp0tk.jpg\", \"download/003.jpg\").start();\n    }\n}\n```\n\n","tags":["java"],"categories":["java"]},{"title":"线程安全","url":"/2020/05/23/java/thread/004/","content":"\n# 线程安全\n\n[TOC]\n\n​\t当多个线程访问同一个数据时，容易出现线程安全问题。需要让线程同步，保证数\n据安全，就像前面的经典案例中多个人同时购买火车票可能会出现相同的票数，票数为负数的情况\n\n## 线程同步\n\n​\t现实生活中，我们会遇到“同一个资源，多个人都想使用”的问题。 比如：教室里，只有一台电脑，多个人都想使用。天然的解决办法就是，在电脑旁边，大家排队。前一人使用完后，后一人再使用。\n\n### 线程同步的概念\n\n> ​\t处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象。 这时候，我们就需要用到“线程同步”。 线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面的线程使用完毕后，下一个线程再使用。\n\n### 线程同步的方式\n\n  由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突的问题。Java语言提供了专门机制以解决这种冲突，有效避免了同一个数据对象被多个线程同时访问造成的这种问题。\n\n​      由于我们可以通过 private 关键字来保证数据对象只能被方法访问，所以我们只需针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法：\n\n- 方式1：同步方法\n\n  ``` java\n  /**\n  * 通过在方法声明中加入 synchronized关键字来声明\n  */\n  public  synchronized  void accessVal(int newVal);\n  ```\n\n  ​\tsynchronized 方法控制对“对象的类成员变量”的访问：每个对象对应一把锁，每个 synchronized 方法都必须获得调用该方法的对象的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。\n\n- 方式2：同步代码块\n\n  ​\tsynchronized 方法的缺陷：若将一个大的方法声明为synchronized 将会大大影响效率。\n\n  ``` java\n  //Java 为我们提供了更好的解决办法，那就是 synchronized 块。 块可以让我们精确地控制到具体的“成员变量”，缩小同步的范围，提高效率。\n  synchronized(syncObject)\n  　  { \n  　　 //代码 \n  　  }\n  ```\n\n  \n\n\n\n### 同步方法\n\n1. 多线程操作同一个对象(未使用线程同步)\n\n   ``` java\n   package cn.clboy.sync.trainticket;\n   \n   /**\n    * @Author cloudlandboy\n    * @Since 1.0.0\n    * @Describe 模拟购买火车票\n    */\n   \n   public class App12306 implements Runnable {\n   \n       /**\n        * 票数\n        */\n       private int total;\n   \n       public App12306(int total) {\n           this.total = total;\n       }\n   \n       @Override\n       public void run() {\n           try {\n               boolean running = true;\n               while (running) {\n                   running = issue();\n               }\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n       }\n   \n       /**\n        * 出票\n        *\n        * @return\n        */\n       public boolean issue() throws InterruptedException {\n           //没票了\n           if (total < 1) {\n               return false;\n           }\n           //模拟网络延迟\n           Thread.sleep(20);\n           System.out.println(Thread.currentThread().getName() + \"--出票成功-->票号：\" + total--);\n   \n           return true;\n       }\n   }\n   \n   class Main {\n   \n       public static void main(String[] args) {\n           //12306平台\n           App12306 app12306 = new App12306(10);\n   \n           //模拟三个黄牛抢票,这里就会发生拿到0和负数还有取到相同票数的情况\n           new Thread(app12306, \"牛一\").start();\n           new Thread(app12306, \"牛二\").start();\n           new Thread(app12306, \"牛三\").start();\n       }\n   }\n   ```\n\n2. 多线程操作同一个对象(使用线程同步)\n\n   ``` java\n   package cn.clboy.sync.trainticket;\n   \n   /**\n    * @Author cloudlandboy\n    * @Since 1.0.0\n    * @Describe 模拟购买火车票，同步方法\n    */\n   \n   public class Sync1App12306 implements Runnable {\n   \n       /**\n        * 票数\n        */\n       private int total;\n   \n       public Sync1App12306(int total) {\n           this.total = total;\n       }\n   \n       @Override\n       public void run() {\n           try {\n               boolean has = true;\n               while (has) {\n                   has = issue();\n               }\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n       }\n   \n       /**\n        * 出票\n        * 这里加上同步锁,等待前一次出票完毕才能继续\n        *\n        * @return\n        */\n       public synchronized boolean issue() throws InterruptedException {\n           //没票了\n           if (total < 1) {\n               return false;\n           }\n           //模拟网络延迟\n           Thread.sleep(20);\n           System.out.println(Thread.currentThread().getName() + \"--出票成功-->票号：\" + total--);\n           return true;\n       }\n   }\n   \n   class Sync1Main {\n   \n       public static void main(String[] args) {\n           //12306平台\n           Sync1App12306 sync1App12306 = new Sync1App12306(10);\n   \n           //模拟三个黄牛抢票\n           new Thread(sync1App12306, \"牛一\").start();\n           new Thread(sync1App12306, \"牛二\").start();\n           new Thread(sync1App12306, \"牛三\").start();\n       }\n   }\n   ```\n\n   \n\n### 同步块\n\n1. 未同步情况下\n\n   ``` java\n   package cn.clboy.sync.bank;\n   \n   /**\n    * @Author cloudlandboy\n    * @Since 1.0.0\n    * @Describe 模拟账上银行\n    */\n   \n   public class HandBank implements Runnable {\n   \n       /**\n        * 登录的账户\n        */\n       private Account account;\n   \n       /**\n        * 要取多少钱\n        */\n       private int takeMoney;\n   \n       public HandBank(Account account, int takeMoney) {\n           this.account = account;\n           this.takeMoney = takeMoney;\n       }\n   \n       @Override\n       public void run() {\n   \n           //账户余额减去要取的钱计算出取出后的余额\n   //        int total = account.getTotal() - takeMoney;应该实时计算，不应该先计算出来\n           if (account.getTotal() - takeMoney < 0) {\n               System.out.println(\"对不起\" + Thread.currentThread().getName() + \"你的账户余额为：\" + account.getTotal() + \"不足本次消费\");\n               return;\n           }\n   \n           try {\n               //网络延迟\n               Thread.sleep(200);\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n   \n           account.setTotal(account.getTotal() - takeMoney);\n           System.out.println(Thread.currentThread().getName() + \"从账户：\" + account.getId() + \"中取出-->\" + takeMoney);\n           System.out.println(Thread.currentThread().getName() + \"取出后剩余：\" + account.getTotal());\n   \n       }\n   }\n   \n   /**\n    * 账户\n    */\n   class Account {\n       /**\n        * 余额\n        */\n       private int total;\n   \n       /**\n        * 卡号\n        */\n       private String id;\n   \n       public Account(int total, String id) {\n           this.total = total;\n           this.id = id;\n       }\n   \n       public int getTotal() {\n           return total;\n       }\n   \n       public void setTotal(int total) {\n           this.total = total;\n       }\n   \n       public String getId() {\n           return id;\n       }\n   \n       public void setId(String id) {\n           this.id = id;\n       }\n   }\n   \n   class Main {\n       public static void main(String[] args) {\n           //开户,存200元,卡号为ABC2019\n           Account account = new Account(200, \"ABC2019\");\n   \n           //自己在准备去和朋友喝酒，取50块钱\n           HandBank handBank_myself = new HandBank(account, 50);\n           new Thread(handBank_myself, \"myself\").start();\n   \n           //同时老婆在家逛淘宝买了条裙子，网银支付，下单199,\n           HandBank handBank_wife = new HandBank(account, 199);\n           new Thread(handBank_wife, \"wife\").start();\n       }\n   }\n   ```\n\n2. 试试同步方法（下面的Account还是使用的上面的Account，因为在同一包下，为了方便，就不用再定义了）\n\n   ``` java\n   package cn.clboy.sync.bank;\n   \n   /**\n    * @Author cloudlandboy\n    * @Since 1.0.0\n    * @Describe 模拟账上银行\n    */\n   \n   public class TestSyncHandBank implements Runnable {\n   \n       /**\n        * 登录的账户\n        */\n       private Account account;\n   \n       /**\n        * 要取多少钱\n        */\n       private int takeMoney;\n   \n       public TestSyncHandBank(Account account, int takeMoney) {\n           this.account = account;\n           this.takeMoney = takeMoney;\n       }\n   \n       @Override\n       public void run() {\n           take();\n       }\n   \n       /**\n        * 加入方法同步,发现无效\n        * 原因：这里锁方法锁的是this，这里的this是TestSyncHandBank也就是账上银行，两个人又不是用的同一个账上银行，\n        * 我们操作的是同一个账户，是不是应该锁account账户\n        */\n       public synchronized void take() {\n           //账户余额减去要取的钱计算出取出后的余额\n   //        int total = account.getTotal() - takeMoney;应该实时计算，不应该先计算出来\n           if (account.getTotal() - takeMoney < 0) {\n               System.out.println(\"对不起\" + Thread.currentThread().getName() + \"你的账户余额为：\" + account.getTotal() + \"不足本次消费\");\n               return;\n           }\n   \n           try {\n               //网络延迟\n               Thread.sleep(200);\n           } catch (InterruptedException e) {\n               e.printStackTrace();\n           }\n   \n           account.setTotal(account.getTotal() - takeMoney);\n           System.out.println(Thread.currentThread().getName() + \"从账户：\" + account.getId() + \"中取出-->\" + takeMoney);\n           System.out.println(Thread.currentThread().getName() + \"取出后剩余：\" + account.getTotal());\n       }\n   }\n   \n   class TestSyncMain {\n       public static void main(String[] args) {\n           //开户,存200元,卡号为ABC2019\n           Account account = new Account(200, \"ABC2019\");\n   \n   \n           //自己在准备去和朋友喝酒，取50块钱\n           TestSyncHandBank handBank_myself = new TestSyncHandBank(account, 50);\n           new Thread(handBank_myself, \"myself\").start();\n   \n           //同时老婆在家逛淘宝买了条裙子，网银支付，下单199,\n           TestSyncHandBank handBank_wife = new TestSyncHandBank(account, 199);\n           new Thread(handBank_wife, \"wife\").start();\n       }\n   }\n   ```\n\n3. 同步块\n\n   ``` java\n   package cn.clboy.sync.bank;\n   \n   /**\n    * @Author cloudlandboy\n    * @Since 1.0.0\n    * @Describe 模拟账上银行，同步块\n    */\n   \n   public class SyncHandBank implements Runnable {\n   \n       /**\n        * 登录的账户\n        */\n       private Account account;\n   \n       /**\n        * 要取多少钱\n        */\n       private int takeMoney;\n   \n       public SyncHandBank(Account account, int takeMoney) {\n           this.account = account;\n           this.takeMoney = takeMoney;\n       }\n   \n       @Override\n       public void run() {\n           take();\n       }\n   \n   \n       public void take() {\n   \n           //双重检测，如果账户余额已经不足，就不需要再同步等待，直接返回，提高性能\n           if (account.getTotal() - takeMoney < 0) {\n               System.out.println(\"对不起\" + Thread.currentThread().getName() + \"你的账户余额为：\" + account.getTotal() + \"不足本次消费-->\" + takeMoney);\n               System.out.println(\"-----------------------------------------------\");\n               return;\n           }\n   \n   \n           //给accont,账户上锁\n           synchronized (account) {\n               //账户余额减去要取的钱计算出取出后的余额\n   //        int total = account.getTotal() - takeMoney;应该实时计算，不应该先计算出来\n               if (account.getTotal() - takeMoney < 0) {\n                   System.out.println(\"对不起\" + Thread.currentThread().getName() + \"你的账户余额为：\" + account.getTotal() + \"不足本次消费-->\" + takeMoney);\n                   return;\n               }\n   \n               try {\n                   //网络延迟\n                   Thread.sleep(20);\n               } catch (InterruptedException e) {\n                   e.printStackTrace();\n               }\n   \n               account.setTotal(account.getTotal() - takeMoney);\n               System.out.println(Thread.currentThread().getName() + \"从账户：\" + account.getId() + \"中取出-->\" + takeMoney);\n               System.out.println(Thread.currentThread().getName() + \"取出后剩余：\" + account.getTotal());\n           }\n       }\n   }\n   \n   class SyncMain {\n       public static void main(String[] args) throws InterruptedException {\n           //开户,存200元,卡号为ABC2019\n           Account account = new Account(200, \"ABC2019\");\n   \n   \n           //自己在准备去和朋友喝酒，取50块钱\n           SyncHandBank handBank_myself = new SyncHandBank(account, 50);\n           new Thread(handBank_myself, \"myself\").start();\n   \n           //同时老婆在家逛淘宝买了条裙子，网银支付，下单199,\n           SyncHandBank handBank_wife = new SyncHandBank(account, 199);\n           new Thread(handBank_wife, \"wife\").start();\n   \n           Thread.sleep(1000);\n           //儿子又要买价值 159元女主播迦娜皮肤\n           SyncHandBank handBank_son = new SyncHandBank(account, 159);\n           new Thread(handBank_son, \"son\").start();\n       }\n   }\n   ```\n\n\n\n### 集合的同步\n\n``` java\npackage cn.clboy.sync.collection;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\n/**\n * @Author cloudlandboy\n * @Since 1.0.0\n * @Describe 测试集合容器的线程问题\n */\n\npublic class Collection {\n\n    public static void main(String[] args) throws Exception {\n        testList();\n        //testSyncList();\n        //testCopyOnWriteArrayList();\n    }\n\n    /**\n     * ArrayList不是线程安全的\n     *\n     * @throws Exception\n     */\n    public static void testList() throws Exception {\n\n        List<String> list = new ArrayList();\n\n        for (int i = 0; i < 1000; i++) {\n            //每次循环创建一个线程\n            new Thread(() -> {\n                list.add(Thread.currentThread().getName());\n            }).start();\n        }\n\n        //等待5秒，让所有线程执行完毕\n        Thread.sleep(5000);\n        //理论上应该是1000，但是，请看结果,肯定有元素放到了相同的索引处\n        System.out.println(list.size());\n    }\n\n    /**\n     * ArrayList使用同步锁\n     *\n     * @throws Exception\n     */\n    public static void testSyncList() throws Exception {\n\n        List<String> list = new ArrayList();\n\n        for (int i = 0; i < 1000; i++) {\n            //每次循环创建一个线程\n            new Thread(() -> {\n                synchronized (list) {\n                    list.add(Thread.currentThread().getName());\n                }\n            }).start();\n        }\n\n        //等待5秒，让所有线程执行完毕\n        Thread.sleep(5000);\n        //理论上应该是1000，但是，请看结果,肯定有元素放到了相同的索引处\n        System.out.println(list.size());\n    }\n\n    /**\n     * 线程安全的集合\n     *\n     * @throws Exception\n     */\n    public static void testCopyOnWriteArrayList() throws Exception {\n\n        List<String> list = new CopyOnWriteArrayList<>();\n\n        for (int i = 0; i < 1000; i++) {\n            //每次循环创建一个线程\n            new Thread(() -> {\n                list.add(Thread.currentThread().getName());\n            }).start();\n        }\n\n        //等待5秒，让所有线程执行完毕\n        Thread.sleep(5000);\n        //理论上应该是1000，但是，请看结果,肯定有元素放到了相同的索引处\n        System.out.println(list.size());\n    }\n\n}\n```\n\n\n\n## 死锁\n\n“死锁”指的是：\n\n​      多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能进行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。就好比是卖家想要买家先交钱再交货，买家正好与卖家相反，各自不退让就形成僵局\n\n​\t代码中卖家和买家都在互相等待对方释放资源，才交出自己的东西。这样，两个线程就形成了互相等待，无法继续运行的“死锁状态”。\n\n``` java\npackage cn.clboy.sync;\n\n/**\n * @Author cloudlandboy\n * @Since 1.0.0\n * @Describe 死锁问题\n */\n\npublic class DeadLock {\n\n    public static void main(String[] args) {\n        Goods goods = new Goods();\n        Money money = new Money();\n\n        //卖家\n        Thread seller = new Thread(() -> {\n            synchronized (goods) {\n                System.out.println(\"卖家手里拿着货物，等待对方先交钱...\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n\n//                synchronized (money) {\n//                    System.out.println(\"卖家拿到钱，概不退货(假货)...\");\n//                }\n            }\n            //做人真实一点，先把货物交给人家又能怎样\n            synchronized (money) {\n                System.out.println(\"卖家拿到钱...\");\n            }\n        });\n\n        //买家\n        Thread buyer = new Thread(() -> {\n            synchronized (money) {\n                System.out.println(\"买家手里攥着钱，等待对方先交货...\");\n                try {\n                    Thread.sleep(1500);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n//                synchronized (goods) {\n//                    System.out.println(\"买家拿到货物....\");\n//                }\n            }\n            //先把钱交给他又能咋地\n            synchronized (goods) {\n                System.out.println(\"买家拿到货物....\");\n            }\n\n        });\n\n        seller.start();\n        buyer.start();\n\n    }\n}\n\n/**\n * 货物\n */\nclass Goods {\n\n}\n\n/**\n * 钱\n */\nclass Money {\n\n}\n```\n\n\n\n## Lock接口\n\nJDK1.5后新增功能，与采用synchronized相比，lock可提供多种锁方案，更灵活\n\n- java.util.concurrent.lock 中的 Lock 框架是锁定的一个抽象，它允许把锁定的实现作为 Java 类，而不是作为语言的特性来实现。这就为 Lock 的多种实现留下了空间，各种实现可能有不同的调度算法、性能特性或者锁定语义。\n- ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义， 但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。\n- 注意：如果同步代码有异常，要将unlock()写入finally语句块\n\nLock和synchronized的区别\n\n1. Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁\n2. Lock只有代码块锁，synchronized有代码块锁和方法锁\n3. 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）\n\n``` java\npackage cn.clboy.sync.trainticket;\n\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * @Author cloudlandboy\n * @Since 1.0.0\n * @Describe 模拟购买火车票，使用lock锁\n */\n\npublic class LockApp12306 implements Runnable {\n\n    /**\n     * 票数\n     */\n    private int total;\n\n    /**\n     * 创建锁\n     */\n    private Lock lock=new ReentrantLock();\n\n    public LockApp12306(int total) {\n        this.total = total;\n    }\n\n    @Override\n    public void run() {\n        boolean has = true;\n        while (has) {\n            has = issue();\n        }\n\n    }\n\n    /**\n     * 出票\n     * 这里加上同步锁,等待前一次出票完毕才能继续\n     *\n     * @return\n     */\n    public boolean issue() {\n        //加锁\n        lock.lock();\n        try {\n            //没票了\n            if (total < 1) {\n                return false;\n            }\n            //模拟网络延迟\n            Thread.sleep(20);\n            System.out.println(Thread.currentThread().getName() + \"--出票成功-->票号：\" + total--);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            //释放锁\n            lock.unlock();\n        }\n        return true;\n    }\n}\n\n\nclass LockMain {\n\n    public static void main(String[] args) {\n        //12306平台\n        LockApp12306 lockApp12306 = new LockApp12306(10);\n\n        //模拟三个黄牛抢票\n        new Thread(lockApp12306, \"牛一\").start();\n        new Thread(lockApp12306, \"牛二\").start();\n        new Thread(lockApp12306, \"牛三\").start();\n    }\n}\n```\n\n## 模拟购买电影票\n\n``` java\npackage cn.clboy.sync.demo;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * @Author cloudlandboy\n * @Since 1.0.0\n * @Describe 模拟电影院\n */\n\npublic class Cinema {\n\n    /**\n     * 剩余座位号\n     */\n    private List<Integer> availableSeats;\n\n    /**\n     * 电影院名称\n     */\n    private String name;\n\n    public Cinema(List<Integer> availableSeats, String name) {\n        this.availableSeats = availableSeats;\n        this.name = name;\n    }\n\n    public void take(List<Integer> seats) throws InterruptedException {\n        String userName = Thread.currentThread().getName();\n        System.out.println(userName + \",欢迎光临：\" + this.name + \"\\r\\n出票中...\");\n        //临时变量\n        List<Integer> tempSeat = new ArrayList<>();\n        //将所有可用的座位号集合放到临时变量\n        tempSeat.addAll(availableSeats);\n\n        Thread.sleep(20);\n\n        //将用户选择的座位占用,就是从集合中删除\n        tempSeat.removeAll(seats);\n\n        //开始的剩余票数-购买后的剩余票数==用户要购买的票数\n        //比如用户买之前有10张票(availableSeats)，他要买3张票(seats),如果他要买的这三张票的座位都在\n        //那么用(tempSeat)10-3=7，然后判断(availableSeats)10-(tempSeat)7=(seats)3成立，等于用户要购买的票数，出票\n        //如果其中只有两张是要买的座位，另一个已经被被人买走，10-2=8,10-8=2与用户购买的票不匹配，出票失败\n        if (availableSeats.size() - tempSeat.size() == seats.size()) {\n            //将availableSeats的指向改为修改后的tempSeat\n            availableSeats = tempSeat;\n            System.out.println(userName + \",出票成功！\" + seats);\n        } else {\n            System.out.println(userName + \",出票失败，剩余座位号：\" + availableSeats + \"你要买的座位号为：\" + seats);\n        }\n\n    }\n\n    public List<Integer> getAvailableSeats() {\n        return availableSeats;\n    }\n\n    public void setAvailableSeats(List<Integer> availableSeats) {\n        this.availableSeats = availableSeats;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\n/**\n * 顾客\n */\nclass Customer implements Runnable {\n\n    /**\n     * 去哪个影院看电影\n     */\n    private Cinema cinema;\n\n    /**\n     * 购买的座位号\n     */\n    private List<Integer> seats;\n\n    public Customer(Cinema cinema, List<Integer> seats) {\n        this.cinema = cinema;\n        this.seats = seats;\n    }\n\n    @Override\n    public void run() {\n        try {\n            synchronized (cinema) {\n                cinema.take(seats);\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        //电影院剩余座位号\n        List<Integer> availableSeats = new ArrayList<>();\n        availableSeats.add(1);\n        availableSeats.add(2);\n        availableSeats.add(6);\n        availableSeats.add(7);\n        availableSeats.add(8);\n        availableSeats.add(14);\n        availableSeats.add(33);\n        Cinema cinema = new Cinema(availableSeats, \"云梦电影院\");\n\n        //三个顾客\n        new Thread(new Customer(cinema, Arrays.asList(6, 7, 8)), \"小明\").start();\n\n        new Thread(new Customer(cinema, Arrays.asList(7, 8)), \"小李\").start();\n\n        new Thread(new Customer(cinema, Arrays.asList(2)), \"王二\").start();\n    }\n}\n```\n\n","tags":["java"],"categories":["java"]},{"title":"happenBefore,volitale,dcl","url":"/2020/05/23/java/thread/006/","content":"\n\n# happenBefore,volitale,dcl\n\n## 什么是指令重排\n\n[![img](https://niliv-technology-1252830662.cos.ap-chengdu.myqcloud.com/java/Snipaste_2019-04-29_20-08-01.png)](https://niliv-technology-1252830662.cos.ap-chengdu.myqcloud.com/java/Snipaste_2019-04-29_20-08-01.png)\n\n[![img](https://niliv-technology-1252830662.cos.ap-chengdu.myqcloud.com/java/Snipaste_2019-04-29_20-08-44.png)](https://niliv-technology-1252830662.cos.ap-chengdu.myqcloud.com/java/Snipaste_2019-04-29_20-08-44.png)\n\n```\npublic class HappenBefore {\n\t//变量1\n\tprivate  static int a = 0;\n\t//变量2\n\tprivate static boolean flag = false;\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tfor(int i=0;i<10;i++) {\n\t\t\ta = 0;\n\t\t\tflag = false;\n\t\t\t\n\t\t\t//线程1 更改数据\n\t\t\tThread t1 = new Thread(()->{\n\t\t\t\ta = 1;\n\t\t\t\tflag = true;\n\t\t\t}) ;\n\t\t\t//线程2 读取数据\n\t\t\tThread t2 = new Thread(()->{\n\t\t\t\tif(flag) {\n\t\t\t\t\ta *=1; \n\t\t\t\t}\n\t\t\t\t//指令重排\n\t\t\t\tif(a == 0) {\n\t\t\t\t\tSystem.out.println(\"happen before a->\"+a);\n\t\t\t\t}\n\t\t\t}) ;\n\t\t\t\n\t\t\tt1.start();\n\t\t\tt2.start();\n\t\t\t\n\t\t\t//合并线程\n\t\t\tt1.join();\n\t\t\tt2.join();\n\t\t}\n\t}\n\n}\n```\n\n# volatile\n\n[![img](https://niliv-technology-1252830662.cos.ap-chengdu.myqcloud.com/java/Snipaste_2019-04-29_20-16-46.png)](https://niliv-technology-1252830662.cos.ap-chengdu.myqcloud.com/java/Snipaste_2019-04-29_20-16-46.png)\n\n```\n/**\n * volatile用于保证数据的同步，也就是可见性\n * \n * @author 裴新 \n *\n */\npublic class VolatileTest {\n\tprivate volatile static int num = 0;\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tnew Thread(()->{\n\t\t\twhile(num==0) { //此处不要编写代码\n\t\t\t\t\n\t\t\t}\n\t\t}) .start();\n\t\t\n\t\tThread.sleep(1000);\n\t\tnum = 1;\n\t}\n\n}\n```\n\n# DCL单例模式\n\n```\npackage com.sxt.others;\n/**\n * DCL单例模式: 懒汉式套路基础上加入并发控制，保证在多线程环境下，对外存在一个对象\n * 1、构造器私有化 -->避免外部new构造器\n * 2、提供私有的静态属性 -->存储对象的地址\n * 3、提供公共的静态方法 --> 获取属性\n * \n * @author 裴新 \n *\n */\npublic class DoubleCheckedLocking {\n\t//2、提供私有的静态属性\n\t//没有volatile其他线程可能访问一个没有初始化的对象\n\tprivate static volatile DoubleCheckedLocking instance;\t\n\t//1、构造器私有化 \n\tprivate DoubleCheckedLocking() {\t\t\n\t}\n\t//3、提供公共的静态方法 --> 获取属性\n\tpublic static DoubleCheckedLocking getInstance() {\t\n\t\t//再次检测\n\t\tif(null!=instance) { //避免不必要的同步 ，已经存在对象\n\t\t\treturn instance;\n\t\t}\n\t\tsynchronized(DoubleCheckedLocking.class) {\n\t\t\tif(null == instance) {\t\t\t\t\n\t\t\t\tinstance = new DoubleCheckedLocking();\n\t\t\t\t//1、开辟空间 //2、初始化对象信息 //3、返回对象的地址给引用\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\t\n\tpublic static DoubleCheckedLocking getInstance1(long time) {\t\t\n\t\t\tif(null == instance) {\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(time);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tinstance = new DoubleCheckedLocking();\n\t\t\t\t//1、开辟空间 //2、初始化对象信息 //3、返回对象的地址给引用\n\t\t\t}\n\t\treturn instance;\n\t}\n\tpublic static void main(String[] args) {\n\t\tThread t = new Thread(()->{\n\t\t\tSystem.out.println(DoubleCheckedLocking.getInstance());\n\t\t}) ;\n\t\tt.start();\n\t\tSystem.out.println(DoubleCheckedLocking.getInstance());\n\t}\n\n}\n```\n\n# ThreadLocal\n\n[![img](https://niliv-technology-1252830662.cos.ap-chengdu.myqcloud.com/java/Snipaste_2019-04-29_20-40-56.png)](https://niliv-technology-1252830662.cos.ap-chengdu.myqcloud.com/java/Snipaste_2019-04-29_20-40-56.png)\n\n```\n/**\n * ThreadLocal:每个线程自身的存储本地、局部区域\n *  get/set/initialValue\n * @author 裴新 \n *\n */\npublic class ThreadLocalTest01 {\n\t//private static ThreadLocal<Integer> threadLocal = new ThreadLocal<> ();\n\t//更改初始化值\n\t/*private static ThreadLocal<Integer> threadLocal = new ThreadLocal<> () {\n\t\tprotected Integer initialValue() {\n\t\t\treturn 200;\n\t\t}; \n\t};*/\n\tprivate static ThreadLocal<Integer> threadLocal = ThreadLocal.withInitial(()-> 200);\n\tpublic static void main(String[] args) {\n\t\t//获取值\n\t\tSystem.out.println(Thread.currentThread().getName()+\"-->\"+threadLocal.get());\t\t\n\t\t//设置值\n\t\tthreadLocal.set(99);\n\t\tSystem.out.println(Thread.currentThread().getName()+\"-->\"+threadLocal.get());\n\t\t\n\t\tnew Thread(new MyRun()).start();\n\t\tnew Thread(new MyRun()).start();\n\t}\t\n\tpublic static  class MyRun implements Runnable{\n\t\tpublic void run() {\n\t\t\tthreadLocal.set((int)(Math.random()*99));\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"-->\"+threadLocal.get());\t\t\n\t\t}\n\t}\n\t\n}\n```\n\n```\n/**\n * ThreadLocal:每个线程自身的数据，更改不会影响其他线程\n * @author 裴新 \n *\n */\npublic class ThreadLocalTest02 {\t\n\tprivate static ThreadLocal<Integer> threadLocal = ThreadLocal.withInitial(()-> 1);\n\tpublic static void main(String[] args) {\n\t\tfor(int i=0;i<5;i++) {\n\t\t\tnew Thread(new MyRun()).start();\n\t\t}\n\t}\t\n\tpublic static  class MyRun implements Runnable{\n\t\tpublic void run() {\n\t\t\tInteger left =threadLocal.get();\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"得到了-->\"+left);\t\t\n\t\t\tthreadLocal.set(left -1);\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"还剩下-->\"+threadLocal.get());\t\n\t\t}\n\t}\n\t\n}\n```\n\n```\n/**\n * ThreadLocal:分析上下文 环境  起点\n * 1、构造器: 哪里调用 就属于哪里 找线程体\n * 2、run方法:本线程自身的\n * @author 裴新 \n *\n */\npublic class ThreadLocalTest03 {\t\n\tprivate static ThreadLocal<Integer> threadLocal = ThreadLocal.withInitial(()-> 1);\n\tpublic static void main(String[] args) {\n\t\tnew Thread(new MyRun()).start();\n\t\tnew Thread(new MyRun()).start();\n\t}\t\n\tpublic static  class MyRun implements Runnable{\n\t\tpublic MyRun() {\n\t\t\tthreadLocal.set(-100);\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"-->\"+threadLocal.get());\t\n\t\t}\n\t\tpublic void run() {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"-->\"+threadLocal.get());\t\n\t\t\t//new Thread(new MyRunxxx()).start();\n\t\t}\n\t}\n\t\n}\n```\n\n```\n/**\n * InheritableThreadLocal:继承上下文 环境的数据 ，拷贝一份给子线程\n * @author 裴新 \n *\n */\npublic class ThreadLocalTest04 {\t\n\tprivate static ThreadLocal<Integer> threadLocal = new InheritableThreadLocal<>();\n\tpublic static void main(String[] args) {\n\t\tthreadLocal.set(2);\n\t\tSystem.out.println(Thread.currentThread().getName()+\"-->\"+threadLocal.get());\t\n\t\t\n\t\t//线程由main线程开辟\n\t\tnew Thread(()->{\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"-->\"+threadLocal.get());\t\n\t\t\tthreadLocal.set(200);\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"-->\"+threadLocal.get());\t\n\t\t}) .start();\n\t\t\n\t}\t\n}\n```\n\n# 可重入锁\n\n[![img](https://niliv-technology-1252830662.cos.ap-chengdu.myqcloud.com/java/Snipaste_2019-04-29_20-55-43.png)](https://niliv-technology-1252830662.cos.ap-chengdu.myqcloud.com/java/Snipaste_2019-04-29_20-55-43.png)\n\n```\npackage com.sxt.others;\n/**\n * 可重入锁: 锁可以延续使用 + 计数器\n * \n * @author 裴新 \n *\n */\npublic class LockTest03 {\n\tReLock lock = new ReLock();\n\tpublic void a() throws InterruptedException {\n\t\tlock.lock();\n\t\tSystem.out.println(lock.getHoldCount());\n\t\tdoSomething();\n\t\tlock.unlock();\n\t\tSystem.out.println(lock.getHoldCount());\n\t}\n\t//不可重入\n\tpublic void doSomething() throws InterruptedException {\n\t\tlock.lock();\n\t\tSystem.out.println(lock.getHoldCount());\n\t\t//...................\n\t\tlock.unlock();\n\t\tSystem.out.println(lock.getHoldCount());\n\t}\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tLockTest03 test = new LockTest03();\n\t\ttest.a();\t\t\t\n\t\tThread.sleep(1000);\t\t\n\t\tSystem.out.println(test.lock.getHoldCount());\n\t}\n\n}\n// 可重入锁\nclass ReLock{\n\t//是否占用\n\tprivate boolean isLocked = false;\n\tprivate Thread lockedBy = null; //存储线程\n\tprivate int holdCount = 0;\n\t//使用锁\n\tpublic synchronized void lock() throws InterruptedException {\n\t\tThread t = Thread.currentThread();\n\t\twhile(isLocked && lockedBy != t) {\n\t\t\twait();\n\t\t}\n\t\t\n\t\tisLocked = true;\n\t\tlockedBy = t;\n\t\tholdCount ++;\n\t}\n\t//释放锁\n\tpublic synchronized void unlock() {\n\t\tif(Thread.currentThread() == lockedBy) {\n\t\t\tholdCount --;\n\t\t\tif(holdCount ==0) {\n\t\t\t\tisLocked = false;\n\t\t\t\tnotify();\n\t\t\t\tlockedBy = null;\n\t\t\t}\t\t\n\t\t}\t\t\n\t}\n\tpublic int getHoldCount() {\n\t\treturn holdCount;\n\t}\n}\n```\n\n# CAS\n\n[![img](https://niliv-technology-1252830662.cos.ap-chengdu.myqcloud.com/java/Snipaste_2019-04-29_21-00-44.png)](https://niliv-technology-1252830662.cos.ap-chengdu.myqcloud.com/java/Snipaste_2019-04-29_21-00-44.png)\n\n```\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * CAS:比较并交换\n * \n * @author 裴新 \n *\n */\npublic class CAS {\n\t//库存\n\tprivate static AtomicInteger stock = new AtomicInteger(5);\n\tpublic static void main(String[] args) {\n\t\tfor(int i=0;i<5;i++) {\n\t\t\tnew Thread(()->{\n\t\t\t\t//模拟网络延时\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tInteger left = stock.decrementAndGet();\n\t\t\t\tif(left<1) {\n\t\t\t\t\tSystem.out.println(\"抢完了...\");\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t\tSystem.out.print(Thread.currentThread().getName()+\"抢了一件商品\");\n\t\t\t\tSystem.out.println(\"-->还剩\"+left);\n\t\t\t}) .start();\n\t\t}\n\t}\n\n}\n```\n\n ","tags":["java"],"categories":["java"]},{"title":"线程等待唤醒","url":"/2020/05/23/java/thread/005/","content":"\n# 等待唤醒机制\n\n[TOC]\n\n## 什么是等待唤醒机制\n\n在开始讲解等待唤醒机制之前，有必要搞清一个概念——线程之间的通信：多个线程在处理<span style=color:red><b>同一个资源</b></span>，但是处理的动作（线程的任务）却不相同。通过一定的手段使各个线程能有效的利用资源。而这种手段即—— 等待唤醒机制。\n\n等待唤醒机制所涉及到的方法：\n\n-  wait（） :等待，将正在执行的线程释放其执行资格 和 执行权，并存储到线程池中。\n-  notify（）：唤醒，唤醒线程池中被wait（）的线程，一次唤醒一个，而且是任意的。\n-  notifyAll（）： 唤醒全部：可以将线程池中的所有wait() 线程都唤醒。\n\n其实，所谓唤醒的意思就是让 线程池中的线程具备执行资格。必须注意的是，这些方法都是在 同步中才有效。同时这些方法在使用时必须标明所属锁，这样才可以明确出这些方法操作的到底是哪个锁上的线程。\n\n仔细查看JavaAPI之后，发现这些方法 并不定义在 Thread中，也没定义在Runnable接口中，却被定义在了Object类中，为什么这些操作线程的方法定义在Object类中？\n\n因为这些方法在使用时，必须要标明所属的锁，而锁又可以是任意对象。能被任意对象调用的方法一定定义在Object类中。\n\n## **线程并发协作(生产者/消费者模式)**\n\n \t多线程环境下，我们经常需要多个线程的并发和协作。这个时候，就需要了解一个重要的多线程并发协作模型“生产者/消费者模式”。\n\n多线程环境下，我们经常需要多个线程的并发和协作。这个时候，就需要了解一个重要的多线程并发协作模型“生产者/消费者模式”。\n\n### 什么是生产者?\n\n​      生产者指的是负责生产数据的模块(这里模块可能是：方法、对象、线程、进程)。\n\n### 什么是消费者?\n\n​      消费者指的是负责处理数据的模块(这里模块可能是：方法、对象、线程、进程)。\n\n### 实现生产者/消费者模式的两种方法\n\n1. 管程法（使用缓冲区）\n2. 信号灯法（使用标识符）\n\n### 什么是缓冲区?\n\n​      消费者不能直接使用生产者的数据，它们之间有个“缓冲区”。生产者将生产好的数据放入“缓冲区”，消费者从“缓冲区”拿要处理的数据。\n\n![图11-17 生产者消费者示意图.png](https://www.sxt.cn/360shop/Public/admin/UEditor/20170526/1495792247608300.png)\n\n​      缓冲区是实现并发的核心，缓冲区的设置有3个好处：\n\n1. 实现线程的并发协作\n\n​      有了缓冲区以后，生产者线程只需要往缓冲区里面放置数据，而不需要管消费者消费的情况;同样，消费者只需要从缓冲区拿数据处理即可，也不需要管生产者生产的情况。 这样，就从逻辑上实现了“生产者线程”和“消费者线程”的分离。\n\n2.  解耦了生产者和消费者\n\n​      生产者不需要和消费者直接打交道。\n\n3. 解决忙闲不均，提高效率\n\n​      生产者生产数据慢时，缓冲区仍有数据，不影响消费者消费;消费者处理数据慢时，生产者仍然可以继续往缓冲区里面放置数据 。\n\n####　管程法\n\n``` java\npackage cn.clboy.sync.cooperation;\n\n/**\n * @Author cloudlandboy\n * @Since 1.0.0\n * @Describe 线程之间通信，协作模型，生产者消费者实现方式一:管程法\n */\n\npublic class ProviderConsumer {\n\n    public static void main(String[] args) {\n        //创建缓冲区\n        BufferArea bufferArea = new BufferArea();\n        //创建生产者\n        new Thread(new Provider(bufferArea)).start();\n        //创建消费者\n        new Thread(new Consumer(bufferArea)).start();\n    }\n\n}\n\n/**\n * 缓冲区\n * 消费者不能直接使用生产者的数据，它们之间有个“缓冲区”。\n * 生产者将生产好的数据放入“缓冲区”，消费者从“缓冲区”拿要处理的数据。\n */\nclass BufferArea {\n    /**\n     * 存储容器\n     */\n    private String[] datas = new String[16];\n\n    /**\n     * 计数器，记录当前缓冲区的数据量\n     */\n    private int count;\n\n    /**\n     * 存储，生产，往缓冲区中添加数据\n     *\n     * @throws Exception\n     */\n    public synchronized void push(String data) {\n        //容器中已经放满，不需要再生产\n        if (count >= datas.length) {\n            try {\n                this.wait();  //线程阻塞  等待消费者消费后通知解除\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        //存在空间接着生产\n        datas[count++] = data;\n        //存在数据了，可以通知消费者消费了\n        this.notifyAll();\n    }\n\n    /**\n     * 获取，消费，在缓冲区中取数据\n     *\n     * @throws Exception\n     */\n    public synchronized String pop() {\n        //没有数据\n        if (count <= 0) {\n            try {\n                this.wait();  //线程阻塞  等待生产者生产后通知解除\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        count--;\n        //存在数据，直接消费\n        String data = datas[count];\n        //通知生产者，有空间了，可以继续生产\n        this.notifyAll();\n\n        return data;\n    }\n}\n\n/**\n * 生产者\n */\nclass Provider implements Runnable {\n\n    private BufferArea bufferArea;\n\n    public Provider(BufferArea bufferArea) {\n        this.bufferArea = bufferArea;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 50; i++) {\n            String data = \"产品\" + i;\n            System.out.println(\"生产者生产了：\" + data);\n            bufferArea.push(data);\n        }\n    }\n}\n\n/**\n * 消费者\n */\nclass Consumer implements Runnable {\n\n    private BufferArea bufferArea;\n\n    public Consumer(BufferArea bufferArea) {\n        this.bufferArea = bufferArea;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 50; i++) {\n            System.out.println(\"消费者消费了：\" + bufferArea.pop());\n        }\n    }\n}\n```\n\n### 信号灯法\n\n``` java\npackage cn.clboy.sync.cooperation;\n\n/**\n * @Author cloudlandboy\n * @Since 1.0.0\n * @Describe 线程之间通信，协作模型，生产者消费者实现方式二:信号灯法\n * @Describe 需要借助标识位，就像人行道的红路灯，红灯车走人停,绿灯人走车停\n * @Describe 这里模拟下棋\n */\n\npublic class ProviderConsumer2 {\n\n    public static void main(String[] args) {\n        //创建对局\n        Chessboard chessboard = new Chessboard();\n\n        //创建黑白玩家\n        Thread blank = new Thread(new BlankPlayer(chessboard));\n        Thread white = new Thread(new WhitePlayer(chessboard));\n\n        //开始\n        blank.start();\n        white.start();\n    }\n\n}\n\n\n/**\n * 对局\n */\nclass Chessboard {\n    /**\n     * 标识位，true：黑棋，false：白棋\n     */\n    private boolean flag = true;\n\n    public synchronized void BlackRun() {\n        //不是true，就等待白棋走完\n        if (!flag) {\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        //是true，走一步\n        System.out.println(\"黑棋走了一步\");\n        //切换标志\n        flag = !flag;\n        //唤醒一个线程线程，就是白棋走\n        this.notify();\n    }\n\n    public synchronized void WhiteRun() {\n        //true，就等待黑棋走完\n        if (flag) {\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //是false，走一步\n        System.out.println(\"白棋走了一步\");\n        //切换标志\n        flag = !flag;\n        //唤醒一个线程，就是黑棋走\n        this.notify();\n    }\n\n}\n\n/**\n * 黑棋玩家\n */\nclass BlankPlayer implements Runnable {\n\n    private Chessboard chessboard;\n\n    public BlankPlayer(Chessboard chessboard) {\n        this.chessboard = chessboard;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 113; i++) {\n            chessboard.BlackRun();\n        }\n    }\n}\n\n/**\n * 白玩家\n */\nclass WhitePlayer implements Runnable {\n\n    private Chessboard chessboard;\n\n    public WhitePlayer(Chessboard chessboard) {\n        this.chessboard = chessboard;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 112; i++) {\n            chessboard.WhiteRun();\n        }\n    }\n}\n\n```\n\n","tags":["java"],"categories":["java"]},{"title":"hexo搭建","url":"/2020/05/22/hexo搭建/","content":"Linux下使用hexo+vscode+markdown编写博客\n\n\n### hexo\n\n#### 安装nodejs和git\n\n*   Windows到[官网](http://nodejs.cn/download)下载安装包\n*   linux安装nodejs：\n\n####  linux安装nodejs\ncurl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -\nsudo apt install nodejs\n\n#### npm换淘宝源\nsudo npm install -g cnpm --registry=https://registry.npm.taobao.org\n    \n\n#### 安装hexo\n\n    sudo cnpm install -g hexo-cli\n    \n\n#### 配置hexo\n\n    # 初始化一个目录\n    hexo init blog\n    cd blog\n    cnpm install\n    \n    # 到hexo主题网站选择一个喜欢的主题，我这里选的是aircloud，把主题clone到themes文件夹\n    git clone https://github.com/aircloud/hexo-theme-aircloud.git themes/aircloud\n    \n\n*   配置\\_config.yaml可以参考以下设置\n\n[官方Demo](https://github.com/aircloud/hexo-aircloud-blog/blob/master/_config.yml)\n\n在文件最后设置需要同步的仓库，可以设置多个：\n\n    deploy:\n        type: git\n        repo:\n            github: your github repo url\n            gitee: your gitee repo url\n            coding: your conding repo url\n    \n\n*   其他功能的配置\n\n请参考[官方文档](https://github.com/aircloud/hexo-theme-aircloud)\n\n#### 使用hexo\n\n    # 新建文章\n    hexo new filename       # 它会在source/_posts文件夹创建一个新的markdown文件，在这里面写文章就好了\n    \n    # 清空缓存，每次生成前最好执行一下\n    hexo clean\n    \n    # 生成静态文件\n    hexo g\n    \n    # 启动本地服务器，每次发布前可以在本地看一下效果\n    hexo s\n    \n    # 发布到远程仓库前，需要安装以下插件\n    cnpm install hexo-deployer-git --save\n    \n    # 发布到远程仓库\n    hexo d\n    \n\n#### 设置github\n\n*   注册github账号\n*   创建一个username.github.io的仓库\n*   创建sshkey\n\n```\n    ssh-keygen -t rsa -C 'your email'\n    # 创建好后到家目录下的.ssh目录找到id_rsa.pub复制里面的公钥，然后到github里面添加sshkey，就可以不需要密码上传了\n```\n\n*   在github设置里添加自己的sshkey\n*   绑定自己的域名\n\n发布好之后就可以通过[https://username.github.io]访问了，但是很多人希望绑定自己的域名，到本地的blog/source文件夹下创建CNAME文件，里面写上需要绑定的域名。发布一下，然后到域名服务商设置CNAME，就可以使用自己的域名访问了。\n\n#### 设置gitee\n\n*   注册gitee账号\n*   创建一个和自己名字相同的仓库\n*   发布后，进入仓库，点击服务-pages就可以设置好博客了\n*   gitee和github有这样几个区别\n    *   gitee访问速度快，github比较慢\n    *   gitee每次发布都需要到pages页面下更新，github不需要\n    *   gitee不能绑定自己的域名，github可以\n*   gitee有一个gitee pages Pro可以解决它的所有问题，但是99/年\n\n#### 设置coding\n\n最近发现了一个代码托管网站[coding]，它用来做博客比上面两个都要合适，因为它有自动发布，在国内访问速 度比较快，可以绑定自己的域名（无需备案），并且完全免费。\n\n用法和上面两个完全相同，创建仓库后进入仓库，点击持续部署-静态网站，就可以设置好博客了。\n\n> 这三个代码托管网站，我推荐在github和coding上都部署一个，防止其中一个突然挂了，gitee那个太麻烦了，就不考虑了。\n\n#### 博客文件的备份\n\n我们要居安思危，为了防止哪天我们的电脑直接挂了，然后带走我们所有的博客，所以我们要备份我们的hexo文件夹。上传到远程仓库的那些只是渲染完成之后的网页，并不是我们编写的markdown文件。如果你使用的是Windows系统，我推荐使用坚果云进行同步，直接把整 个文件夹同步就好了。当然，有些文件夹是不用同步的，坚果云可以设置忽略文件夹，不用同步的文件夹有public和.deploy\\_git. 但是 我使用的是Linux，而Linux版的坚果云不可以设置忽略文件夹，所以我就直接使用git进行备份了。\n\n### markdown\n\nmarkdown是个好东西，Linux上优秀的markdown编辑器也不少，比如typora就有Linux版本的，但是在我的电脑上好像有点bug，无法右键 打开文件，所以我就选择了vscode。  \n我在vscode上安装的插件主要有:\n\n*   Markdown All in One(集成了markdown的一些功能)\n*   Markdown Preview Enhanced(预览markdown文件)\n*   Paste Image(自定义粘贴图片的链接的)\n*   One Dark Pro(主题，好看)\n*   scrolloff(当你打字的时候，保证你的光标不会移动到最上面或最下面让你的目光集中在中间的位置)\n*   Power Mode(打字的时候有特效,好看)\n\n\n\n编写markdown文件最麻烦的还是图片的插入，最好的解决方案就是图床，Windows下有一款很好用的图床软件叫Picgo，在Linux下也有， 但是里面提供的图床真正稳定免费的只有github图床，但是github图床访问又太慢了，所以我就放弃了使用Picgo。\n\n其实只要是可以使用git的代码托管网站都可以作为我们的图床，它们的图片产生的外链前面都是一样的，只有文件名不同，我们只需要 使用_Paste Image_插件将图片保存到电脑里的同一个目录，然后设置好图片链接的格式，最后将目录里的图片全都push到远程仓库就可 以访问了。\n\n这样的好处是本地也会保存有一份图片副本,如果你的远程仓库挂了,图片也不会丢失,你可以寻找其他的替代方案,到时候批量把链接改掉就可以直接访问了.\n\n#### Paste Image 设置\n\n先说Paste Image的设置，点击vscode左下角的小齿轮,选择设置-扩展-Paste Image Configuration, 需要更改的只有两项:\n\n*   Paste Image: Insert Pattern(粘贴的链接格式,your\\_url的获取方法见本地仓库设置)  \n    ${imageSyntaxPrefix}your\\_url${imageFileName}${imageSyntaxSuffix}\n*   Paste Image: Path(图片在本地保存的绝对路径)\n\n这样你每次复制图片之后,使用ctrl+alt+v粘贴到vscode的时候,图片将自动保存到你设置的文件夹里,链接格式也已经帮你转换好了.\n\n#### git设置\n\n这时候图片还在本地文件夹保存着,但是链接是远程仓库的链接,还是访问不了图片的,现在就是要把图片文件夹同步到远程仓库.\n\n这里远程仓库我使用的是国内的coding,本来想用gitee的,但是gitee的访问好像有点问题,所以只好用coding了.我在使用gitee的时候,本地的预览无法显示出图片,但是直接将链接粘贴到浏览器是可以访问的,将文章发布到博客之后,我在gitee和github都部署了博客,结果gitee的无法显示出图片,github的可以,Interesting!\n\n##### 远程仓库设置\n\n1.  在coding注册登录\n2.  在coding创建一个公开的仓库\n3.  将sshkey公钥添加到coding设置里\n4.  复制仓库的链接备用\n\n\n#### 本地仓库设置\n\n1.  到上面Paste Image里面设置的文件夹路径下打开终端,执行以下命令.\n```\n    # 初始化仓库\n    git init\n    \n    # 与远程仓库关联\n    git remote add origin your-repo-url(这就是上面复制的仓库链接)\n    \n    # 拉取远程仓库的内容\n    git pull origin master\n    \n    # 在文件夹放一个测试图片,将本地仓库的内容推送到远程仓库并绑定\n    git push --set-upstream origin master\n    \n    # 以后每次上传时候的三部曲\n    git add .\n    git commit -m 'update'\n    git push\n ```  \n\n现在图片已经上传到远程仓库了,现在到远程仓库点击那张图片,点击右上角的原始数据,这个时候浏览器上地址栏的链接就是这张图片的 外链了,这个链接除了文件名之外的部分就是上面要设置的_Paste Image: Insert Pattern(粘贴的链接格式)_中的_your\\_url_的部分.\n\n##### 自动上传脚本\n\n到现在为止,在markdown中添加图片的步骤就是:\n\n1.  复制图片\n2.  使用ctrl+alt+v粘贴链接到vscode\n3.  使用上传三部曲,上传图片\n\n但是每次都要打开终端,进入那个目录,执行三条命令进行上传,实在是太麻烦了,所以我自己又写了一个脚本,自动上传图片.我使用的是Python,需要依赖gitpython库.\n\n    #! /usr/bin/python3\n    \n    import git\n    \n    pushPath = \"你的图片文件夹的绝对路径\"\n    \n    repo = git.Repo(pushPath)\n    origin = repo.remote(name=\"origin\")\n    \n    def autoPush():\n        repo.git.add(\".\")\n        repo.git.commit(m=\"update\")\n        origin.push()\n    \n    if __name__ == \"__main__\":\n        autoPush()\n    \n\n授予此脚本执行权限,然后把它绑定到一个快捷键,然后每次就可以直接按一下快捷键自动上传了.","tags":["hexo"]},{"title":"java数组","url":"/2020/05/22/java/collection/array/","content":"Linux下使用hexo+vscode+markdown编写博客\n\n# JAVA数组\n\n[TOC]\n\n## 数组的copy\n\n <mark>src：</mark> copy的源数组  \n <mark>srcPos：</mark>从哪个索引处开始  \n <mark>dest：</mark>拷贝到的目标数据  \n <mark>destPos：</mark>从目标数据的哪个位置开始放  \n <mark>length：</mark>复制几个元素  \n ``` java\n    public static void copy() throws Exception {\n        String[] src = {\"a\", \"b\", \"c\", \"d\"};\n        String[] dest = new String[4];\n\n        //将src中的b和c复制到dest的[1]和[2]位置\n        \n        System.arraycopy(src, 1, dest, 1, 2);\n\n        System.out.println(Arrays.toString(dest));\n    }\n ```\n输出结果：  \n```\n[null, b, c, null]\n```\n## 从数组中删除某个元素  \n\n本质上还是数组的拷贝  \n\n``` java\n    public static void remove() throws Exception {\n        int[] src = {1, 2, 88, 3, 4, 5};\n\n        //删除88,就应该从88的下一个元素的下标开始复制到结尾，复制到的数组还是src，从88的下标处开始放\n        System.arraycopy(src, 3, src, 2, src.length - 3);\n\n        //然后删除最后一个元素\n        src[src.length - 1] = 0;\n        System.out.println(Arrays.toString(src));\n    }\n```\n输出结果：\n```\n[1, 2, 3, 4, 5, 0]\n```\n封装成方法：\n``` java\n    public static void remove(String[] array, int index) throws Exception {\n        System.arraycopy(array, index + 1, array, index, array.length - index - 1);\n        array[array.length - 1] = null;\n        System.out.println(Arrays.toString(array));\n    }\n```\n\n## 数组的扩容  \n\n本质上是：先定义一个更大的数组，然后将原数组内容原封不动拷贝到新数组中  \n``` java\n    public static void main(String[] args) throws Exception {\n        String[] arr = {\"a\", \"b\", \"c\"};\n        System.out.println(Arrays.toString(arr));\n        arr = enlarge(arr, 10);\n        System.out.println(Arrays.toString(arr));\n    }\n\n    public static String[] enlarge(String[] array, int num) throws Exception {\n\n\n//        String[] newArray = new String[array.length + num];\n//\n//        System.arraycopy(array, 0, newArray, 0, array.length);\n//\n//        return newArray;\n\n        return Arrays.copyOf(array,num);\n    }\n```\n输出结果：  \n```\n[a, b, c]\n[a, b, c, null, null, null, null, null, null, null]\n```\n## 冒泡排序\n\n![](https://cdn.static.note.zzrfdsn.cn/images/1258817-20190325093445247-432584102.gif)\n``` java\n    public static void main(String[] args) throws Exception {\n        int[] arr = {3, 1, 6, 2, 9, 0, 7, 4, 5, 8};\n        bubbleSort(arr);\n    }\n\n    public static void bubbleSort(int[] array) throws Exception {\n        int temp;\n        //两两比较减去一次多余的\n        for (int k = 0; k < array.length - 1; k++) {\n            boolean done = true;\n            //循环一轮找出最大值，每一轮就会找出一个最大值就没有必要再循环全部，只需要循环到上一个最大值前即可\n            for (int i = 0; i < array.length - 1 - k; i++) {\n                if (array[i] > array[i + 1]) {\n                    temp = array[i];\n                    array[i] = array[i + 1];\n                    array[i + 1] = temp;\n                    done = false;\n                }\n                System.out.println(Arrays.toString(array));\n            }\n\n            //如果一轮循环完毕没有一个位置对换，就说明排序完毕，跳出循环\n            if (done) {\n                break;\n            }\n            System.out.println(\"------------------------------\");\n        }\n    }\n```\n## 二分法查找\n\n二分法查找原理：  \n\n1. 只要低位下标不大于高位下标，就进行二分查找\n\n2. 先在有序的数组中对半查找中间的坐标，如果中标和要查找的下标相等时，找到目标数，那二分结束。\n\n3. 如果步骤2没有找到，那就会出现先2种情况：a、中标大于find值；b、中标小于find值；\n\n   a. 如果中标大于find值，说明find值在中标的左边，那么高位就是此时的中标，然后继续二分\n\n   b. 如果中标小于find值，说明find值在中标的右边，那么低位就是此时的中标，然后继续二分\n\n4. 如果低位下标大于高位下标：那就是没有这个想要查找的find值\n\n\n``` java\n    public static void main(String[] args) throws Exception {\n        int[] arr = {3, 1, 6, 2, 9, 0, 7, 4, 5, 8};\n        //需要先对数据进行排序\n        Arrays.sort(arr);\n        System.out.println(Arrays.toString(arr));\n        int index = binarySearch(arr, 0);\n        System.out.println(index);\n    }\n\n    public static int binarySearch(int[] array, int key) throws Exception {\n        int start = 0;\n        int end = array.length - 1;\n\n        while (start <= end) {\n            //取中间数\n            int middle = (start + end) / 2;\n            if (key < array[middle]) {\n                //要查找的数比中间数小，那就把查找结尾值变为中间值减去一\n                end = middle - 1;\n            } else if (key > array[middle]) {\n                //要查找的数比中间数大，那就把查找开始位置变为中间值加一\n                start = middle + 1;\n            } else {\n                //等于中间值\n                return middle;\n            }\n        }\n\n        //没有查到\n        return -1;\n\n//       return Arrays.binarySearch(array,key);\n    }\n```\n","tags":["java"],"categories":["java"]},{"title":"Hello World","url":"/2020/05/22/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]