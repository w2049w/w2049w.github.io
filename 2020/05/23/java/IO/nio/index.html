<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        NIO - undefined
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.1"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i>  </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/" />
        </div>
        <div class="name">
            <i>wwei</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#NIO"><span class="toc-text">NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO与IO的主要区别"><span class="toc-text">NIO与IO的主要区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缓冲区-Buffer"><span class="toc-text">缓冲区(Buffer)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#缓冲区的基本属性"><span class="toc-text">缓冲区的基本属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Buffer的常用方法"><span class="toc-text">Buffer的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓冲区的数据操作"><span class="toc-text">缓冲区的数据操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put"><span class="toc-text">put()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flip"><span class="toc-text">flip()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get"><span class="toc-text">get()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rewind-可重复读"><span class="toc-text">rewind()可重复读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clear"><span class="toc-text">clear()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mark-和reset"><span class="toc-text">mark()和reset()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hasRemaining-和remaining"><span class="toc-text">hasRemaining()和remaining()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#直接与非直接缓冲区"><span class="toc-text">直接与非直接缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通道-Channel"><span class="toc-text">通道(Channel)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#主要实现类"><span class="toc-text">主要实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取通道"><span class="toc-text">获取通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通道的数据传输"><span class="toc-text">通道的数据传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transferTo-和transferFrom"><span class="toc-text">transferTo()和transferFrom()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分散-Scatter-和聚集-Gather"><span class="toc-text">分散(Scatter)和聚集(Gather)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileChannel的常用方法"><span class="toc-text">FileChannel的常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符集：Charset"><span class="toc-text">字符集：Charset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞与非阻塞"><span class="toc-text">阻塞与非阻塞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SocketChannel"><span class="toc-text">SocketChannel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞式NIO"><span class="toc-text">阻塞式NIO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选择器-Selector"><span class="toc-text">选择器(Selector)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选择器-Selector-的应用"><span class="toc-text">选择器(Selector)的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SelectionKey"><span class="toc-text">SelectionKey</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Selector的常用方法"><span class="toc-text">Selector的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非阻塞式NIO"><span class="toc-text">非阻塞式NIO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DatagramChannel"><span class="toc-text">DatagramChannel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#管道-pipe"><span class="toc-text">管道(pipe)</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i>  </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        NIO
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2020-05-23 00:00:00</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#java" title="java">java</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。</p>
<p>NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同。</p>
<p>NIO支持<code>面向缓冲区</code>的、<code>基于通道的IO操作</code>。NIO将以更加高效的方式进行文件的读写操作。</p>
<h2 id="NIO与IO的主要区别"><a href="#NIO与IO的主要区别" class="headerlink" title="NIO与IO的主要区别"></a>NIO与IO的主要区别</h2><table>
<thead>
<tr>
<th>IO</th>
<th>NIO</th>
</tr>
</thead>
<tbody><tr>
<td>面向流(Stream Oriented)</td>
<td>面向缓冲区(Buffer Oriented)</td>
</tr>
<tr>
<td>阻塞IO(Blocking IO)</td>
<td>非阻塞IO(Non Blocking IO)</td>
</tr>
<tr>
<td>(无)</td>
<td>选择器(Selectors)</td>
</tr>
</tbody></table>
<blockquote>
<p>传统IO面向流，程序读取文件需要建立一个输入流</p>
</blockquote>
<p><img src="https://cdn.static.note.zzrfdsn.cn/images/io/20191228175457.gif" alt="20191228175457"></p>
<blockquote>
<p>同样传统IO要想将程序中的内容输出到文件还要建立一个输出流</p>
</blockquote>
<p><img src="https://cdn.static.note.zzrfdsn.cn/images/io/1577527290649.png" alt="1577527290649"></p>
<blockquote>
<p>NIO面向缓存区，其中的通道也可以理解为传统IO中流，但是又有些差异</p>
</blockquote>
<p>如果把传统IO中流理解为生活中的水流(单向流动)，那么可以把NIO中的通道理解为生活中的火车轨道，只是一条通往两个地方的连接(A-&gt;B)，铁路是静止的，是无法完成运输的，要想从A到B就要坐上从A到B的火车(缓存区)，然后沿着这条轨道(通道)才能到达B，到达B之后乘客从火车上下来，同样火车又可以载着想从B到A的人沿着这条轨道再回到A</p>
<p><img src="https://cdn.static.note.zzrfdsn.cn/images/io/20191228181005.gif" alt="20191228181005"></p>
<blockquote>
<p>所以NIO中的缓存区是双向的</p>
</blockquote>
<p><img src="https://cdn.static.note.zzrfdsn.cn/images/io/1577528211499.png" alt="1577528211499"></p>
<p>?&gt; <strong>简而言之，通道负责传输， 缓存区负责存储</strong></p>
<h2 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区(Buffer)"></a>缓冲区(Buffer)</h2><p><code>缓冲区（Buffer）</code>：一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类。</p>
<p>Java NIO 中的 Buffer 主要用于与 NIO 通道进行交互，数据是从通道<code>读</code>入缓冲区，从缓冲区<code>写</code>入通道中的</p>
<p>Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(boolean 除外) ，有以下 Buffer 常用子类：</p>
<ul>
<li><strong>ByteBuffer</strong></li>
<li><strong>CharBuffer</strong></li>
<li><strong>ShortBuffer</strong></li>
<li><strong>IntBuffer</strong></li>
<li><strong>LongBuffer</strong></li>
<li><strong>FloatBuffer</strong></li>
<li><strong>DoubleBuff</strong></li>
</ul>
<p>上述 Buffer 类 他们都采用相似的方法进行管理数据，只是各自管理的数据类型不同而已。都是通过<code>allocate</code>静态方法获取一个 Buffer对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个容量为 capacity 的 XxxBuffer 对象</span></span><br><span class="line">XxxBuffer.allocate(<span class="keyword">int</span> capacity)</span><br></pre></td></tr></table></figure>



<h3 id="缓冲区的基本属性"><a href="#缓冲区的基本属性" class="headerlink" title="缓冲区的基本属性"></a>缓冲区的基本属性</h3><ul>
<li><p><code>容量 (capacity)</code> ：表示 Buffer 最大数据容量，缓冲区容量不能为负，并且创建后不能更改。</p>
<p>(因为底层是数组，数组一但被创建就不能被改变)</p>
</li>
<li><p><code>限制 (limit)</code>：界限，表示缓冲区中可以操作数据的大小。（limit 后数据不能进行读写）</p>
</li>
<li><p><code>位置 (position)</code>：位置，表示缓冲区中正在操作数据的位置。</p>
</li>
<li><p><code>标记 (mark)与重置 (reset)</code>：标记，表示记录当前 position 的位置。可以通过 reset() 恢复到 mark 的位置</p>
</li>
</ul>
<p>!&gt; 标记、位置、限制、容量遵守以下不变式： <code>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//通过 allocate() 获取缓冲区</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">this</span>.print(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Buffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//表示 Buffer 最大数据容量</span></span><br><span class="line">        System.out.println(<span class="string">"capacity："</span> + buffer.capacity());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//界限，表示缓冲区中可以操作数据的大小</span></span><br><span class="line">        System.out.println(<span class="string">"limit："</span> + buffer.limit());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//位置，表示缓冲区中正在操作数据的位置</span></span><br><span class="line">        System.out.println(<span class="string">"position："</span> + buffer.position());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">capacity：10</span><br><span class="line">limit：10</span><br><span class="line">position：0</span><br></pre></td></tr></table></figure>



<h3 id="Buffer的常用方法"><a href="#Buffer的常用方法" class="headerlink" title="Buffer的常用方法"></a>Buffer的常用方法</h3><table>
<thead>
<tr>
<th>方 法</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>Buffer clear()</td>
<td>清空缓冲区并返回对缓冲区的引用</td>
</tr>
<tr>
<td>Buffer flip()</td>
<td>将缓冲区的界限设置为当前位置，并将当前位置重置为 0</td>
</tr>
<tr>
<td>int capacity()</td>
<td>返回 Buffer 的 capacity 大小</td>
</tr>
<tr>
<td>boolean hasRemaining()</td>
<td>判断缓冲区中是否还有元素</td>
</tr>
<tr>
<td>int limit()</td>
<td>返回 Buffer 的界限(limit) 的位置</td>
</tr>
<tr>
<td>Buffer limit(int n)</td>
<td>将设置缓冲区界限为 n, 并返回一个具有新 limit 的缓冲区对象</td>
</tr>
<tr>
<td>Buffer mark()</td>
<td>对缓冲区设置标记</td>
</tr>
<tr>
<td>int position()</td>
<td>返回缓冲区的当前位置 position</td>
</tr>
<tr>
<td>Buffer position(int n)</td>
<td>将设置缓冲区的当前位置为 n , 并返回修改后的 Buffer 对象</td>
</tr>
<tr>
<td>int remaining()</td>
<td>返回 position 和 limit 之间的元素个数</td>
</tr>
<tr>
<td>Buffer reset()</td>
<td>将位置 position 转到以前设置的 mark 所在的位置</td>
</tr>
<tr>
<td>Buffer rewind()</td>
<td>将位置设为为 0， 取消设置的 mark</td>
</tr>
</tbody></table>
<p><img src="https://cdn.static.note.zzrfdsn.cn/images/io/1577534826954.png" alt="1577534826954"></p>
<h3 id="缓冲区的数据操作"><a href="#缓冲区的数据操作" class="headerlink" title="缓冲区的数据操作"></a>缓冲区的数据操作</h3><blockquote>
<p>Buffer 所有子类提供了两个用于数据操作的方法：<strong>get()</strong> 与 <strong>put()</strong> 方法</p>
</blockquote>
<ul>
<li><p><strong>获取 Buffer 中的数据</strong></p>
<ul>
<li><code>get()</code> ：读取单个字节</li>
<li><code>get(byte[] dst)</code>：批量读取多个字节到 dst 中</li>
<li><code>get(int index)</code>：读取指定索引位置的字节(不会移动 position)</li>
</ul>
</li>
<li><p><strong>放入数据到 Buffer 中</strong></p>
<ul>
<li><code>put(byte b)</code>：将给定单个字节写入缓冲区的当前位置</li>
<li><code>put(byte[] src)</code>：将 src 中的字节写入缓冲区的当前位置</li>
<li><code>put(int index, byte b)</code>：将指定字节写入缓冲区的索引位置(不会移动 position)</li>
</ul>
</li>
</ul>
<h3 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    byteBuffer.put(<span class="string">"abc"</span>.getBytes());</span><br><span class="line">    <span class="keyword">this</span>.print(byteBuffer);</span><br><span class="line">    byteBuffer.put(<span class="string">"中"</span>.getBytes());</span><br><span class="line">    <span class="keyword">this</span>.print(byteBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">capacity：10</span><br><span class="line">limit：10</span><br><span class="line">position：3</span><br><span class="line"></span><br><span class="line">capacity：10</span><br><span class="line">limit：10</span><br><span class="line">position：6</span><br></pre></td></tr></table></figure>



<h3 id="flip"><a href="#flip" class="headerlink" title="flip()"></a>flip()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    byteBuffer.put(<span class="string">"abcde"</span>.getBytes());</span><br><span class="line">    <span class="keyword">this</span>.print(byteBuffer);</span><br><span class="line">    <span class="comment">//切换读取数据模式,将缓冲区的界限(limit)设置为当前位置(position)，并将当前位置重置为 0</span></span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    <span class="keyword">this</span>.print(byteBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">capacity：10</span><br><span class="line">limit：10</span><br><span class="line">position：5</span><br><span class="line"></span><br><span class="line">capacity：10</span><br><span class="line">limit：5</span><br><span class="line">position：0</span><br></pre></td></tr></table></figure>



<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    byteBuffer.put(<span class="string">"abcde"</span>.getBytes());</span><br><span class="line">    <span class="keyword">this</span>.print(byteBuffer);</span><br><span class="line">    <span class="comment">//切换读取数据模式,将缓冲区的界限(limit)设置为当前位置(position)，并将当前位置重置为 0</span></span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    <span class="keyword">this</span>.print(byteBuffer);</span><br><span class="line">    <span class="comment">//利用 get() 读取缓冲区中的数据</span></span><br><span class="line">    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuffer.limit()];</span><br><span class="line">    byteBuffer.get(b);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(b));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">capacity：10</span><br><span class="line">limit：10</span><br><span class="line">position：5</span><br><span class="line"></span><br><span class="line">capacity：10</span><br><span class="line">limit：5</span><br><span class="line">position：0</span><br><span class="line"></span><br><span class="line">abcde</span><br><span class="line"></span><br><span class="line">capacity：10</span><br><span class="line">limit：5</span><br><span class="line">position：5</span><br></pre></td></tr></table></figure>



<h3 id="rewind-可重复读"><a href="#rewind-可重复读" class="headerlink" title="rewind()可重复读"></a>rewind()可重复读</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    byteBuffer.put(<span class="string">"abcde"</span>.getBytes());</span><br><span class="line">    <span class="comment">//切换读取数据模式,将缓冲区的界限(limit)设置为当前位置(position)，并将当前位置重置为 0</span></span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    <span class="comment">//利用 get() 读取缓冲区中的数据</span></span><br><span class="line">    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuffer.limit()];</span><br><span class="line">    byteBuffer.get(b);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(b));</span><br><span class="line">    <span class="keyword">this</span>.print(byteBuffer);</span><br><span class="line">    byteBuffer.rewind();</span><br><span class="line">    <span class="keyword">this</span>.print(byteBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">abcde</span><br><span class="line"></span><br><span class="line">capacity：10</span><br><span class="line">limit：5</span><br><span class="line">position：5</span><br><span class="line"></span><br><span class="line">capacity：10</span><br><span class="line">limit：5</span><br><span class="line">position：0</span><br></pre></td></tr></table></figure>



<h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><blockquote>
<p>清空缓冲区. 但是缓冲区中的数据依然存在，但是处于“被遗忘”状态</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    byteBuffer.put(<span class="string">"abcde"</span>.getBytes());</span><br><span class="line">    <span class="comment">//切换读取数据模式,将缓冲区的界限(limit)设置为当前位置(position)，并将当前位置重置为 0</span></span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    <span class="comment">//利用 get() 读取缓冲区中的数据</span></span><br><span class="line">    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuffer.limit()];</span><br><span class="line">    byteBuffer.get(b);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(b));</span><br><span class="line">    <span class="keyword">this</span>.print(byteBuffer);</span><br><span class="line">    </span><br><span class="line">    byteBuffer.rewind();</span><br><span class="line">    <span class="keyword">this</span>.print(byteBuffer);</span><br><span class="line">    </span><br><span class="line">    byteBuffer.clear();</span><br><span class="line">    <span class="keyword">this</span>.print(byteBuffer);</span><br><span class="line">    </span><br><span class="line">    System.out.println((<span class="keyword">char</span>) byteBuffer.get());</span><br><span class="line">    System.out.println((<span class="keyword">char</span>)byteBuffer.get());</span><br><span class="line">    System.out.println((<span class="keyword">char</span>)byteBuffer.get());</span><br><span class="line">    System.out.println((<span class="keyword">char</span>)byteBuffer.get());</span><br><span class="line">    System.out.println((<span class="keyword">char</span>)byteBuffer.get());</span><br><span class="line">    System.out.println(byteBuffer.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">abcde</span><br><span class="line"></span><br><span class="line">capacity：10</span><br><span class="line">limit：5</span><br><span class="line">position：5</span><br><span class="line"></span><br><span class="line">capacity：10</span><br><span class="line">limit：5</span><br><span class="line">position：0</span><br><span class="line"></span><br><span class="line">capacity：10</span><br><span class="line">limit：10</span><br><span class="line">position：0</span><br><span class="line"></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">0</span><br></pre></td></tr></table></figure>



<h3 id="mark-和reset"><a href="#mark-和reset" class="headerlink" title="mark()和reset()"></a>mark()和reset()</h3><blockquote>
<p>mark() : 标记，reset() : 恢复到 mark 的位置</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test07() throws Exception &#123;</span><br><span class="line">    ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(10);</span><br><span class="line">    byteBuffer.put(&quot;abcde&quot;.getBytes());</span><br><span class="line">    byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">    byte[] bytes &#x3D; new byte[byteBuffer.limit()];</span><br><span class="line">    byteBuffer.get(bytes, 0, 2);</span><br><span class="line">    System.out.println(byteBuffer.position());</span><br><span class="line">    &#x2F;&#x2F;标记当前position位置</span><br><span class="line">    byteBuffer.mark();</span><br><span class="line">    System.out.println(new String(bytes));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;再读取两个</span><br><span class="line">    byteBuffer.get(bytes, byteBuffer.position(), 2);</span><br><span class="line">    System.out.println(byteBuffer.position());</span><br><span class="line">    System.out.println(new String(bytes));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;reset() : 恢复到 mark 的位置</span><br><span class="line">    byteBuffer.reset();</span><br><span class="line">    System.out.println(byteBuffer.position());</span><br><span class="line">    System.out.println((char) byteBuffer.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">ab</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line">abcd</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line">c</span><br></pre></td></tr></table></figure>



<h3 id="hasRemaining-和remaining"><a href="#hasRemaining-和remaining" class="headerlink" title="hasRemaining()和remaining()"></a>hasRemaining()和remaining()</h3><blockquote>
<p>hasRemaining()：判断缓冲区中是否还有剩余数据</p>
<p>remaining()：获取缓冲区中可以操作的数量</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test08</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    byteBuffer.put(<span class="string">"abcde"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    System.out.println(byteBuffer.hasRemaining());</span><br><span class="line">    System.out.println(byteBuffer.remaining());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    byteBuffer.put(<span class="string">"12345"</span>.getBytes());</span><br><span class="line">    System.out.println(byteBuffer.hasRemaining());</span><br><span class="line">    System.out.println(byteBuffer.remaining());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">false</span><br><span class="line">0</span><br></pre></td></tr></table></figure>



<h2 id="直接与非直接缓冲区"><a href="#直接与非直接缓冲区" class="headerlink" title="直接与非直接缓冲区"></a>直接与非直接缓冲区</h2><blockquote>
<p>非直接缓冲区：通过 allocate() 方法分配缓冲区，将缓冲区建立在 JVM 的内存中</p>
<p>直接缓冲区：通过 allocateDirect() 方法分配直接缓冲区，将缓冲区建立在物理内存中。可以提高效率</p>
</blockquote>
<p><img src="https://cdn.static.note.zzrfdsn.cn/images/io/1577535963932.png" alt="1577535963932"></p>
<p><img src="https://cdn.static.note.zzrfdsn.cn/images/io/1577536017071.png" alt="1577536017071"></p>
<ul>
<li>字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在<br>此缓冲区上执行本机 I/O 操作。也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），<br>虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。</li>
<li>直接字节缓冲区可以通过调用此类的 <code>allocateDirect()</code> 工厂方法来创建。此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的<br>本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好<br>处时分配它们。</li>
<li>直接字节缓冲区还可以通过 <code>FileChannel</code> 的 <code>map()</code> 方法 将文件区域直接映射到内存中来创建。该方法返回<code>MappedByteBuffer</code> 。Java 平台的实现有助于通过 JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。</li>
<li>字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 <code>isDirect()</code> 方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//非直接缓存区</span></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    System.out.println(byteBuffer.isDirect());</span><br><span class="line">    <span class="comment">//直接缓存区</span></span><br><span class="line">    ByteBuffer directByteBuffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">    System.out.println(directByteBuffer.isDirect());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>



<h2 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道(Channel)"></a>通道(Channel)</h2><blockquote>
<p>通道（Channel）：由 java.nio.channels 包定义的。Channel 表示 IO 源与目标打开的连接。<br>Channel 类似于传统的“流”。只不过 Channel 本身不能直接访问数据，Channel 只能与Buffer 进行交互。</p>
<p>简而言之就是用于源节点与目标节点的连接。在 Java NIO 中负责缓冲区中数据的传输。Channel 本身不存储数据，因此需要配合缓冲区进行传输。</p>
</blockquote>
<blockquote>
<p>先来<strong>了解</strong>一下计算机的IO原理</p>
</blockquote>
<p><img src="https://cdn.static.note.zzrfdsn.cn/images/io/1577538320259.png" alt="1577538320259"></p>
<p>在Java应用程序要对磁盘中的数据进行读写的时候都要通过read或者write方法调用操作系统提供的IO接口进行读写操作</p>
<p>在早期的时候所有的IO接口都是由CPU中央处理器独立负责的，这样也就是说当程序发出大量的读写请求时CPU的占用率就会变得非常高以至于CPU没有空闲的时间去调度其他的工作</p>
<p>后来操作系统在内存和接口之间加了DMA(Direct Memory Access，直接内存存取)，这个时候如果应用程序再向操作系统发送读写请求，DMA会向CPU申请权限，CPU给(jǐ)予权限后所有的IO操作都将由DMA管理，在DMA控制器的控制下，在传送过程中就不需要中央处理器的参与，这个时候读写操作就不会占用CPU资源，但是大量的IO请求就有可能会造成总线冲突</p>
<p><img src="https://cdn.static.note.zzrfdsn.cn/images/io/1577538836863.png" alt="1577538836863"></p>
<p><img src="http://ww1.sinaimg.cn/large/9150e4e5gy1fy3oj4ctywj204z04kt8r.jpg" alt="9150e4e5gy1fy3oj4ctywj204z04kt8r"></p>
<p>反正到最后就变成了通道，这个东东具有执行I/O指令的能力，并通过执行通道(I/O)程序来控制I/O操作，不需要CPU的介入，所以就提高了CPU的利用率</p>
<p><img src="https://cdn.static.note.zzrfdsn.cn/images/io/1577540113316.png" alt="1577540113316"></p>
<p><img src="http://ww2.sinaimg.cn/large/9150e4e5jw1fcdcmp73ptj204o05kq30.jpg" alt="9150e4e5jw1fcdcmp73ptj204o05kq30"></p>
<h3 id="主要实现类"><a href="#主要实现类" class="headerlink" title="主要实现类"></a>主要实现类</h3><blockquote>
<p>Java 为 Channel 接口提供的最主要实现类如下：</p>
</blockquote>
<p><code>java.nio.channels.Channel</code> 接口：</p>
<ul>
<li><code>FileChannel</code>：用于读取、写入、映射和操作文件的通道。</li>
<li><code>DatagramChannel</code>：通过 UDP 读写网络中的数据通道。</li>
<li><code>SocketChannel</code>：通过 TCP 读写网络中的数据。</li>
<li><code>ServerSocketChannel</code>：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个SocketChannel。</li>
</ul>
<h3 id="获取通道"><a href="#获取通道" class="headerlink" title="获取通道"></a>获取通道</h3><blockquote>
<p>获取通道的一种方式是对支持通道的对象调用getChannel() 方法。支持通道的类如下：</p>
</blockquote>
<ul>
<li>FileInputStream</li>
<li>FileOutputStream</li>
<li>RandomAccessFile</li>
<li>DatagramSocket</li>
<li>Socket</li>
<li>ServerSocket</li>
<li>在 JDK 1.7 中的 NIO.2 针对各个通道提供了静态方法 open()<ul>
<li>在 JDK 1.7 中的 NIO.2 的 Files 工具类的 newByteChannel()</li>
</ul>
</li>
</ul>
<h3 id="通道的数据传输"><a href="#通道的数据传输" class="headerlink" title="通道的数据传输"></a>通道的数据传输</h3><blockquote>
<p>利用通道完成文件的复制（非直接缓冲区）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"resources/1.jpg"</span>);</span><br><span class="line">    FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">"resources/1_copy.jpg"</span>);</span><br><span class="line">    <span class="comment">//创建缓存区</span></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    FileChannel inChannel = in.getChannel();</span><br><span class="line">    FileChannel outChannel = out.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从 Channel 读取数据到 Buffer</span></span><br><span class="line">    <span class="keyword">while</span> (inChannel.read(byteBuffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//切换读取数据的模式</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 Buffer 中数据写入 Channel</span></span><br><span class="line">        outChannel.write(byteBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清空缓冲区</span></span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    <span class="keyword">if</span> (outChannel != <span class="keyword">null</span>) outChannel.close();</span><br><span class="line">    <span class="keyword">if</span> (inChannel != <span class="keyword">null</span>) inChannel.close();</span><br><span class="line">    <span class="keyword">if</span> (out != <span class="keyword">null</span>) out.close();</span><br><span class="line">    <span class="keyword">if</span> (in != <span class="keyword">null</span>) in.close();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"非直接缓冲区耗费时间："</span> + (end - start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>使用直接缓冲区完成文件的复制(内存映射文件)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个用于读的通道</span></span><br><span class="line">    FileChannel inChannel = FileChannel.open(Paths.get(<span class="string">"resources"</span>, <span class="string">"1.jpg"</span>), StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个用于写的通道,因为下面获取的内存映射是读写模式所以这里也要开启读的模式，如果文件不存在还需要能够创建</span></span><br><span class="line">    FileChannel outChannel = FileChannel.open(Paths.get(<span class="string">"resources"</span>, <span class="string">"1_copy_2.jpg"</span>), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内存映射文件</span></span><br><span class="line">    MappedByteBuffer inMapBuffer = inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, inChannel.size());</span><br><span class="line">    MappedByteBuffer outMapBuffer = outChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, inChannel.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接对缓存区进行读写操作,不需要通过通道操作</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[inMapBuffer.limit()];</span><br><span class="line">    inMapBuffer.get(bytes);</span><br><span class="line">    outMapBuffer.put(bytes);</span><br><span class="line"></span><br><span class="line">    outChannel.close();</span><br><span class="line">    inChannel.close();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"直接缓冲区耗费时间："</span> + (end - start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="transferTo-和transferFrom"><a href="#transferTo-和transferFrom" class="headerlink" title="transferTo()和transferFrom()"></a>transferTo()和transferFrom()</h3><blockquote>
<p>将数据从源通道传输到其他 Channel 中</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    FileChannel inChannel = FileChannel.open(Paths.get(<span class="string">"resources"</span>, <span class="string">"1.jpg"</span>), StandardOpenOption.READ);</span><br><span class="line">    FileChannel outChannel = FileChannel.open(Paths.get(<span class="string">"resources"</span>, <span class="string">"1_copy_3.jpg"</span>), StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line">    inChannel.transferTo(<span class="number">0</span>, inChannel.size(), outChannel);</span><br><span class="line">    <span class="comment">//outChannel.transferFrom(inChannel, 0, inChannel.size());</span></span><br><span class="line"></span><br><span class="line">    outChannel.close();</span><br><span class="line">    inChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="分散-Scatter-和聚集-Gather"><a href="#分散-Scatter-和聚集-Gather" class="headerlink" title="分散(Scatter)和聚集(Gather)"></a>分散(Scatter)和聚集(Gather)</h3><blockquote>
<p>分散读取（Scattering Reads）是指从 Channel 中读取的数据“分散”到多个 Buffer 中。</p>
</blockquote>
<p><img src="https://cdn.static.note.zzrfdsn.cn/images/io/1577612307893.png" alt="1577612307893"></p>
<blockquote>
<p>聚集写入（Gathering Writes）是指将多个 Buffer 中的数据“聚集”到 Channel。</p>
</blockquote>
<p><img src="https://cdn.static.note.zzrfdsn.cn/images/io/1577612355504.png" alt="1577612355504"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"resources/a1.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">    <span class="comment">//获取通道</span></span><br><span class="line">    FileChannel inChannel = file.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配指定大小的缓存区</span></span><br><span class="line">    ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">26</span>);</span><br><span class="line">    ByteBuffer buffer2 = ByteBuffer.allocate(<span class="number">102</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分散读取</span></span><br><span class="line">    ByteBuffer[] buffers = &#123;buffer1, buffer2&#125;;</span><br><span class="line">    inChannel.read(buffers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切换读取数据模式</span></span><br><span class="line">    <span class="keyword">for</span> (ByteBuffer buffer : buffers) &#123;</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">//查看每个buffer读取的数据</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.limit()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//聚集写入</span></span><br><span class="line">    RandomAccessFile out = <span class="keyword">new</span> RandomAccessFile(<span class="string">"resources/a1_copy.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">    FileChannel outChannel = out.getChannel();</span><br><span class="line">    outChannel.write(buffers);</span><br><span class="line"></span><br><span class="line">    outChannel.close();</span><br><span class="line">    inChannel.close();</span><br><span class="line">    out.close();</span><br><span class="line">    file.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="FileChannel的常用方法"><a href="#FileChannel的常用方法" class="headerlink" title="FileChannel的常用方法"></a>FileChannel的常用方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int read(ByteBuffer dst)</td>
<td>从 Channel 中读取数据到 ByteBuffer</td>
</tr>
<tr>
<td>long read(ByteBuffer[] dsts)</td>
<td>将 Channel 中的数据“分散”到 ByteBuffer[]</td>
</tr>
<tr>
<td>int write(ByteBuffer src)</td>
<td>将 ByteBuffer 中的数据写入到 Channel</td>
</tr>
<tr>
<td>long write(ByteBuffer[] srcs)</td>
<td>将 ByteBuffer[] 中的数据“聚集”到 Channel</td>
</tr>
<tr>
<td>long position()</td>
<td>返回此通道的文件位置</td>
</tr>
<tr>
<td>FileChannel position(long p)</td>
<td>设置此通道的文件位置</td>
</tr>
<tr>
<td>long size()</td>
<td>返回此通道的文件的当前大小</td>
</tr>
<tr>
<td>FileChannel truncate(long s)</td>
<td>将此通道的文件截取为给定大小</td>
</tr>
<tr>
<td>void force(boolean metaData)</td>
<td>强制将所有对此通道的文件更新写入到存储设备中</td>
</tr>
</tbody></table>
<h2 id="字符集：Charset"><a href="#字符集：Charset" class="headerlink" title="字符集：Charset"></a>字符集：Charset</h2><blockquote>
<p>编码：字符串 -&gt; 字节数组</p>
<p>解码：字节数组  -&gt; 字符串</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//001.txt的编码为GBK</span></span><br><span class="line">    FileChannel channel = FileChannel.open(Paths.get(<span class="string">"resources"</span>, <span class="string">"001.txt"</span>), StandardOpenOption.READ);</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    channel.read(byteBuffer);</span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    <span class="comment">//输出乱码,默认是使用UTF-8解码</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(byteBuffer.array(), <span class="number">0</span>, byteBuffer.limit()));</span><br><span class="line"></span><br><span class="line">    Charset gbk = Charset.forName(<span class="string">"GBK"</span>);</span><br><span class="line">    <span class="comment">//使用GBK编码格式进行解码</span></span><br><span class="line">    CharBuffer decode = gbk.decode(byteBuffer);</span><br><span class="line">    System.out.println(String.valueOf(decode.array()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用GBK编码</span></span><br><span class="line">    ByteBuffer byteBuffer02 = gbk.encode(<span class="string">"我爱你，亲爱的姑娘。。。"</span>);</span><br><span class="line">    <span class="comment">//乱码</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(byteBuffer02.array(), <span class="number">0</span>, byteBuffer02.limit()));</span><br><span class="line">    <span class="comment">//使用GBK解码</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(byteBuffer02.array(), <span class="number">0</span>, byteBuffer02.limit(), gbk));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://cdn.static.note.zzrfdsn.cn/images/io/1577620983665.png" alt="1577620983665"></p>
<h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><blockquote>
<p>传统的 IO 流都是阻塞式的。也就是说，当一个线程调用 read() 或 write() 时，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务。因此，在完成网络通信进行 IO 操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量客户端时，性能急剧下降。</p>
</blockquote>
<blockquote>
<p> Java NIO 是非阻塞模式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。因此，NIO 可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端。</p>
</blockquote>
<ul>
<li>传统阻塞IO方式：客户端向服务器端发送请求，服务器端便开始进行监听客户端的数据是否传过来。这时候客户端在准备自己的数据，而服务器端就需要干等着。即使服务器端是多线程的，但有时一味增加线程数，只会让阻塞的线程越来越多。</li>
<li>NIO的非阻塞方式：将用于传输的通道全部注册到选择器上。</li>
<li>选择器的作用是监控这些通道的IO状况（读，写，连接，接收数据的情况等状况）。</li>
<li>选择器与通道之间的联系：<ul>
<li>通道注册到选择器上</li>
<li>选择器监控通道</li>
<li>当某一通道，某一个事件就绪之后，选择器才会将这个通道分配到服务器端的一个或多个线程上，再继续运行。例如客户端需要发送数据给服务器端，只当客户端所有的数据都准备完毕后，选择器才会将这个注册的通道分配到服务器端的一个或多个线程上。而在客户端准备数据的这段时间，服务器端的线程可以执行别的任务。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.static.note.zzrfdsn.cn/images/io/1577622352000.jpg" alt="1577622352000"></p>
<h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><blockquote>
<p>Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。</p>
</blockquote>
<p><strong>操作步骤：</strong></p>
<ul>
<li>打开 SocketChannel</li>
<li>读写数据</li>
<li>关闭 SocketChannel</li>
</ul>
<blockquote>
<p>Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道，就像标准IO中的ServerSocket一样。</p>
</blockquote>
<h3 id="阻塞式NIO"><a href="#阻塞式NIO" class="headerlink" title="阻塞式NIO"></a>阻塞式NIO</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingNIOTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClient</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取网络通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">7001</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取读取本地文件的通道</span></span><br><span class="line">        FileChannel localFileChannel = FileChannel.open(Paths.get(<span class="string">"resources"</span>, <span class="string">"1.jpg"</span>), StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分配指定大小的缓冲区</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取本地文件，并发送到服务端</span></span><br><span class="line">        <span class="keyword">while</span> (localFileChannel.read(byteBuffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            socketChannel.write(byteBuffer);</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭通道</span></span><br><span class="line">        localFileChannel.close();</span><br><span class="line">        socketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testServer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取服务端网络通道</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//绑定端口号</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">7001</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取本地文件存储通道</span></span><br><span class="line">        FileChannel localFileChannel = FileChannel.open(</span><br><span class="line">                Paths.get(<span class="string">"resources/server/1.jpg"</span>),</span><br><span class="line">                StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取客户端连接的通道</span></span><br><span class="line">        SocketChannel clientSocketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分配指定大小的缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收客户端的数据，并保存到本地</span></span><br><span class="line">        <span class="keyword">while</span> (clientSocketChannel.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            localFileChannel.write(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭通道</span></span><br><span class="line">        clientSocketChannel.close();</span><br><span class="line">        localFileChannel.close();</span><br><span class="line">        serverSocketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingNIOTest02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClient</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取网络通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">7001</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取读取本地文件的通道</span></span><br><span class="line">        FileChannel localFileChannel = FileChannel.open(Paths.get(<span class="string">"resources"</span>, <span class="string">"1.jpg"</span>), StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分配指定大小的缓冲区</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取本地文件，并发送到服务端</span></span><br><span class="line">        <span class="keyword">while</span> (localFileChannel.read(byteBuffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            socketChannel.write(byteBuffer);</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        socketChannel.shutdownOutput();</span><br><span class="line">        <span class="comment">//接收服务端的反馈</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = socketChannel.read(byteBuffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(byteBuffer.array(), <span class="number">0</span>, len));</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭通道</span></span><br><span class="line">        localFileChannel.close();</span><br><span class="line">        socketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testServer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取服务端网络通道</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//绑定端口号</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">7001</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取本地文件存储通道</span></span><br><span class="line">        FileChannel localFileChannel = FileChannel.open(</span><br><span class="line">                Paths.get(<span class="string">"resources/server/1.jpg"</span>),</span><br><span class="line">                StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取客户端连接的通道</span></span><br><span class="line">        SocketChannel clientSocketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分配指定大小的缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收客户端的数据，并保存到本地</span></span><br><span class="line">        <span class="keyword">while</span> (clientSocketChannel.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            localFileChannel.write(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送反馈消息给客户端</span></span><br><span class="line">        buffer.put(<span class="string">"服务端成功接收"</span>.getBytes());</span><br><span class="line">        buffer.flip();</span><br><span class="line">        clientSocketChannel.write(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭通道</span></span><br><span class="line">        clientSocketChannel.close();</span><br><span class="line">        localFileChannel.close();</span><br><span class="line">        serverSocketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="选择器-Selector"><a href="#选择器-Selector" class="headerlink" title="选择器(Selector)"></a>选择器(Selector)</h3><blockquote>
<p>选择器（Selector） 是 SelectableChannle 对象的多路复用器，Selector 可以同时监控多SelectableChannel 的 IO 状况，也就是说，利用 Selector 可使一个单独的线程管理多个 Channel。Selector 是非阻塞 IO 的核心。</p>
</blockquote>
<p><strong>SelectableChannle 的结构如下：</strong></p>
<p><img src="https://cdn.static.note.zzrfdsn.cn/images/io/1577694612406.png" alt="1577694612406"></p>
<h3 id="选择器-Selector-的应用"><a href="#选择器-Selector-的应用" class="headerlink" title="选择器(Selector)的应用"></a>选择器(Selector)的应用</h3><blockquote>
<p>创建 Selector ：通过调用 Selector.open() 方法创建一个 Selector。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>



<blockquote>
<p>向选择器注册通道：SelectableChannel.register(Selector sel, int op</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelector</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//获取socket网络通道</span></span><br><span class="line">    SocketChannel socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">80</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 Selector ：通过调用 Selector.open() 方法创建一个 Selector。</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将SocketChannel切换到非阻塞模式</span></span><br><span class="line">    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向选择器注册通道：</span></span><br><span class="line">    SelectionKey selectionKey = socketChannel.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><ul>
<li><p>当调用 register(Selector sel, int ops) 将通道注册选择器时，选择器对通道的监听事件，需要通过第二个参数 ops 指定。</p>
</li>
<li><p>可以监听的事件类型（可使用 SelectionKey 的四个常量表示）：</p>
<ul>
<li><p>读 : SelectionKey.OP_READ （1）</p>
</li>
<li><p>写 : SelectionKey.OP_WRITE （4）</p>
</li>
<li><p>连接 : SelectionKey.OP_CONNECT （8）</p>
</li>
<li><p>接收 : SelectionKey.OP_ACCEPT （16）</p>
</li>
<li><p>若注册时不止监听一个事件，则可以使用“位或”操作符连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向选择器注册通道：</span></span><br><span class="line">socketChannel.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<blockquote>
<p>SelectionKey：表示 SelectableChannel 和 Selector 之间的注册关系。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作。</p>
</blockquote>
<table>
<thead>
<tr>
<th>方 法</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>int interestOps()</td>
<td>获取感兴趣事件集合</td>
</tr>
<tr>
<td>int readyOps()</td>
<td>获取通道已经准备就绪的操作的集合</td>
</tr>
<tr>
<td>SelectableChannel channel()</td>
<td>获取注册通道</td>
</tr>
<tr>
<td>Selector selector()</td>
<td>返回选择器</td>
</tr>
<tr>
<td>boolean isReadable()</td>
<td>检测 Channal 中读事件是否就绪</td>
</tr>
<tr>
<td>boolean isWritable()</td>
<td>检测 Channal 中写事件是否就绪</td>
</tr>
<tr>
<td>boolean isConnectable()</td>
<td>检测 Channel 中连接是否就绪</td>
</tr>
<tr>
<td>boolean isAcceptable()</td>
<td>检测 Channel 中接收是否就绪</td>
</tr>
</tbody></table>
<h3 id="Selector的常用方法"><a href="#Selector的常用方法" class="headerlink" title="Selector的常用方法"></a>Selector的常用方法</h3><table>
<thead>
<tr>
<th>方 法</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>Set&lt;SelectionKey&gt; keys()</td>
<td>所有的 SelectionKey 集合。代表注册在该Selector上的Channel</td>
</tr>
<tr>
<td>selectedKeys()</td>
<td>被选择的 SelectionKey 集合。返回此Selector的已选择键集</td>
</tr>
<tr>
<td>int select()</td>
<td>监控所有注册的Channel，当它们中间有需要处理的 IO 操作时，该方法返回，并将对应得的 SelectionKey 加入被选择的集合中，该方法返回这些 Channel 的数量。</td>
</tr>
<tr>
<td>int select(long timeout)</td>
<td>可以设置超时时长的 select() 操作</td>
</tr>
<tr>
<td>int selectNow()</td>
<td>执行一个立即返回的 select() 操作，该方法不会阻塞线程</td>
</tr>
<tr>
<td>Selector wakeup()</td>
<td>使一个还未返回的 select() 方法立即返回</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭该选择器</td>
</tr>
</tbody></table>
<h3 id="非阻塞式NIO"><a href="#非阻塞式NIO" class="headerlink" title="非阻塞式NIO"></a>非阻塞式NIO</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonBlockingNIOTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClient</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">7001</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//切换到非阻塞模式</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分配指定大小的缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建标准输入流</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"键入您的昵称："</span>);</span><br><span class="line">        String name = scanner.nextLine();</span><br><span class="line">        System.out.println(<span class="string">"OK，开始聊天吧！"</span>);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            String info = scanner.nextLine();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"quit"</span>.equals(info)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String msg = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(LocalDateTime.now()) + <span class="string">"：\n"</span> + name + <span class="string">"："</span> + info;</span><br><span class="line">            buffer.put(msg.getBytes());</span><br><span class="line">            buffer.flip();</span><br><span class="line">            socketChannel.write(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭通道</span></span><br><span class="line">        socketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testServer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取通道</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">7001</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//切换到非阻塞模式</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取选择器</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将通道注册到选择器，并且指定“监听接收事件”</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//轮询式的获取选择器上已经“准备就绪”的事件</span></span><br><span class="line">        <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//获取当前选择器中所有注册的“选择键(已就绪的监听事件)”</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                <span class="comment">//获取准备“就绪”的事件</span></span><br><span class="line">                SelectionKey sk = it.next();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断具体是什么事件准备就绪</span></span><br><span class="line">                <span class="keyword">if</span> (sk.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">//若“接收就绪”，获取客户端连接</span></span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//切换到非阻模式</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//将该通道注册到选择器上</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">//获取当前选择器上“读就绪”状态的通道</span></span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel) sk.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//分配缓冲区</span></span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="comment">//读取数据,客户端没有关闭，不能判断是否-1,返回的可能是0</span></span><br><span class="line">                    <span class="keyword">while</span> (socketChannel.read(buffer) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.limit()));</span><br><span class="line">                        buffer.clear();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//用完之后取消选择键 SelectionKey，不然下一次循环这个已经就绪的SelectionKey还存在</span></span><br><span class="line">                it.remove();</span><br><span class="line">            &#125; <span class="comment">//end while</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>IDEA控制台单元测试无法输入</p>
<p>点击Help&gt;Edit Custom VM Options，天津哎如下一行，然后重启IDEA</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-Deditable.java.test.console</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>



<h2 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h2><blockquote>
<p>Java NIO中的DatagramChannel是一个能收发UDP包的通道。</p>
</blockquote>
<p><strong>操作步骤：</strong></p>
<ul>
<li>打开 DatagramChannel</li>
<li>接收/发送</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonBlockingNIO_UDPTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSend</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取网络通道</span></span><br><span class="line">        DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置为非阻塞模式</span></span><br><span class="line">        datagramChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"键入你的昵称："</span>);</span><br><span class="line">        String name = scanner.nextLine();</span><br><span class="line">        System.out.println(<span class="string">"OK,开始聊天吧!"</span>);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            String info = scanner.next();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"quit"</span>.equalsIgnoreCase(info)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String msg = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(LocalDateTime.now()) + <span class="string">"：\n"</span> + name + <span class="string">"："</span> + info;</span><br><span class="line">            buffer.put(msg.getBytes());</span><br><span class="line">            buffer.flip();</span><br><span class="line">            datagramChannel.send(buffer, <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">7001</span>));</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        datagramChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReceive</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class="line">        datagramChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">7001</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置为非阻塞模式</span></span><br><span class="line">        datagramChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建选择器</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册到选择器</span></span><br><span class="line">        datagramChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                SelectionKey sk = it.next();</span><br><span class="line">                <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    datagramChannel.receive(buffer);</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.limit()));</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道(pipe)"></a>管道(pipe)</h2><blockquote>
<p>Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。</p>
</blockquote>
<p><img src="https://cdn.static.note.zzrfdsn.cn/images/io/1577706711253.png" alt="1577706711253"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Pipe pipe = Pipe.open();</span><br><span class="line"></span><br><span class="line">    ThreadFactory threadFactory = Executors.defaultThreadFactory();</span><br><span class="line">    ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory);</span><br><span class="line">    <span class="comment">//线程A 将数据写到sink通道</span></span><br><span class="line">    threadPool.execute(() -&gt; &#123;</span><br><span class="line">        Pipe.SinkChannel sinkChannel = pipe.sink();</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"HH:mm:ss"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                buffer.put(formatter.format(LocalDateTime.now()).getBytes());</span><br><span class="line">                buffer.flip();</span><br><span class="line">                sinkChannel.write(buffer);</span><br><span class="line">                buffer.clear();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            sinkChannel.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程B 从source通道读取数据</span></span><br><span class="line">    threadPool.execute(() -&gt;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        Pipe.SourceChannel sourceChannel = pipe.source();</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (sourceChannel.read(buffer) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, buffer.limit()));</span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            sourceChannel.close();</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud" target="_blank" rel="noopener">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
